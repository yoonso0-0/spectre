<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Utilities</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities</div>  </div>
</div><!--header-->
<div class="contents">

<p>A collection of useful classes, functions and metafunctions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacealg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacealg.html">alg</a></td></tr>
<tr class="memdesc:namespacealg"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions wrapping STL algorithms and additional algorithms. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceformaline"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceformaline.html">formaline</a></td></tr>
<tr class="memdesc:namespaceformaline"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions for retrieving system and source tree information. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacefuncl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacefuncl.html">funcl</a></td></tr>
<tr class="memdesc:namespacefuncl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Higher order function objects similar to <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a></code>, etc. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacegsl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacegsl.html">gsl</a></td></tr>
<tr class="memdesc:namespacegsl"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations from the Guideline Support Library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceRegistration"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceRegistration.html">Registration</a></td></tr>
<tr class="memdesc:namespaceRegistration"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helpers for derived class registration. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetmpl2"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetmpl2.html">tmpl2</a></td></tr>
<tr class="memdesc:namespacetmpl2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming things that are not planned to be submitted to Brigand. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetContainerSize.html">GetContainerSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct which retrieves the <code>t.size()</code> for operand <code>t</code>. This will cause a compiler error if no such function exists.  <a href="structGetContainerSize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structGetContainerElement.html">GetContainerElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct for the subscript operator. Returns <code>t[i]</code>  <a href="structGetContainerElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable struct which applies the <code>t.destructive_resize()</code> for operand <code>t</code>. This will cause a compiler error if no such function exists.  <a href="structContainerDestructiveResize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFraction.html">ContinuedFraction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the continued fraction representation of a number.  <a href="classContinuedFraction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classContinuedFractionSummer.html">ContinuedFractionSummer&lt; Fraction &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sum a continued fraction.  <a href="classContinuedFractionSummer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require a pointer to not be a <code>nullptr</code>  <a href="classgsl_1_1not__null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgsl_1_1span.html">gsl::span&lt; ElementType, Extent &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a span/view on a range, which is cheap to copy (one pointer).  <a href="classgsl_1_1span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMakeString.html">MakeString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a string by streaming into object.  <a href="classMakeString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNoSuchType.html">NoSuchType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to mark "no type" or "bad state" for metaprogramming.  <a href="structNoSuchType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOverloader.html">Overloader&lt; Fs &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used for overloading lambdas, useful for lambda-SFINAE.  <a href="classOverloader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPointerVector.html">PointerVector&lt; Type, AF, PF, TF, ExprResultType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A raw pointer endowed with expression template support via the Blaze library.  <a href="structPointerVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRational.html">Rational</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCacheRange.html">CacheRange&lt; Start, End &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCacheEnumeration.html">CacheEnumeration&lt; EnumerationType, Enums &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStaticCache.html">StaticCache&lt; Generator, T, Ranges &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt; Tags &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An associative container that is indexed by structs.  <a href="classtuples_1_1TaggedTuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtmpl2_1_1value__list.html">tmpl2::value_list&lt; T,... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A compile-time list of values of the same type.  <a href="structtmpl2_1_1value__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTypeDisplayer.html">TypeDisplayer&lt;... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get compiler error with type of template parameter.  <a href="structTypeDisplayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmake__list.html">make_list&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction to turn a parameter pack into a typelist.  <a href="structmake__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga265f35910bd218c59dd33acffe0c0b69"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(function)</td></tr>
<tr class="memdesc:ga265f35910bd218c59dd33acffe0c0b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a function that acts similarly to a virtual function, but can take template parameters.  <a href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">More...</a><br /></td></tr>
<tr class="separator:ga265f35910bd218c59dd33acffe0c0b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9d571cd642604cb7bd87bb039ca3760f">SPECTRE_ALWAYS_INLINE</a>&#160;&#160;&#160;inline</td></tr>
<tr class="separator:ga9d571cd642604cb7bd87bb039ca3760f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7b776398a66e9a6bd561c8decf08b47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION_MACRO, ...)</td></tr>
<tr class="memdesc:gad7b776398a66e9a6bd561c8decf08b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro useful for generating many explicit instantiations of function or class templates.  <a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">More...</a><br /></td></tr>
<tr class="separator:gad7b776398a66e9a6bd561c8decf08b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaffde14445f49f65ff4f5b592e44ee71a">LIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gaffde14445f49f65ff4f5b592e44ee71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10d0a221f4d7a706701b806c8135fd7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab10d0a221f4d7a706701b806c8135fd7">UNLIKELY</a>(x)&#160;&#160;&#160;(x)</td></tr>
<tr class="separator:gab10d0a221f4d7a706701b806c8135fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaee1c0cc775bf58891fab30b95a3ac51f">DEFINE_STD_ARRAY_BINOP</a>(RESULT_TYPE,  LTYPE,  RTYPE,  OP_FUNCTION_NAME,  BINARY_OP)</td></tr>
<tr class="memdesc:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares a binary function on an array, intended for binary operators such as <code>+</code>  <a href="group__UtilitiesGroup.html#gaee1c0cc775bf58891fab30b95a3ac51f">More...</a><br /></td></tr>
<tr class="separator:gaee1c0cc775bf58891fab30b95a3ac51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga4409dfaeeba8ef49967a7c98e4709c98">DEFINE_STD_ARRAY_INPLACE_BINOP</a>(LTYPE,  RTYPE,  OP_FUNCTION_NAME,  BINARY_OP)</td></tr>
<tr class="memdesc:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares an in-place binary function on an array, intended for operations such as <code>+=</code>  <a href="group__UtilitiesGroup.html#ga4409dfaeeba8ef49967a7c98e4709c98">More...</a><br /></td></tr>
<tr class="separator:ga4409dfaeeba8ef49967a7c98e4709c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(...)&#160;&#160;&#160;(void)<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td></tr>
<tr class="memdesc:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a parameter pack evaluating the terms from left to right.  <a href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">More...</a><br /></td></tr>
<tr class="separator:ga902d1cefbb10846eb8f5be9f6be5c340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga3f918eda8b76895af59951db3ed6bb81"><td class="memTemplParams" colspan="2">template&lt;typename Sequence &gt; </td></tr>
<tr class="memitem:ga3f918eda8b76895af59951db3ed6bb81"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga3f918eda8b76895af59951db3ed6bb81">make_boost_variant_over</a> = typename detail::make_boost_variant_over_impl&lt; tmpl::remove_duplicates&lt; Sequence &gt; &gt;::type</td></tr>
<tr class="memdesc:ga3f918eda8b76895af59951db3ed6bb81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a boost::variant with all all the types inside the typelist Sequence.  <a href="group__UtilitiesGroup.html#ga3f918eda8b76895af59951db3ed6bb81">More...</a><br /></td></tr>
<tr class="separator:ga3f918eda8b76895af59951db3ed6bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplParams" colspan="2">template&lt;class T , Requires&lt; std::is_pointer&lt; T &gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typename detail::owner_impl&lt; T &gt;::type</td></tr>
<tr class="memdesc:gae57946a2ff8730c87f1e47d636dd5b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a raw pointer as owning its data.  <a href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">More...</a><br /></td></tr>
<tr class="separator:gae57946a2ff8730c87f1e47d636dd5b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:ga084d535585c18d4e80f8ec6052d341a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> = typename Requires_detail::requires_impl&lt; B &gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td></tr>
<tr class="memdesc:ga084d535585c18d4e80f8ec6052d341a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code>  <a href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">More...</a><br /></td></tr>
<tr class="separator:ga084d535585c18d4e80f8ec6052d341a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab28f70a6916977ab004146c9ad07cf5f"><td class="memTemplParams" colspan="2"><a id="gab28f70a6916977ab004146c9ad07cf5f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab28f70a6916977ab004146c9ad07cf5f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tuples::tagged_tuple_from_typelist</b> = typename TaggedTuple_detail::tagged_tuple_typelist_impl&lt; T &gt;::type</td></tr>
<tr class="separator:gab28f70a6916977ab004146c9ad07cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga01ee1794935080949a6995ae7d5e08cc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), true)... &gt; &gt;</td></tr>
<tr class="memdesc:ga01ee1794935080949a6995ae7d5e08cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">More...</a><br /></td></tr>
<tr class="separator:ga01ee1794935080949a6995ae7d5e08cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool, Bs... &gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt; bool,(static_cast&lt; void &gt;(Bs), false)... &gt; &gt;::value &gt;</td></tr>
<tr class="memdesc:ga6e25dbfa539ff4513329969dbcd81c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">More...</a><br /></td></tr>
<tr class="separator:ga6e25dbfa539ff4513329969dbcd81c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gacb1b5375ffa8efe0793310220d2b1d5e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gacb1b5375ffa8efe0793310220d2b1d5e"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gacb1b5375ffa8efe0793310220d2b1d5e">cpp20::swap</a> (T &amp;a, T &amp;b) noexcept</td></tr>
<tr class="separator:gacb1b5375ffa8efe0793310220d2b1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f41a812c1350575cf0e202b59902983"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt1 , class ForwardIt2 &gt; </td></tr>
<tr class="memitem:ga2f41a812c1350575cf0e202b59902983"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2f41a812c1350575cf0e202b59902983">cpp20::iter_swap</a> (ForwardIt1 a, ForwardIt2 b)</td></tr>
<tr class="separator:ga2f41a812c1350575cf0e202b59902983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga0465ea9937545d1d3404c6ab6e71b15c">cpp20::reverse</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:ga0465ea9937545d1d3404c6ab6e71b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memTemplParams" colspan="2">template&lt;class Compare , class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac4ff3f48d2db8cb4a7101602d5f6ed3d">cpp20::next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last, Compare comp)</td></tr>
<tr class="separator:gac4ff3f48d2db8cb4a7101602d5f6ed3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0a66c125713e4158f86b06644a309eb"><td class="memTemplParams" colspan="2">template&lt;class BidirectionalIterator &gt; </td></tr>
<tr class="memitem:gaf0a66c125713e4158f86b06644a309eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf0a66c125713e4158f86b06644a309eb">cpp20::next_permutation</a> (BidirectionalIterator first, BidirectionalIterator last)</td></tr>
<tr class="separator:gaf0a66c125713e4158f86b06644a309eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac84a6c0bd8692c342b9ddf4ba63601e2">cpp20::find</a> (InputIt first, InputIt last, const T &amp;value)</td></tr>
<tr class="separator:gac84a6c0bd8692c342b9ddf4ba63601e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9f222044f3284747287f0c3b5089ccd"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:gad9f222044f3284747287f0c3b5089ccd"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad9f222044f3284747287f0c3b5089ccd">cpp20::find_if</a> (InputIt first, InputIt last, UnaryPredicate p)</td></tr>
<tr class="separator:gad9f222044f3284747287f0c3b5089ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memTemplItemLeft" align="right" valign="top">constexpr InputIt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga77bc48018339ff6ac9402f49a5cd2068">cpp20::find_if_not</a> (InputIt first, InputIt last, UnaryPredicate q)</td></tr>
<tr class="separator:ga77bc48018339ff6ac9402f49a5cd2068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaa46a305d87ee4ae9fede9d55c373286">ddot_</a> (const size_t &amp;N, const double *X, const size_t &amp;INCX, const double *Y, const size_t &amp;INCY)</td></tr>
<tr class="separator:gaaa46a305d87ee4ae9fede9d55c373286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplParams" colspan="2">template&lt;bool UseLibXsmm = false&gt; </td></tr>
<tr class="memitem:gac932a44b57087d32ce5341314437dbbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">dgemm_</a> (const char &amp;TRANSA, const char &amp;TRANSB, const size_t &amp;M, const size_t &amp;N, const size_t &amp;K, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *B, const size_t &amp;LDB, const double &amp;BETA, double *C, const size_t &amp;LDC)</td></tr>
<tr class="memdesc:gac932a44b57087d32ce5341314437dbbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-matrix multiplication.  <a href="group__UtilitiesGroup.html#gac932a44b57087d32ce5341314437dbbd">More...</a><br /></td></tr>
<tr class="separator:gac932a44b57087d32ce5341314437dbbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad4d31316e0975f0a66a60d9ac92756a8">dgemv_</a> (const char &amp;TRANS, const size_t &amp;M, const size_t &amp;N, const double &amp;ALPHA, const double *A, const size_t &amp;LDA, const double *X, const size_t &amp;INCX, const double &amp;BETA, double *Y, const size_t &amp;INCY)</td></tr>
<tr class="memdesc:gad4d31316e0975f0a66a60d9ac92756a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a matrix-vector multiplication.  <a href="group__UtilitiesGroup.html#gad4d31316e0975f0a66a60d9ac92756a8">More...</a><br /></td></tr>
<tr class="separator:gad4d31316e0975f0a66a60d9ac92756a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32e4641766bcfa0da87662aaba91037c"><td class="memTemplParams" colspan="2"><a id="ga32e4641766bcfa0da87662aaba91037c"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga32e4641766bcfa0da87662aaba91037c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga32e4641766bcfa0da87662aaba91037c">type_of_current_state</a> (const boost::variant&lt; Ts... &gt; &amp;variant) noexcept</td></tr>
<tr class="memdesc:ga32e4641766bcfa0da87662aaba91037c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the type name of the current state of the boost::variant. <br /></td></tr>
<tr class="separator:ga32e4641766bcfa0da87662aaba91037c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e6b7719315887d84283779530000ee1"><td class="memTemplParams" colspan="2"><a id="ga7e6b7719315887d84283779530000ee1"></a>
template&lt;typename KeyType , typename T &gt; </td></tr>
<tr class="memitem:ga7e6b7719315887d84283779530000ee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; KeyType, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga7e6b7719315887d84283779530000ee1">clone_unique_ptrs</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; KeyType, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt;&gt; &amp;map) noexcept</td></tr>
<tr class="memdesc:ga7e6b7719315887d84283779530000ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a map of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returns a copy of the map by invoking <code>get_clone()</code> on each element of the input map. <br /></td></tr>
<tr class="separator:ga7e6b7719315887d84283779530000ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc482d04a40c3613df2ac49df93f9323"><td class="memTemplParams" colspan="2"><a id="gadc482d04a40c3613df2ac49df93f9323"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadc482d04a40c3613df2ac49df93f9323"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadc482d04a40c3613df2ac49df93f9323">clone_unique_ptrs</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt;&gt; &amp;vector) noexcept</td></tr>
<tr class="memdesc:gadc482d04a40c3613df2ac49df93f9323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a vector of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code> returns a copy of the vector by invoking <code>get_clone()</code> on each element of the input vector. <br /></td></tr>
<tr class="separator:gadc482d04a40c3613df2ac49df93f9323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0084c31ad1370a7305ac159837d3384"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SubscriptFunction  = GetContainerElement&gt; </td></tr>
<tr class="memitem:gab0084c31ad1370a7305ac159837d3384"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab0084c31ad1370a7305ac159837d3384">get_element</a> (T &amp;t, const size_t i, SubscriptFunction at=<a class="el" href="structGetContainerElement.html">GetContainerElement</a>{}) noexcept</td></tr>
<tr class="memdesc:gab0084c31ad1370a7305ac159837d3384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <code>i</code>th element if <code>T</code> has a subscript operator, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns <code>t</code>.  <a href="group__UtilitiesGroup.html#gab0084c31ad1370a7305ac159837d3384">More...</a><br /></td></tr>
<tr class="separator:gab0084c31ad1370a7305ac159837d3384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48f1ae622586a451d95b26daaac2378e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename SizeFunction  = GetContainerSize&gt; </td></tr>
<tr class="memitem:ga48f1ae622586a451d95b26daaac2378e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga48f1ae622586a451d95b26daaac2378e">get_size</a> (const T &amp;t, SizeFunction size=<a class="el" href="structGetContainerSize.html">GetContainerSize</a>{}) noexcept</td></tr>
<tr class="memdesc:ga48f1ae622586a451d95b26daaac2378e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the size of <code>t</code> if <code>t.size()</code> is a valid expression, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns 1.  <a href="group__UtilitiesGroup.html#ga48f1ae622586a451d95b26daaac2378e">More...</a><br /></td></tr>
<tr class="separator:ga48f1ae622586a451d95b26daaac2378e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ae0c4131a2de652b81b4997e740d5a"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename DestructiveResizeFunction  = ContainerDestructiveResize&gt; </td></tr>
<tr class="memitem:gab9ae0c4131a2de652b81b4997e740d5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab9ae0c4131a2de652b81b4997e740d5a">destructive_resize_components</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Container * &gt; container, const size_t new_size, DestructiveResizeFunction destructive_resize=<a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a>{}) noexcept</td></tr>
<tr class="memdesc:gab9ae0c4131a2de652b81b4997e740d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the size of each component of the container, and resizes if necessary.  <a href="group__UtilitiesGroup.html#gab9ae0c4131a2de652b81b4997e740d5a">More...</a><br /></td></tr>
<tr class="separator:gab9ae0c4131a2de652b81b4997e740d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplParams" colspan="2"><a id="gaccb7d5132ccd60f32c504c51f9d7fb3c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaccb7d5132ccd60f32c504c51f9d7fb3c">dereference_wrapper</a> (T &amp;&amp;t)</td></tr>
<tr class="memdesc:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference object held by a reference wrapper, if a non-reference_wrapper type is passed in then the object is returned. <br /></td></tr>
<tr class="separator:gaccb7d5132ccd60f32c504c51f9d7fb3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed84deeb606f239b8781809d2be69a6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6ed84deeb606f239b8781809d2be69a6">equal_within_roundoff</a> (const double a, const double b, const double eps=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::epsilon() *100.0, const double scale=1.0) noexcept</td></tr>
<tr class="separator:ga6ed84deeb606f239b8781809d2be69a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa46b024995f6a5d70ed31882a9a0bcab"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Classes , typename Base , typename Callable , Requires&lt;(tmpl::size&lt; Classes &gt;::value !=0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gaa46b024995f6a5d70ed31882a9a0bcab"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa46b024995f6a5d70ed31882a9a0bcab">call_with_dynamic_type</a> (Base *const obj, Callable &amp;&amp;f) noexcept</td></tr>
<tr class="memdesc:gaa46b024995f6a5d70ed31882a9a0bcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a functor with the derived type of a base class pointer.  <a href="group__UtilitiesGroup.html#gaa46b024995f6a5d70ed31882a9a0bcab">More...</a><br /></td></tr>
<tr class="separator:gaa46b024995f6a5d70ed31882a9a0bcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplParams" colspan="2">template&lt;typename Fraction , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga6c00908b8856ad6d441d443d22586d0a"><td class="memTemplItemLeft" align="right" valign="top">Fraction&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga6c00908b8856ad6d441d443d22586d0a">simplest_fraction_in_interval</a> (const T1 &amp;end1, const T2 &amp;end2) noexcept</td></tr>
<tr class="memdesc:ga6c00908b8856ad6d441d443d22586d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the fraction in the supplied interval with the smallest denominator.  <a href="group__UtilitiesGroup.html#ga6c00908b8856ad6d441d443d22586d0a">More...</a><br /></td></tr>
<tr class="separator:ga6c00908b8856ad6d441d443d22586d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1b1a8fbda55342653e23c0806e0ee7b"><td class="memTemplParams" colspan="2"><a id="gae1b1a8fbda55342653e23c0806e0ee7b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae1b1a8fbda55342653e23c0806e0ee7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae1b1a8fbda55342653e23c0806e0ee7b">get_output</a> (const T &amp;t) noexcept</td></tr>
<tr class="memdesc:gae1b1a8fbda55342653e23c0806e0ee7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the streamed output of <code>t</code> as a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></code> <br /></td></tr>
<tr class="separator:gae1b1a8fbda55342653e23c0806e0ee7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplParams" colspan="2"><a id="ga2da8b404f35c108209c4ce27c8d50e1c"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2da8b404f35c108209c4ce27c8d50e1c">gsl::narrow_cast</a> (U &amp;&amp;u) noexcept</td></tr>
<tr class="memdesc:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <code>u</code> to a type <code>T</code> where the cast may result in narrowing. <br /></td></tr>
<tr class="separator:ga2da8b404f35c108209c4ce27c8d50e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplParams" colspan="2"><a id="gafaf6db75ede2a9bc2fa4b6b17b8ef128"></a>
template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gafaf6db75ede2a9bc2fa4b6b17b8ef128">gsl::narrow</a> (U u)</td></tr>
<tr class="memdesc:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="mdescLeft">&#160;</td><td class="mdescRight">A checked version of <a class="el" href="group__UtilitiesGroup.html#ga2da8b404f35c108209c4ce27c8d50e1c" title="Cast u to a type T where the cast may result in narrowing.">narrow_cast()</a> that ERRORs if the cast changed the value. <br /></td></tr>
<tr class="separator:gafaf6db75ede2a9bc2fa4b6b17b8ef128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplParams" colspan="2"><a id="ga818f101f2f8bd824a3bc7c2c2361c560"></a>
template&lt;class T , std::size_t N, typename Size &gt; </td></tr>
<tr class="memitem:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memTemplItemLeft" align="right" valign="top">constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga818f101f2f8bd824a3bc7c2c2361c560">gsl::at</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;arr, Size index)</td></tr>
<tr class="memdesc:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid. <br /></td></tr>
<tr class="separator:ga818f101f2f8bd824a3bc7c2c2361c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga188c2766e601fb537e7d34ae70c6ff9d"><td class="memTemplParams" colspan="2">template&lt;class ElementType &gt; </td></tr>
<tr class="memitem:ga188c2766e601fb537e7d34ae70c6ff9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga188c2766e601fb537e7d34ae70c6ff9d">gsl::make_span</a> (ElementType *ptr, typename <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;::index_type count)</td></tr>
<tr class="separator:ga188c2766e601fb537e7d34ae70c6ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9fcbbaa07506a5df5379b64772333d9"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf9fcbbaa07506a5df5379b64772333d9">operator&quot;&quot;_st</a> (const unsigned long long n)</td></tr>
<tr class="separator:gaf9fcbbaa07506a5df5379b64772333d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ed7eef85864542bf2c2e212f86a533"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga08ed7eef85864542bf2c2e212f86a533"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga08ed7eef85864542bf2c2e212f86a533">make_array</a> (Args &amp;&amp;... args) noexcept(noexcept(MakeArray_detail::MakeArray&lt; Size==0 &gt;::template apply&lt; T &gt;(<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;(Size==0 ? Size :Size - 1)&gt;{}, std::forward&lt; Args &gt;(args)...)))</td></tr>
<tr class="memdesc:ga08ed7eef85864542bf2c2e212f86a533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code>  <a href="group__UtilitiesGroup.html#ga08ed7eef85864542bf2c2e212f86a533">More...</a><br /></td></tr>
<tr class="separator:ga08ed7eef85864542bf2c2e212f86a533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f67df443d6136a55de6328f7753ffb"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename T &gt; </td></tr>
<tr class="memitem:gad8f67df443d6136a55de6328f7753ffb"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad8f67df443d6136a55de6328f7753ffb">make_array</a> (T &amp;&amp;t) noexcept(noexcept(MakeArray_detail::MakeArray&lt; Size==0 &gt;::template apply&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;&gt;(<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt;(Size==0 ? Size :Size - 1)&gt;{}, std::forward&lt; T &gt;(t)))) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, Size &gt;</td></tr>
<tr class="memdesc:gad8f67df443d6136a55de6328f7753ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code>  <a href="group__UtilitiesGroup.html#gad8f67df443d6136a55de6328f7753ffb">More...</a><br /></td></tr>
<tr class="separator:gad8f67df443d6136a55de6328f7753ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe93472abfc969727ac3d0d17be9c761"><td class="memTemplParams" colspan="2"><a id="gafe93472abfc969727ac3d0d17be9c761"></a>
template&lt;typename T , typename... V, Requires&lt;(sizeof...(V) &gt; 0)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gafe93472abfc969727ac3d0d17be9c761"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gafe93472abfc969727ac3d0d17be9c761">make_array</a> (T &amp;&amp;t, V &amp;&amp;... values) noexcept(noexcept(<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;{ {std::forward&lt; T &gt;(t), std::forward&lt; V &gt;(values)...}})) -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; typename <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; T &gt;, sizeof...(V)+1 &gt;</td></tr>
<tr class="memdesc:gafe93472abfc969727ac3d0d17be9c761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to initialize a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a> with varying number of arguments. <br /></td></tr>
<tr class="separator:gafe93472abfc969727ac3d0d17be9c761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t size, typename Seq &gt; </td></tr>
<tr class="memitem:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a> (Seq &amp;&amp;seq) noexcept(noexcept(MakeArray_detail::make_array_from_iterator_impl&lt; T, size &gt;(std::forward&lt; Seq &gt;(seq), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; size &gt;{})))</td></tr>
<tr class="memdesc:gaea51ad2c5ef8f8f99279545e1389d056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code>  <a href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">More...</a><br /></td></tr>
<tr class="separator:gaea51ad2c5ef8f8f99279545e1389d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c101f8a7d8a56c76d781f69369ce7a0"><td class="memTemplParams" colspan="2"><a id="ga2c101f8a7d8a56c76d781f69369ce7a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2c101f8a7d8a56c76d781f69369ce7a0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2c101f8a7d8a56c76d781f69369ce7a0">make_signaling_NaN</a> (const T &amp;) noexcept</td></tr>
<tr class="memdesc:ga2c101f8a7d8a56c76d781f69369ce7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an appropriate signaling NaN for fundamantal or multi-field types (such as <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code>). <br /></td></tr>
<tr class="separator:ga2c101f8a7d8a56c76d781f69369ce7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplParams" colspan="2"><a id="ga1eed7cb45692393b257c3987070d1da2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1eed7cb45692393b257c3987070d1da2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1eed7cb45692393b257c3987070d1da2">number_of_digits</a> (const T number)</td></tr>
<tr class="memdesc:ga1eed7cb45692393b257c3987070d1da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of digits in an integer number. <br /></td></tr>
<tr class="separator:ga1eed7cb45692393b257c3987070d1da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab208666192c91f22d2a7b9176ea9b7ce"><td class="memTemplParams" colspan="2">template&lt;typename CoeffsIterable , typename DataType &gt; </td></tr>
<tr class="memitem:gab208666192c91f22d2a7b9176ea9b7ce"><td class="memTemplItemLeft" align="right" valign="top">DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab208666192c91f22d2a7b9176ea9b7ce">evaluate_polynomial</a> (const CoeffsIterable &amp;coeffs, const DataType &amp;x) noexcept</td></tr>
<tr class="memdesc:gab208666192c91f22d2a7b9176ea9b7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate a polynomial \(\sum_{p=0}^N c_p x^p\) with Horner's rule.  <a href="group__UtilitiesGroup.html#gab208666192c91f22d2a7b9176ea9b7ce">More...</a><br /></td></tr>
<tr class="separator:gab208666192c91f22d2a7b9176ea9b7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ac6e1d1e46f4ae6712e87875fa01b7"><td class="memTemplParams" colspan="2"><a id="ga59ac6e1d1e46f4ae6712e87875fa01b7"></a>
template&lt;typename T , Requires&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga59ac6e1d1e46f4ae6712e87875fa01b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga59ac6e1d1e46f4ae6712e87875fa01b7">step_function</a> (const T &amp;arg) noexcept</td></tr>
<tr class="memdesc:ga59ac6e1d1e46f4ae6712e87875fa01b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the Heaviside step function \(\Theta\) for arithmetic types. \(\Theta(0) = 1\). <br /></td></tr>
<tr class="separator:ga59ac6e1d1e46f4ae6712e87875fa01b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be93b92f1d0720fb1f36cb6803d71e3"><td class="memTemplParams" colspan="2">template&lt;size_t N, typename DataType &gt; </td></tr>
<tr class="memitem:ga8be93b92f1d0720fb1f36cb6803d71e3"><td class="memTemplItemLeft" align="right" valign="top">DataType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga8be93b92f1d0720fb1f36cb6803d71e3">smoothstep</a> (const double lower_edge, const double upper_edge, const DataType &amp;arg) noexcept</td></tr>
<tr class="memdesc:ga8be93b92f1d0720fb1f36cb6803d71e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoothly interpolates from 0 to 1 between <code>lower_edge</code> and <code>upper_edge</code> with a Hermite polynomial of degree <code>2 * N + 1</code>.  <a href="group__UtilitiesGroup.html#ga8be93b92f1d0720fb1f36cb6803d71e3">More...</a><br /></td></tr>
<tr class="separator:ga8be93b92f1d0720fb1f36cb6803d71e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac859fe461b8b025882f253595596d0c8"><td class="memTemplParams" colspan="2"><a id="gac859fe461b8b025882f253595596d0c8"></a>
template&lt;typename T , Requires&lt; std::is_arithmetic&lt; T &gt;::value or tt::is_a_v&lt; std::complex, T &gt;&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:gac859fe461b8b025882f253595596d0c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac859fe461b8b025882f253595596d0c8">invsqrt</a> (const T &amp;arg) noexcept</td></tr>
<tr class="memdesc:gac859fe461b8b025882f253595596d0c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the inverse square-root ( \(1/\sqrt{x}\)) for arithmetic and complex types. <br /></td></tr>
<tr class="separator:gac859fe461b8b025882f253595596d0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a3720f381e30ef73f4bd79965a0a1e5"><td class="memTemplParams" colspan="2"><a id="ga0a3720f381e30ef73f4bd79965a0a1e5"></a>
template&lt;typename T , Requires&lt; std::is_arithmetic&lt; T &gt;::value &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga0a3720f381e30ef73f4bd79965a0a1e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga0a3720f381e30ef73f4bd79965a0a1e5">invcbrt</a> (const T &amp;arg) noexcept</td></tr>
<tr class="memdesc:ga0a3720f381e30ef73f4bd79965a0a1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the inverse cube-root ( \(1/\sqrt[3]{x}\)) for arithmetic types. <br /></td></tr>
<tr class="separator:ga0a3720f381e30ef73f4bd79965a0a1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed2d71b6d2a2931b43f7953821a23e24"><td class="memTemplParams" colspan="2"><a id="gaed2d71b6d2a2931b43f7953821a23e24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed2d71b6d2a2931b43f7953821a23e24"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaed2d71b6d2a2931b43f7953821a23e24">sgn</a> (const T &amp;val) noexcept</td></tr>
<tr class="memdesc:gaed2d71b6d2a2931b43f7953821a23e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sign function of <code>val</code> defined as <code>1</code> if <code>val &gt; 0</code>, <code>0</code> if <code>val == 0</code>, and <code>-1</code> if <code>val &lt; 0</code>. <br /></td></tr>
<tr class="separator:gaed2d71b6d2a2931b43f7953821a23e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memTemplParams" colspan="2">template&lt;class ForwardIterator , class T &gt; </td></tr>
<tr class="memitem:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga218ddc950e1c70d86bf6455664d0b5f1">cpp2b::iota</a> (ForwardIterator first, ForwardIterator last, T value)</td></tr>
<tr class="separator:ga218ddc950e1c70d86bf6455664d0b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memTemplParams" colspan="2">template&lt;class InputIt , class T &gt; </td></tr>
<tr class="memitem:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa3be3b8a2b80d0c3837f82d82e5f25f5">cpp2b::accumulate</a> (InputIt first, InputIt last, T init)</td></tr>
<tr class="separator:gaa3be3b8a2b80d0c3837f82d82e5f25f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2551ec8708f0bbd6ff2306b499e508f"><td class="memTemplParams" colspan="2"><a id="gad2551ec8708f0bbd6ff2306b499e508f"></a>
template&lt;class... Fs&gt; </td></tr>
<tr class="memitem:gad2551ec8708f0bbd6ff2306b499e508f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOverloader.html">Overloader</a>&lt; Fs... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad2551ec8708f0bbd6ff2306b499e508f">make_overloader</a> (Fs... fs)</td></tr>
<tr class="memdesc:gad2551ec8708f0bbd6ff2306b499e508f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <code><a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE.">Overloader</a>&lt;Fs...&gt;</code>, see <a class="el" href="classOverloader.html" title="Used for overloading lambdas, useful for lambda-SFINAE.">Overloader</a> for details. <br /></td></tr>
<tr class="separator:gad2551ec8708f0bbd6ff2306b499e508f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21441bd61f4925d8337487fa2c997ab3"><td class="memTemplParams" colspan="2"><a id="ga21441bd61f4925d8337487fa2c997ab3"></a>
template&lt;typename ForwardIt , typename Func &gt; </td></tr>
<tr class="memitem:ga21441bd61f4925d8337487fa2c997ab3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga21441bd61f4925d8337487fa2c997ab3">sequence_print_helper</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end, Func f) noexcept</td></tr>
<tr class="memdesc:ga21441bd61f4925d8337487fa2c997ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the function f(out, it) to each item from begin to end, separated by commas and surrounded by parens. <br /></td></tr>
<tr class="separator:ga21441bd61f4925d8337487fa2c997ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3f2549b502159340b4e76e325e3f5"><td class="memTemplParams" colspan="2"><a id="gac9d3f2549b502159340b4e76e325e3f5"></a>
template&lt;typename ForwardIt &gt; </td></tr>
<tr class="memitem:gac9d3f2549b502159340b4e76e325e3f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gac9d3f2549b502159340b4e76e325e3f5">sequence_print_helper</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end) noexcept</td></tr>
<tr class="memdesc:gac9d3f2549b502159340b4e76e325e3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints all the items as a comma separated list surrounded by parens. <br /></td></tr>
<tr class="separator:gac9d3f2549b502159340b4e76e325e3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa86214e3a4760293a956acb6ad56942d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIt , typename Func &gt; </td></tr>
<tr class="memitem:gaa86214e3a4760293a956acb6ad56942d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa86214e3a4760293a956acb6ad56942d">unordered_print_helper</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;out, ForwardIt &amp;&amp;begin, ForwardIt &amp;&amp;end, Func f) noexcept</td></tr>
<tr class="separator:gaa86214e3a4760293a956acb6ad56942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5051536555a38beaf3cbe4784bb4002"><td class="memTemplParams" colspan="2">template&lt;typename... Ranges, typename Generator &gt; </td></tr>
<tr class="memitem:gab5051536555a38beaf3cbe4784bb4002"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab5051536555a38beaf3cbe4784bb4002">make_static_cache</a> (Generator &amp;&amp;generator) noexcept</td></tr>
<tr class="separator:gab5051536555a38beaf3cbe4784bb4002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be082292cf46aa7a006b44e729474e7"><td class="memTemplParams" colspan="2"><a id="ga2be082292cf46aa7a006b44e729474e7"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:ga2be082292cf46aa7a006b44e729474e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga2be082292cf46aa7a006b44e729474e7">all_but_specified_element_of</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a, const size_t element_to_remove) noexcept</td></tr>
<tr class="memdesc:ga2be082292cf46aa7a006b44e729474e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array omitting one element. <br /></td></tr>
<tr class="separator:ga2be082292cf46aa7a006b44e729474e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf56b8d2cde45404481339fbafcf19e39"><td class="memTemplParams" colspan="2"><a id="gaf56b8d2cde45404481339fbafcf19e39"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gaf56b8d2cde45404481339fbafcf19e39"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf56b8d2cde45404481339fbafcf19e39">insert_element</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; a, const size_t element_to_add, T value) noexcept</td></tr>
<tr class="memdesc:gaf56b8d2cde45404481339fbafcf19e39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array adding one element. <br /></td></tr>
<tr class="separator:gaf56b8d2cde45404481339fbafcf19e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memTemplParams" colspan="2"><a id="gabddc5fbff7dc002caf6472d5c782b11b"></a>
template&lt;typename T , size_t Dim&gt; </td></tr>
<tr class="memitem:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim+1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gabddc5fbff7dc002caf6472d5c782b11b">prepend</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;a, T value) noexcept</td></tr>
<tr class="memdesc:gabddc5fbff7dc002caf6472d5c782b11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an array from an existing array prepending a value. <br /></td></tr>
<tr class="separator:gabddc5fbff7dc002caf6472d5c782b11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05223223c63459beb75c170fa104ca57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga05223223c63459beb75c170fa104ca57"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga05223223c63459beb75c170fa104ca57">magnitude</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga05223223c63459beb75c170fa104ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Euclidean magnitude of the elements of the array.  <a href="group__UtilitiesGroup.html#ga05223223c63459beb75c170fa104ca57">More...</a><br /></td></tr>
<tr class="separator:ga05223223c63459beb75c170fa104ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9752049086a20f017376e22ad169e47"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t Dim, typename F &gt; </td></tr>
<tr class="memitem:gaa9752049086a20f017376e22ad169e47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa9752049086a20f017376e22ad169e47">map_array</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;array, const F &amp;f) noexcept</td></tr>
<tr class="separator:gaa9752049086a20f017376e22ad169e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a857ea4c010222258f6b7043e7ca5ea"><td class="memTemplParams" colspan="2"><a id="ga5a857ea4c010222258f6b7043e7ca5ea"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a857ea4c010222258f6b7043e7ca5ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga5a857ea4c010222258f6b7043e7ca5ea">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga5a857ea4c010222258f6b7043e7ca5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>. <br /></td></tr>
<tr class="separator:ga5a857ea4c010222258f6b7043e7ca5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b79de8b7fc5ce9e82abcfb3462c9ec5"><td class="memTemplParams" colspan="2"><a id="ga9b79de8b7fc5ce9e82abcfb3462c9ec5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga9b79de8b7fc5ce9e82abcfb3462c9ec5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9b79de8b7fc5ce9e82abcfb3462c9ec5">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga9b79de8b7fc5ce9e82abcfb3462c9ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>. <br /></td></tr>
<tr class="separator:ga9b79de8b7fc5ce9e82abcfb3462c9ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89764c6408c1f5cd42bc200486d69242"><td class="memTemplParams" colspan="2"><a id="ga89764c6408c1f5cd42bc200486d69242"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga89764c6408c1f5cd42bc200486d69242"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga89764c6408c1f5cd42bc200486d69242">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>&lt; T &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga89764c6408c1f5cd42bc200486d69242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/deque.html">std::deque</a>. <br /></td></tr>
<tr class="separator:ga89764c6408c1f5cd42bc200486d69242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80caef68489ec044291edee80f908449"><td class="memTemplParams" colspan="2"><a id="ga80caef68489ec044291edee80f908449"></a>
template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:ga80caef68489ec044291edee80f908449"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga80caef68489ec044291edee80f908449">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, N &gt; &amp;a) noexcept</td></tr>
<tr class="memdesc:ga80caef68489ec044291edee80f908449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>. <br /></td></tr>
<tr class="separator:ga80caef68489ec044291edee80f908449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325c1aa4e0b973a0c2d5e06e520f9f12"><td class="memTemplParams" colspan="2"><a id="ga325c1aa4e0b973a0c2d5e06e520f9f12"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga325c1aa4e0b973a0c2d5e06e520f9f12"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga325c1aa4e0b973a0c2d5e06e520f9f12">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Args... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:ga325c1aa4e0b973a0c2d5e06e520f9f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for tuples. <br /></td></tr>
<tr class="separator:ga325c1aa4e0b973a0c2d5e06e520f9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59ccc440263d8ac121421332824a6f6c"><td class="memTemplParams" colspan="2"><a id="ga59ccc440263d8ac121421332824a6f6c"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:ga59ccc440263d8ac121421332824a6f6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga59ccc440263d8ac121421332824a6f6c">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:ga59ccc440263d8ac121421332824a6f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:ga59ccc440263d8ac121421332824a6f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc2ee6d0503fea7bcbb6de4a3460a077"><td class="memTemplParams" colspan="2"><a id="gabc2ee6d0503fea7bcbb6de4a3460a077"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gabc2ee6d0503fea7bcbb6de4a3460a077"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gabc2ee6d0503fea7bcbb6de4a3460a077">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m) noexcept</td></tr>
<tr class="memdesc:gabc2ee6d0503fea7bcbb6de4a3460a077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output all the key, value pairs of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gabc2ee6d0503fea7bcbb6de4a3460a077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12f928f2f24f35c2283fb3a3471f5e80"><td class="memTemplParams" colspan="2"><a id="ga12f928f2f24f35c2283fb3a3471f5e80"></a>
template&lt;typename T , typename H &gt; </td></tr>
<tr class="memitem:ga12f928f2f24f35c2283fb3a3471f5e80"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga12f928f2f24f35c2283fb3a3471f5e80">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>&lt; T, H &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ga12f928f2f24f35c2283fb3a3471f5e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_set.html">std::unordered_set</a>. <br /></td></tr>
<tr class="separator:ga12f928f2f24f35c2283fb3a3471f5e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9c5288383a6353698fd9630bbb0f234"><td class="memTemplParams" colspan="2"><a id="gad9c5288383a6353698fd9630bbb0f234"></a>
template&lt;typename T , typename C &gt; </td></tr>
<tr class="memitem:gad9c5288383a6353698fd9630bbb0f234"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad9c5288383a6353698fd9630bbb0f234">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>&lt; T, C &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:gad9c5288383a6353698fd9630bbb0f234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output the items of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/set.html">std::set</a>. <br /></td></tr>
<tr class="separator:gad9c5288383a6353698fd9630bbb0f234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5af8fce009b5c67f11a00a5949c028f4"><td class="memTemplParams" colspan="2"><a id="ga5af8fce009b5c67f11a00a5949c028f4"></a>
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga5af8fce009b5c67f11a00a5949c028f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga5af8fce009b5c67f11a00a5949c028f4">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; T &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:ga5af8fce009b5c67f11a00a5949c028f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>. <br /></td></tr>
<tr class="separator:ga5af8fce009b5c67f11a00a5949c028f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9045d540ebe626ccae39ff049e4f4c37"><td class="memTemplParams" colspan="2"><a id="ga9045d540ebe626ccae39ff049e4f4c37"></a>
template&lt;typename T , Requires&lt; tt::is_streamable&lt; std::ostream, T &gt;::value &gt; &gt; </td></tr>
<tr class="memitem:ga9045d540ebe626ccae39ff049e4f4c37"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9045d540ebe626ccae39ff049e4f4c37">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; T &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:ga9045d540ebe626ccae39ff049e4f4c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>. <br /></td></tr>
<tr class="separator:ga9045d540ebe626ccae39ff049e4f4c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a2ab86b466642aa383a85ead968cf5"><td class="memTemplParams" colspan="2"><a id="gae7a2ab86b466642aa383a85ead968cf5"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gae7a2ab86b466642aa383a85ead968cf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gae7a2ab86b466642aa383a85ead968cf5">operator&lt;&lt;</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; T, U &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gae7a2ab86b466642aa383a85ead968cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream operator for <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>. <br /></td></tr>
<tr class="separator:gae7a2ab86b466642aa383a85ead968cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplParams" colspan="2"><a id="ga495b431a620b10beb24f1afc90b77e20"></a>
template&lt;typename K , typename V , typename H &gt; </td></tr>
<tr class="memitem:ga495b431a620b10beb24f1afc90b77e20"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga495b431a620b10beb24f1afc90b77e20">keys_of</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; K, V, H &gt; &amp;m)</td></tr>
<tr class="memdesc:ga495b431a620b10beb24f1afc90b77e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>. <br /></td></tr>
<tr class="separator:ga495b431a620b10beb24f1afc90b77e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplParams" colspan="2"><a id="gaf707b57628e9425c91d92eb278a52c99"></a>
template&lt;typename K , typename V , typename C &gt; </td></tr>
<tr class="memitem:gaf707b57628e9425c91d92eb278a52c99"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf707b57628e9425c91d92eb278a52c99">keys_of</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>&lt; K, V, C &gt; &amp;m)</td></tr>
<tr class="memdesc:gaf707b57628e9425c91d92eb278a52c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a string containing the keys of a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/map.html">std::map</a>. <br /></td></tr>
<tr class="separator:gaf707b57628e9425c91d92eb278a52c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga9a7c7ee897f581360154a3676d5f7ab9">formatted_string</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;fmt, Args... args)</td></tr>
<tr class="memdesc:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a string like printf.  <a href="group__UtilitiesGroup.html#ga9a7c7ee897f581360154a3676d5f7ab9">More...</a><br /></td></tr>
<tr class="separator:ga9a7c7ee897f581360154a3676d5f7ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memItemLeft" align="right" valign="top"><a id="gaa9e9df95875a2fa4b6ec2acfe7fa26ff"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaa9e9df95875a2fa4b6ec2acfe7fa26ff">current_date_and_time</a> ()</td></tr>
<tr class="memdesc:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current date and time. <br /></td></tr>
<tr class="separator:gaa9e9df95875a2fa4b6ec2acfe7fa26ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplParams" colspan="2"><a id="gaf29c2fe540b02e47a11c1ff9287bf169"></a>
template&lt;class Tag , class... Tags&gt; </td></tr>
<tr class="memitem:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memTemplItemLeft" align="right" valign="top">constexpr const Tag::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaf29c2fe540b02e47a11c1ff9287bf169">tuples::get</a> (const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t) noexcept</td></tr>
<tr class="memdesc:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the element of <code>Tag</code> in the <a class="el" href="classtuples_1_1TaggedTuple.html" title="An associative container that is indexed by structs.">TaggedTuple</a>. <br /></td></tr>
<tr class="separator:gaf29c2fe540b02e47a11c1ff9287bf169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memTemplParams" colspan="2">template&lt;typename ApplyTags , typename F , typename... Tags&gt; </td></tr>
<tr class="memitem:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab0d5e7fa5e0aa31f06200f691d74300b">tuples::apply</a> (F &amp;&amp;f, const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;t)</td></tr>
<tr class="memdesc:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack.  <a href="group__UtilitiesGroup.html#gab0d5e7fa5e0aa31f06200f691d74300b">More...</a><br /></td></tr>
<tr class="separator:gab0d5e7fa5e0aa31f06200f691d74300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">expand_pack</a> (Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:ga45da409b9b03a4ad18e76036ab5a853c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows zero-cost unordered expansion of a parameter.  <a href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">More...</a><br /></td></tr>
<tr class="separator:ga45da409b9b03a4ad18e76036ab5a853c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb2a89d7a8daca3527693c77ab04f0b"><td class="memTemplParams" colspan="2"><a id="gaccb2a89d7a8daca3527693c77ab04f0b"></a>
template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:gaccb2a89d7a8daca3527693c77ab04f0b"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaccb2a89d7a8daca3527693c77ab04f0b">get_first_argument</a> (T &amp;&amp;t, Ts &amp;&amp;...) noexcept</td></tr>
<tr class="memdesc:gaccb2a89d7a8daca3527693c77ab04f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first argument of a parameter pack. <br /></td></tr>
<tr class="separator:gaccb2a89d7a8daca3527693c77ab04f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:ga91227dc4aa14972b7b2e7070719d061b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:ga91227dc4aa14972b7b2e7070719d061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">More...</a><br /></td></tr>
<tr class="separator:ga91227dc4aa14972b7b2e7070719d061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplParams" colspan="2">template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </td></tr>
<tr class="memitem:gad65147320c04e61267089a58d71a6302"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_transform_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence</a>&lt; sizeof...(Elements)&gt;{}, args...)))</td></tr>
<tr class="memdesc:gad65147320c04e61267089a58d71a6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a transform over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>.  <a href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">More...</a><br /></td></tr>
<tr class="separator:gad65147320c04e61267089a58d71a6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f2550f464834199603ab935620cfb46"><td class="memTemplParams" colspan="2">template&lt;size_t Start, size_t Stop, typename Tuple &gt; </td></tr>
<tr class="memitem:ga1f2550f464834199603ab935620cfb46"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga1f2550f464834199603ab935620cfb46">tuple_slice</a> (Tuple &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:ga1f2550f464834199603ab935620cfb46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee29910f2f9d5bc27cdc77cf604bd41"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Tuple &gt; </td></tr>
<tr class="memitem:gaaee29910f2f9d5bc27cdc77cf604bd41"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gaaee29910f2f9d5bc27cdc77cf604bd41">tuple_head</a> (Tuple &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:gaaee29910f2f9d5bc27cdc77cf604bd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4355f2be0dea656e459cab9a500c6a8e"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Tuple &gt; </td></tr>
<tr class="memitem:ga4355f2be0dea656e459cab9a500c6a8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga4355f2be0dea656e459cab9a500c6a8e">tuple_tail</a> (Tuple &amp;&amp;tuple) noexcept</td></tr>
<tr class="separator:ga4355f2be0dea656e459cab9a500c6a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae6888e4cbdcbc1166e32898ae9429a"><td class="memTemplParams" colspan="2">template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </td></tr>
<tr class="memitem:gadae6888e4cbdcbc1166e32898ae9429a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadae6888e4cbdcbc1166e32898ae9429a">outer_product</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultVectorType * &gt; result, const LhsVectorType &amp;lhs, const RhsVectorType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:gadae6888e4cbdcbc1166e32898ae9429a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the outer product between two vectors.  <a href="group__UtilitiesGroup.html#gadae6888e4cbdcbc1166e32898ae9429a">More...</a><br /></td></tr>
<tr class="separator:gadae6888e4cbdcbc1166e32898ae9429a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd9ead5cb45cd6ce2c4680cd82d861cb"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:gadd9ead5cb45cd6ce2c4680cd82d861cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gadd9ead5cb45cd6ce2c4680cd82d861cb">fill_with_n_copies</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt; result, const VectorType &amp;to_copy, const size_t times_to_copy) noexcept</td></tr>
<tr class="memdesc:gadd9ead5cb45cd6ce2c4680cd82d861cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence.  <a href="group__UtilitiesGroup.html#gadd9ead5cb45cd6ce2c4680cd82d861cb">More...</a><br /></td></tr>
<tr class="separator:gadd9ead5cb45cd6ce2c4680cd82d861cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ef3eefc9ddb3dc4befdc2c232a1c541"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga7ef3eefc9ddb3dc4befdc2c232a1c541">wrap_text</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> str, size_t line_length, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;indentation=&quot;&quot;) noexcept</td></tr>
<tr class="memdesc:ga7ef3eefc9ddb3dc4befdc2c232a1c541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap the string <code>str</code> so that it is no longer than <code>line_length</code> and indent each new line with <code>indentation</code>. The first line is also indented.  <a href="group__UtilitiesGroup.html#ga7ef3eefc9ddb3dc4befdc2c232a1c541">More...</a><br /></td></tr>
<tr class="separator:ga7ef3eefc9ddb3dc4befdc2c232a1c541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:gab78389fadf763e3693ce893fad5d7fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">tmpl2::flat_all_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:gab78389fadf763e3693ce893fad5d7fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical AND between bools 'B"".  <a href="group__UtilitiesGroup.html#gab78389fadf763e3693ce893fad5d7fba">More...</a><br /></td></tr>
<tr class="separator:gab78389fadf763e3693ce893fad5d7fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplParams" colspan="2">template&lt;bool... Bs&gt; </td></tr>
<tr class="memitem:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">tmpl2::flat_any_v</a> = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td></tr>
<tr class="memdesc:ga8a328cb983ebb1947b0eb9d924f40253"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-short-circuiting logical OR between bools 'B"".  <a href="group__UtilitiesGroup.html#ga8a328cb983ebb1947b0eb9d924f40253">More...</a><br /></td></tr>
<tr class="separator:ga8a328cb983ebb1947b0eb9d924f40253"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of useful classes, functions and metafunctions. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga265f35910bd218c59dd33acffe0c0b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga265f35910bd218c59dd33acffe0c0b69">&#9670;&nbsp;</a></span>DEFINE_FAKE_VIRTUAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_FAKE_VIRTUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="comment">/* This struct is only needed for producing an error if the function */</span>      \</div>
<div class="line">  <span class="comment">/* is not overridden in the derived class. */</span>                                \</div>
<div class="line">  template &lt;typename Base&gt;                                                     \</div>
<div class="line">  struct FakeVirtualInherit_##function : <span class="keyword">public</span> Base {                         \</div>
<div class="line">    using Base::Base;                                                          \</div>
<div class="line">    <span class="comment">/* clang-tidy: I think &quot;= delete&quot; was overlooked in the guideline */</span>       \</div>
<div class="line">    void <span class="keyword">function</span>(...) <span class="keyword">const</span> = <span class="keyword">delete</span>; <span class="comment">/* NOLINT */</span>                            \</div>
<div class="line">  };                                                                           \</div>
<div class="line">                                                                               \</div>
<div class="line">  template &lt;<span class="keyword">typename</span> Classes, <span class="keyword">typename</span>... TArgs, <span class="keyword">typename</span> Base,                \</div>
<div class="line">            typename... Args&gt;                                                  \</div>
<div class="line">  decltype(<span class="keyword">auto</span>) fake_virtual_<span class="preprocessor">##function(Base* obj, Args&amp;&amp;... args) noexcept { \</span></div>
<div class="line"><span class="preprocessor">    </span><span class="comment">/* NOLINTNEXTLINE(misc-macro-parentheses) */</span><span class="preprocessor">                               \</span></div>
<div class="line"><span class="preprocessor">    return call_with_dynamic_type&lt;decltype(obj-&gt;template function&lt;TArgs...&gt;(   \</span></div>
<div class="line"><span class="preprocessor">                                      args...)), </span><span class="comment">/* NOLINT */</span><span class="preprocessor">                  \</span></div>
<div class="line"><span class="preprocessor">                                  Classes&gt;(                                    \</span></div>
<div class="line"><span class="preprocessor">        obj, [&amp;args...](auto* const dynamic_obj) noexcept -&gt; decltype(auto) {  \</span></div>
<div class="line"><span class="preprocessor">          static_assert(                                                       \</span></div>
<div class="line"><span class="preprocessor">              std::is_base_of_v&lt;typename Base::Inherit,                        \</span></div>
<div class="line"><span class="preprocessor">                                std::decay_t&lt;decltype(*dynamic_obj)&gt;&gt;,         \</span></div>
<div class="line"><span class="preprocessor">              &quot;Derived class does not inherit from Base::Inherit&quot;);            \</span></div>
<div class="line"><span class="preprocessor">          </span><span class="comment">/* clang-tidy: macro arg in parentheses */</span><span class="preprocessor">                           \</span></div>
<div class="line"><span class="preprocessor">          return dynamic_obj-&gt;template function&lt;TArgs...&gt;(</span><span class="comment">/* NOLINT */</span><span class="preprocessor">         \</span></div>
<div class="line"><span class="preprocessor">                                                          std::forward&lt;Args&gt;(  \</span></div>
<div class="line"><span class="preprocessor">                                                              args)...);       \</span></div>
<div class="line"><span class="preprocessor">        });                                                                    \</span></div>
<div class="line"><span class="preprocessor">  }</span></div>
</div><!-- fragment -->
<p>Define a function that acts similarly to a virtual function, but can take template parameters. </p>
<h3>Details</h3>
<p><code><a class="el" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69" title="Define a function that acts similarly to a virtual function, but can take template parameters.">DEFINE_FAKE_VIRTUAL(func)</a></code> defines the function <code>fake_virtual_func</code> and the struct <code>FakeVirtualInherit_func</code>. It should usually be called in a detail namespace.</p>
<p>A base class <code>Base</code> using this functionality should define a type </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func&lt;Base&gt;;</div>
</div><!-- fragment --><p> and a member function <code>func</code> wrapping <code>fake_virtual_func</code>, with the wrapper passing the derived classes as a typelist as the first template argument and the <code>this</code> pointer as the first normal argument.</p>
<p>Derived classes should then inherit from <code>Base::Inherit</code> instead of directly from <code>Base</code>. (<code>Base::Inherit</code> inherits from <code>Base</code>.)</p>
<p>If the base class has no pure virtual functions remaining it will generally be desirable to mark the constructors and assignment operators protected so that a bare base class cannot be instantiated.</p>
<p>If it is necessary to use multiple fake virtual functions with the same base class, the <code>Inherit</code> definition can nest the fake virtual classes: </p><div class="fragment"><div class="line"><span class="keyword">using</span> Inherit = FakeVirtualInherit_func1&lt;FakeVirtualInherit_func2&lt;Base&gt;&gt;;</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line"><a class="code" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a>(fv)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Derived;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Base {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using</span> Inherit = FakeVirtualInherit_fv&lt;Base&gt;;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">protected</span>:</div>
<div class="line">  Base() = <span class="keywordflow">default</span>;</div>
<div class="line">  Base(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  Base(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  Base&amp; operator=(<span class="keyword">const</span> Base&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  Base&amp; operator=(Base&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> ~Base() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> fake_virtual_fv&lt;tmpl::list&lt;Derived&gt;, T&gt;(<span class="keyword">this</span>, x);</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Derived : <span class="keyword">public</span> Base::Inherit {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">int</span> fv(<span class="keywordtype">int</span> x) {</div>
<div class="line">    <span class="keywordflow">return</span> x + 3;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#gaa46b024995f6a5d70ed31882a9a0bcab" title="Call a functor with the derived type of a base class pointer.">call_with_dynamic_type</a> </dd></dl>

</div>
</div>
<a id="gaee1c0cc775bf58891fab30b95a3ac51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee1c0cc775bf58891fab30b95a3ac51f">&#9670;&nbsp;</a></span>DEFINE_STD_ARRAY_BINOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_STD_ARRAY_BINOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RESULT_TYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OP_FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BINARY_OP&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim&gt;                                                     \</div>
<div class="line">  std::array&lt;RESULT_TYPE, Dim&gt; OP_FUNCTION_NAME(                            \</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;LTYPE, Dim&gt;</a>&amp; lhs,                                    \</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;RTYPE, Dim&gt;</a>&amp; rhs) noexcept {                         \</div>
<div class="line">    std::array&lt;RESULT_TYPE, Dim&gt; result; <span class="comment">/*NOLINT*/</span>                         \</div>
<div class="line">    std::transform(lhs.begin(), lhs.end(), rhs.begin(), result.begin(),     \</div>
<div class="line">                   BINARY_OP);                                              \</div>
<div class="line">    return result;                                                          \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Declares a binary function on an array, intended for binary operators such as <code>+</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RESULT_TYPE</td><td>the <code>value_type</code> that is the result of the operation (e.g. <code>A</code> for resulting <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;A,2&gt;</code>)</td></tr>
    <tr><td class="paramname">LTYPE</td><td>the <code>value_type</code> of the first argument of the function (so the left value if the function is an operator overload)</td></tr>
    <tr><td class="paramname">RTYPE</td><td>the <code>value_type</code> of the second argument of the function</td></tr>
    <tr><td class="paramname">OP_FUNCTION_NAME</td><td>the function which should be declared (e.g. <code>operator+</code>)</td></tr>
    <tr><td class="paramname">BINARY_OP</td><td>the binary function which should be applied elementwise to the pair of arrays. (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a>&lt;&gt;()</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4409dfaeeba8ef49967a7c98e4709c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4409dfaeeba8ef49967a7c98e4709c98">&#9670;&nbsp;</a></span>DEFINE_STD_ARRAY_INPLACE_BINOP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFINE_STD_ARRAY_INPLACE_BINOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">LTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">RTYPE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">OP_FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">BINARY_OP&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim&gt;                                                \</div>
<div class="line">  std::array&lt;LTYPE, Dim&gt;&amp; OP_FUNCTION_NAME(                            \</div>
<div class="line">      <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;LTYPE, Dim&gt;</a>&amp; lhs,                                     \</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;RTYPE, Dim&gt;</a>&amp; rhs) noexcept {                    \</div>
<div class="line">    std::transform(lhs.begin(), lhs.end(), rhs.begin(), lhs.begin(),   \</div>
<div class="line">                   BINARY_OP);                                         \</div>
<div class="line">    return lhs;                                                        \</div>
<div class="line">  }</div>
</div><!-- fragment -->
<p>Declares an in-place binary function on an array, intended for operations such as <code>+=</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">LTYPE</td><td>the <code>value_type</code> of the first argument of the function which is also the result <code>value_tye</code> of the operation (so the left value if the function is an operator overload)</td></tr>
    <tr><td class="paramname">RTYPE</td><td>the <code>value_type</code> of the second argument of the function</td></tr>
    <tr><td class="paramname">OP_FUNCTION_NAME</td><td>the function which should be declared (e.g. <code>operator+=</code>)</td></tr>
    <tr><td class="paramname">BINARY_OP</td><td>the binary function which should be applied elementwise to the pair of arrays. (e.g. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/functional/plus.html">std::plus</a>&lt;&gt;()</code>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga902d1cefbb10846eb8f5be9f6be5c340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga902d1cefbb10846eb8f5be9f6be5c340">&#9670;&nbsp;</a></span>EXPAND_PACK_LEFT_TO_RIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EXPAND_PACK_LEFT_TO_RIGHT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;(void)<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt;char&gt; { ((void)(__VA_ARGS__), '0')... }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a parameter pack evaluating the terms from left to right. </p>
<p>The parameter pack inside the argument to the macro must not be expanded since the macro will do the expansion correctly for you. In the below example a parameter pack of <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, I&gt;</code> is passed to the function. The closure <code>lambda</code> is used to sum up the values of all the <code>Ts</code>. Note that the <code>Ts</code> passed to <code>EXPAND_PACK_LEFT_TO_RIGHT</code> is not expanded.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</div>
<div class="line"><span class="keywordtype">void</span> test_expand_pack_left_to_right(<span class="keyword">const</span> <span class="keywordtype">size_t</span> expected,</div>
<div class="line">                                    tmpl::list&lt;Ts...&gt; <span class="comment">/*meta*/</span>) {</div>
<div class="line">  <span class="keywordtype">size_t</span> sum = 0;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> lambda = [&amp;sum](<span class="keyword">auto</span> tag) { sum += decltype(tag)::value; };</div>
<div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a>(lambda(Ts{}));</div>
<div class="line">  CHECK(sum == expected);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple.">tuple_fold</a> tuple_counted_fold <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> </dd></dl>

</div>
</div>
<a id="gad7b776398a66e9a6bd561c8decf08b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7b776398a66e9a6bd561c8decf08b47">&#9670;&nbsp;</a></span>GENERATE_INSTANTIATIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GENERATE_INSTANTIATIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">INSTANTIATION_MACRO, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  GENERATE_INSTANTIATIONS_DO_PRODUCT(                                    \</div>
<div class="line">      INSTANTIATION_MACRO,                                               \</div>
<div class="line">      BOOST_PP_LIST_TRANSFORM(GENERATE_INSTANTIATION_TUPLES_TO_LISTS, _, \</div>
<div class="line">                              BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))</div>
</div><!-- fragment -->
<p>Macro useful for generating many explicit instantiations of function or class templates. </p>
<p>It is often necessary to generate explicit instantiations of function or class templates. Since the total number of explicit instantiations scales as the product of the number of possible number of parameter values of each template parameter, this quickly becomes tedious. This macro allows you to easily generate hundreds of explicit instantiations.</p>
<p>The first argument to the macro is a macro that takes two arguments and is described below. The remaining arguments are macro-tuples, e.g. <code>(1, 2, 3)</code>. The Cartesian product of the macro-tuples is then computed and each term is passed as a tuple as the second argument to the <code>INSTANTIATION_MACRO</code>. The first argument to the <code>INSTANTIATION_MACRO</code> is a Boost.Preprocessor internal variable so just make it <code>_</code>. The <code>INSTANTIATION(_, data)</code> macro below serves as an example. A concrete example is generating explicit instantiations of the class <code><a class="el" href="classIndex.html">Index</a>&lt;Dim&gt;</code> for <code>Dim = 0,1,2,3</code>, which you would do as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div>
<div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef GET_DIM</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div>
</div><!-- fragment --><p>This will generate:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div>
</div><!-- fragment --><p>It is also possible to generate explicit instantiations for multiple classes or functions in a single call to <code>GENERATE_INSTANTIATIONS</code>. For example, the (in)equivalence operators can be generated using:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define GET_DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"><span class="preprocessor">#define GEN_OP(op, dim)                            \</span></div>
<div class="line"><span class="preprocessor">  template bool operator op(const Index&lt;dim&gt;&amp; lhs, \</span></div>
<div class="line"><span class="preprocessor">                            const Index&lt;dim&gt;&amp; rhs) noexcept;</span></div>
<div class="line"><span class="preprocessor">#define INSTANTIATION(_, data)         \</span></div>
<div class="line"><span class="preprocessor">  template class Index&lt;GET_DIM(data)&gt;; \</span></div>
<div class="line"><span class="preprocessor">  GEN_OP(==, GET_DIM(data))            \</span></div>
<div class="line"><span class="preprocessor">  GEN_OP(!=, GET_DIM(data))</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATION, (0, 1, 2, 3))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef GET_DIM</span></div>
<div class="line"><span class="preprocessor">#undef GEN_OP</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATION</span></div>
</div><!-- fragment --><p>which will result in the instantiations:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;0&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;0&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;1&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;1&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;2&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;2&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keyword">class </span><a class="code" href="classIndex.html">Index&lt;3&gt;</a>;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div>
<div class="line"><span class="keyword">template</span> <span class="keywordtype">bool</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; lhs, <span class="keyword">const</span> <a class="code" href="classIndex.html">Index&lt;3&gt;</a>&amp; rhs) noexcept;</div>
</div><!-- fragment --><p>Now let's look at generating instantiations of member function templates of class templates, which will be a common use case. In this example we generate explicit instantiations of all the member function templates of the class <code><a class="el" href="classScalarWave_1_1Solutions_1_1PlaneWave.html" title="A plane wave solution to the Euclidean wave equation.">ScalarWave::Solutions::PlaneWave</a></code>. In total, for <code>Dim = 1,2,3</code> and types <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> this is about 42 explicit instantiations, which would be extremely annoying to write by hand. The macro code is surprisingly simple:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define DIM(data) BOOST_PP_TUPLE_ELEM(0, data)</span></div>
<div class="line"><span class="preprocessor">#define DTYPE(data) BOOST_PP_TUPLE_ELEM(1, data)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define INSTANTIATE(_, data)                                              \</span></div>
<div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div>
<div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::psi(                       \</span></div>
<div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept; \</span></div>
<div class="line"><span class="preprocessor">  template Scalar&lt;DTYPE(data)&gt;                                            \</span></div>
<div class="line"><span class="preprocessor">  ScalarWave::Solutions::PlaneWave&lt;DIM(data)&gt;::dpsi_dt(                   \</span></div>
<div class="line"><span class="preprocessor">      const tnsr::I&lt;DTYPE(data), DIM(data)&gt;&amp; x, double t) const noexcept;</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(INSTANTIATE, (1, 2, 3), (<span class="keywordtype">double</span>, <a class="code" href="classDataVector.html">DataVector</a>))</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#undef DIM</span></div>
<div class="line"><span class="preprocessor">#undef DTYPE</span></div>
<div class="line"><span class="preprocessor">#undef INSTANTIATE</span></div>
</div><!-- fragment --><p>We don't show the result from preprocessor since for all of the member functions of <code>PlaneWave</code> the total output is approximately 150 lines, but you can hopefully see the benefits of generating explicit instantiations using the <code>GENERATE_INSTANTIATIONS</code> way.</p>
<p>One thing that can be difficult is debugging metaprograms (be they template or macro-based). To this end we provide a make target <code>DebugPreprocessor</code> which prints the output of running the preprocessor on the file <code>src/Executables/DebugPreprocessor/DebugPreprocessor.cpp</code>. Note that the output of the <code>GENERATE_INSTANTIATIONS</code> macro will be on a single line, so it often proves useful to copy-paste the output into an editor and run clang-format over the code so it's easier to reason about. </p>

</div>
</div>
<a id="gaffde14445f49f65ff4f5b592e44ee71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde14445f49f65ff4f5b592e44ee71a">&#9670;&nbsp;</a></span>LIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate true most of the time </p>

</div>
</div>
<a id="ga9d571cd642604cb7bd87bb039ca3760f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d571cd642604cb7bd87bb039ca3760f">&#9670;&nbsp;</a></span>SPECTRE_ALWAYS_INLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_ALWAYS_INLINE&#160;&#160;&#160;inline</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Always inline a function. Only use this if you benchmarked the code. </p>

</div>
</div>
<a id="gab10d0a221f4d7a706701b806c8135fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10d0a221f4d7a706701b806c8135fd7">&#9670;&nbsp;</a></span>UNLIKELY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNLIKELY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(x)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The if statement is expected to evaluate false most of the time </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga01ee1794935080949a6995ae7d5e08cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01ee1794935080949a6995ae7d5e08cc">&#9670;&nbsp;</a></span>flat_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">tmpl2::flat_all</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt;<a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), true)...&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga6e25dbfa539ff4513329969dbcd81c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e25dbfa539ff4513329969dbcd81c40">&#9670;&nbsp;</a></span>flat_any</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">tmpl2::flat_any</a> = typedef <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; bool, not <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_same.html">std::is_same</a>&lt; <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, Bs...&gt;, <a class="el" href="structtmpl2_1_1value__list.html">value_list</a>&lt;bool, (static_cast&lt;void&gt;(Bs), false)...&gt; &gt;::value&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga3f918eda8b76895af59951db3ed6bb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f918eda8b76895af59951db3ed6bb81">&#9670;&nbsp;</a></span>make_boost_variant_over</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Sequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga3f918eda8b76895af59951db3ed6bb81">make_boost_variant_over</a> =  typename detail::make_boost_variant_over_impl&lt; tmpl::remove_duplicates&lt;Sequence&gt; &gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a boost::variant with all all the types inside the typelist Sequence. </p>
<p><em>Returns:</em> boost::variant of all types inside <code>Sequence</code> </p>

</div>
</div>
<a id="gae57946a2ff8730c87f1e47d636dd5b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57946a2ff8730c87f1e47d636dd5b57">&#9670;&nbsp;</a></span>owner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , Requires&lt; std::is_pointer&lt; T &gt;::value &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57">gsl::owner</a> = typedef typename detail::owner_impl&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark a raw pointer as owning its data. </p>
<dl class="section warning"><dt>Warning</dt><dd>You should never actually use <code><a class="el" href="group__UtilitiesGroup.html#gae57946a2ff8730c87f1e47d636dd5b57" title="Mark a raw pointer as owning its data.">gsl::owner</a></code>. Instead you should use <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a></code>, and if shared ownership is required, <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a></code>. </dd></dl>

</div>
</div>
<a id="ga084d535585c18d4e80f8ec6052d341a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084d535585c18d4e80f8ec6052d341a3">&#9670;&nbsp;</a></span>Requires</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__UtilitiesGroup.html#ga084d535585c18d4e80f8ec6052d341a3">Requires</a> =  typename Requires_detail::requires_impl&lt; B&gt;::template_error_type_failed_to_meet_requirements_on_template_parameters</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Express requirements on the template parameters of a function or class, replaces <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> </p>
<p>Replacement for <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> and Concepts for expressing requirements on template parameters. This does not require merging of the Concepts TS (whose merit is debatable) and provides an "error message" if substitution of a template parameter failed. Specifically, the compiler error will contain "template_error_type_failed_to_meet_requirements_on_template_parameters", aiding the user of a function or class in tracking down the list of requirements on the deduced type.</p>
<p>For example, if a function <code>foo</code> is defined as: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p>then calling the function with a list, <code>foo(<a class="elRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a>&lt;double&gt;{});</code> results in the following compilation error from clang: </p><div class="fragment"><div class="line">./tests/Unit/Utilities/Test_Requires.cpp:29:3: error: no matching <span class="keyword">function</span></div>
<div class="line">   <span class="keywordflow">for</span> <a class="code" href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">call</a> to <span class="stringliteral">&#39;foo&#39;</span></div>
<div class="line">  foo(<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/list.html">std::list&lt;double&gt;</a>{});</div>
<div class="line">  ^~~</div>
<div class="line">./tests/Unit/Utilities/Test_Requires.cpp:15:13: note: candidate</div>
<div class="line">    <span class="keyword">template</span> ignored: substitution failure [with T = std::__1::list&lt;double,</div>
<div class="line">    std::__1::allocator&lt;double&gt; &gt;]: no type named</div>
<div class="line">    <span class="stringliteral">&#39;template_error_type_failed_to_meet_requirements_on_template_parameters&#39;</span></div>
<div class="line">    in <span class="stringliteral">&#39;Requires_detail::requires_impl&lt;false&gt;&#39;</span></div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp;) {</div>
<div class="line">            ^</div>
<div class="line">1 error generated.</div>
</div><!-- fragment --><p>Here is an example of how write function overloads using <code>Requires</code> or to express constraints on the template parameters: </p><div class="fragment"><div class="line"><span class="comment">/// [foo_definition]</span></div>
<div class="line"><span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::vector, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;vector&quot;</span>;</div>
<div class="line">}<span class="comment"></span></div>
<div class="line"><span class="comment">/// [foo_definition]</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;tt::is_a_v&lt;std::list, T&gt;&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> foo(<span class="keyword">const</span> T&amp; <span class="comment">/*unused*/</span>) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;list&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Using <code>Requires</code> is safer than using <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/enable_if.html">std::enable_if_t</a></code> because the nested type alias is of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/nullptr_t.html">std::nullptr_t</a></code> and so usage is always: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, Requires&lt;(<span class="keywordtype">bool</span> depending on T)&gt; = <span class="keywordtype">nullptr</span>&gt;</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa3be3b8a2b80d0c3837f82d82e5f25f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3be3b8a2b80d0c3837f82d82e5f25f5">&#9670;&nbsp;</a></span>accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T cpp2b::accumulate </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::accumulate that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/numeric">https://github.com/llvm-mirror/libcxx/blob/master/include/numeric</a> </p>

</div>
</div>
<a id="gab0d5e7fa5e0aa31f06200f691d74300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0d5e7fa5e0aa31f06200f691d74300b">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ApplyTags , typename F , typename... Tags&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr decltype(auto) tuples::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtuples_1_1TaggedTuple.html">TaggedTuple</a>&lt; Tags... &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke <code>f</code> with the <code>ApplyTags</code> taken from <code>t</code> expanded in a parameter pack. </p>
<p><code>ApplyTags</code> defaults to the full list of tags in <code>t</code>.</p>
<p>Here is an example how to use the function:</p>
<div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> extra_factor = 3.;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> result = tuples::apply(</div>
<div class="line">        [&amp;extra_factor](<span class="keyword">const</span> <span class="keyword">auto</span>&amp;... expanded_args) {</div>
<div class="line">          <span class="keywordflow">return</span> extra_factor * test_function(expanded_args...);</div>
<div class="line">        },</div>
<div class="line">        <a class="code" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple&lt;FirstArg, SecondArg&gt;</a>{1, 2.});</div>
</div><!-- fragment --><p> This is the function being called in the above example:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>FirstArg {</div>
<div class="line">  <span class="keyword">using</span> type = int;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">struct </span>SecondArg {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">double</span> test_function(<span class="keyword">const</span> <span class="keywordtype">int</span> first_arg, <span class="keyword">const</span> <span class="keywordtype">double</span> second_arg) {</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(first_arg) + second_arg;</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>std::apply </dd></dl>

</div>
</div>
<a id="gaa46b024995f6a5d70ed31882a9a0bcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa46b024995f6a5d70ed31882a9a0bcab">&#9670;&nbsp;</a></span>call_with_dynamic_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Classes , typename Base , typename Callable , Requires&lt;(tmpl::size&lt; Classes &gt;::value !=0)&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Result call_with_dynamic_type </td>
          <td>(</td>
          <td class="paramtype">Base *const&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call a functor with the derived type of a base class pointer. </p>
<h3>Details</h3>
<p>Calls functor with obj cast to type <code>T*</code> where T is the dynamic type of <code>*obj</code>. The decay type of <code>T</code> must be in the provided list of classes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69" title="Define a function that acts similarly to a virtual function, but can take template parameters.">DEFINE_FAKE_VIRTUAL</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>the return type </td></tr>
    <tr><td class="paramname">Classes</td><td>the typelist of derived classes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaa46a305d87ee4ae9fede9d55c373286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa46a305d87ee4ae9fede9d55c373286">&#9670;&nbsp;</a></span>ddot_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ddot_ </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product of two vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the length of the vectors. </td></tr>
    <tr><td class="paramname">X</td><td>a pointer to the first element of the first vector. </td></tr>
    <tr><td class="paramname">INCX</td><td>the stride for the elements of the first vector. </td></tr>
    <tr><td class="paramname">Y</td><td>a pointer to the first element of the second vector. </td></tr>
    <tr><td class="paramname">INCY</td><td>the stride for the elements of the second vector. </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> the dot product of the given vectors. </p>

</div>
</div>
<a id="gab9ae0c4131a2de652b81b4997e740d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9ae0c4131a2de652b81b4997e740d5a">&#9670;&nbsp;</a></span>destructive_resize_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename DestructiveResizeFunction  = ContainerDestructiveResize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void destructive_resize_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Container * &gt;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DestructiveResizeFunction&#160;</td>
          <td class="paramname"><em>destructive_resize</em> = <code><a class="el" href="structContainerDestructiveResize.html">ContainerDestructiveResize</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks the size of each component of the container, and resizes if necessary. </p>
<h3>Details</h3>
<p>This operation is not permitted when any of the components of the tensor is non-owning (see <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code> for ownership details). </p><dl class="section note"><dt>Note</dt><dd>This utility should NOT be used when it is anticipated that the components will be the wrong size. In that case, suggest either manual checking or restructuring so that resizing is less common. The internal call uses <code>UNLIKELY</code> to perform the checks most quickly when resizing is unnecessary.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is typically to be called on <code>Tensor</code>s, NOT (for instance) <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>s. For derived classes of <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code>, this function will cause no resize. Instead, use the <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code> member function <code><a class="el" href="classVectorImpl.html#a81d5cdc8b3211ba18932e4068eae7ba6" title="A common operation for checking the size and resizing a memory buffer if needed to ensure that it has...">VectorImpl::destructive_resize()</a></code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This assumes that a range-based iterator will appropriately loop over the elements to resize, and that each resized element is either a fundamental type or a derived class of <code><a class="el" href="classVectorImpl.html" title="Base class template for various DataVector and related types.">VectorImpl</a></code>. If either of those assumptions needs to be relaxed, this function will need to be generalized. </dd></dl>

</div>
</div>
<a id="gac932a44b57087d32ce5341314437dbbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac932a44b57087d32ce5341314437dbbd">&#9670;&nbsp;</a></span>dgemm_()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool UseLibXsmm = false&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemm_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-matrix multiplication. </p>
<p>Perform the matrix-matrix multiplication </p><p class="formulaDsp">
\[ C = \alpha \mathrm{op}(A) \mathrm{op}(B) + \beta \mathrm{op}(C) \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<p>LIBXSMM, which is much faster than BLAS for small matrices, can be called instead of BLAS by passing the template parameter <code>true</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANSA</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">TRANSB</td><td>either 'N', 'T' or 'C', transposition of matrix B </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(B)\) and \(\mathrm{op}(C)\) </td></tr>
    <tr><td class="paramname">K</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">B</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(B\) </td></tr>
    <tr><td class="paramname">LDB</td><td>Specifies first dimension of \(\mathrm{op}(B)\) </td></tr>
    <tr><td class="paramname">BETA</td><td>specifies \(\beta\) </td></tr>
    <tr><td class="paramname">C</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(C\) </td></tr>
    <tr><td class="paramname">LDC</td><td>Specifies first dimension of \(\mathrm{op}(C)\) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UseLibXsmm</td><td>if <code>true</code> then use LIBXSMM </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4d31316e0975f0a66a60d9ac92756a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d31316e0975f0a66a60d9ac92756a8">&#9670;&nbsp;</a></span>dgemv_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dgemv_ </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>TRANS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>ALPHA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>INCY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a matrix-vector multiplication. </p>
<p class="formulaDsp">
\[ y = \alpha \mathrm{op}(A) x + \beta y \]
</p>
<p>where \(\mathrm{op}(A)\) represents either \(A\) or \(A^{T}\) (transpose of \(A\)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TRANS</td><td>either 'N', 'T' or 'C', transposition of matrix A </td></tr>
    <tr><td class="paramname">M</td><td>Number of rows in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">N</td><td>Number of columns in \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">ALPHA</td><td>specifies \(\alpha\) </td></tr>
    <tr><td class="paramname">A</td><td><a class="el" href="classMatrix.html" title="A dynamically sized matrix of doubles with column-major storage.">Matrix</a> \(A\) </td></tr>
    <tr><td class="paramname">LDA</td><td>Specifies first dimension of \(\mathrm{op}(A)\) </td></tr>
    <tr><td class="paramname">X</td><td>Vector \(x\) </td></tr>
    <tr><td class="paramname">INCX</td><td>Specifies the increment for the elements of \(x\) </td></tr>
    <tr><td class="paramname">BETA</td><td>Specifies \(\beta\) </td></tr>
    <tr><td class="paramname">Y</td><td>Vector \(y\) </td></tr>
    <tr><td class="paramname">INCY</td><td>Specifies the increment for the elements of \(y\) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ed84deeb606f239b8781809d2be69a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed84deeb606f239b8781809d2be69a6">&#9670;&nbsp;</a></span>equal_within_roundoff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool equal_within_roundoff </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>eps</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()&#160;*&#160;100.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>scale</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if two values <code>a</code> and <code>b</code> are equal within roundoff, by comparing <code>abs(a - b) &lt; (max(abs(a), abs(b)) + scale) * eps</code>. </p>

</div>
</div>
<a id="gab208666192c91f22d2a7b9176ea9b7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab208666192c91f22d2a7b9176ea9b7ce">&#9670;&nbsp;</a></span>evaluate_polynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CoeffsIterable , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType evaluate_polynomial </td>
          <td>(</td>
          <td class="paramtype">const CoeffsIterable &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluate a polynomial \(\sum_{p=0}^N c_p x^p\) with Horner's rule. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coeffs</td><td>The polynomial coefficients \(c_p\) ordered from constant to largest power </td></tr>
    <tr><td class="paramname">x</td><td>The polynomial variable \(x\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CoeffsIterable</td><td>The type of the polynomial coefficients <code>coeffs</code>. Can be a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> or <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double&gt;</code>, which means the coefficients are constant for all values in <code>x</code>. Each coefficient can also be a vector type of typically the same size as <code>x</code>, which means the coefficients vary with the elements in <code>x</code>. </td></tr>
    <tr><td class="paramname">DataType</td><td>The type of the polynomial variable <code>x</code>. Must support <code>make_with_value&lt;DataType, DataType&gt;</code>, as well as (elementwise) addition with <code>CoeffsIterable::value_type</code> and multiplication with <code>DataType</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga45da409b9b03a4ad18e76036ab5a853c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45da409b9b03a4ad18e76036ab5a853c">&#9670;&nbsp;</a></span>expand_pack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void expand_pack </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows zero-cost unordered expansion of a parameter. </p>
<h3>Details</h3>
<p>Expands a parameter pack, typically useful for runtime evaluation via a Callable such as a lambda, function, or function object. For example, an unordered transform of a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> can be implemented as: </p><div class="fragment"><div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Elements, <span class="keywordtype">size_t</span>... Is&gt;</div>
<div class="line"><span class="keywordtype">void</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; tupull,</div>
<div class="line">               <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;Elements...&gt;</a>&amp; out_tupull,</div>
<div class="line">               <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence&lt;Is...&gt;</a> <span class="comment">/*meta*/</span>) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> func = [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; in, <span class="keyword">auto</span>&amp; out) {</div>
<div class="line">    out = in * <span class="keyword">static_cast&lt;</span>decltype(in)<span class="keyword">&gt;</span>(2);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">  };</div>
<div class="line">  <a class="code" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">expand_pack</a>(func(std::get&lt;Is&gt;(tupull), std::get&lt;Is&gt;(out_tupull))...);</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace</span></div>
<div class="line"> </div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Utilities.expand_pack&quot;</span>, <span class="stringliteral">&quot;[Utilities][Unit]&quot;</span>) {</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull = std::make_tuple(3, 2.7, 8.2);</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;int, double, float&gt;</a> my_tupull_output;</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/algorithm/transform.html">transform</a>(my_tupull, my_tupull_output, <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::make_index_sequence&lt;3&gt;</a>{});</div>
<div class="line">  CHECK(std::get&lt;0&gt;(my_tupull_output) == 6);</div>
<div class="line">  CHECK(std::get&lt;1&gt;(my_tupull_output) == 5.4);</div>
<div class="line">  CHECK(std::get&lt;2&gt;(my_tupull_output) == 16.4f);</div>
<div class="line">}</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple.">tuple_fold</a> tuple_counted_fold <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <a class="el" href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340" title="Expand a parameter pack evaluating the terms from left to right.">EXPAND_PACK_LEFT_TO_RIGHT</a> </dd></dl>

</div>
</div>
<a id="gadd9ead5cb45cd6ce2c4680cd82d861cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd9ead5cb45cd6ce2c4680cd82d861cb">&#9670;&nbsp;</a></span>fill_with_n_copies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill_with_n_copies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; VectorType * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorType &amp;&#160;</td>
          <td class="paramname"><em>to_copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>times_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates or fills a vector with data from <code>to_repeat</code> copied <code>times_to_repeat</code> times in sequence. </p>
<h3>Details</h3>
<p>This can be useful for generating data that consists of the same block of values duplicated a number of times. For instance, this can be used to create a vector representing three-dimensional volume data from a corresponding two-dimensional vector data, if the two-dimensional data corresponds to the two fastest-varying directions of the desired three-dimensional representation. The result would then be uniform in the slowest-varying direction of the three dimensional grid. </p>

</div>
</div>
<a id="gac84a6c0bd8692c342b9ddf4ba63601e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac84a6c0bd8692c342b9ddf4ba63601e2">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::find that is constexpr </p>

</div>
</div>
<a id="gad9f222044f3284747287f0c3b5089ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9f222044f3284747287f0c3b5089ccd">&#9670;&nbsp;</a></span>find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find_if </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::find_if that is constexpr </p>

</div>
</div>
<a id="ga77bc48018339ff6ac9402f49a5cd2068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77bc48018339ff6ac9402f49a5cd2068">&#9670;&nbsp;</a></span>find_if_not()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIt , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr InputIt cpp20::find_if_not </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::find_if_not that is constexpr </p>

</div>
</div>
<a id="ga9a7c7ee897f581360154a3676d5f7ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a7c7ee897f581360154a3676d5f7ab9">&#9670;&nbsp;</a></span>formatted_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> formatted_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a string like printf. </p>
<p>Given a formatting string and arguments this returns the corresponding string. Similar to printf but using std::strings. </p>

</div>
</div>
<a id="gab0084c31ad1370a7305ac159837d3384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0084c31ad1370a7305ac159837d3384">&#9670;&nbsp;</a></span>get_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SubscriptFunction  = GetContainerElement&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) get_element </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubscriptFunction&#160;</td>
          <td class="paramname"><em>at</em> = <code><a class="el" href="structGetContainerElement.html">GetContainerElement</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the <code>i</code>th element if <code>T</code> has a subscript operator, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns <code>t</code>. </p>
<h3>Details</h3>
<p>This function also optionally takes the user-defined subscript function <code>at</code>, which can be used to specify a custom indexing function. For instance, for a type which is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> of a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>s, the indexing function could be the below callable struct: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayOfArraysIndexFunctor {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> OuterArraySize, <span class="keywordtype">size_t</span> InnerArraySize, <span class="keyword">typename</span> T&gt;</div>
<div class="line">  T&amp; operator()(<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;T, InnerArraySize&gt;</a>, OuterArraySize&gt;&amp;</div>
<div class="line">                    array_of_arrays,</div>
<div class="line">                <span class="keywordtype">size_t</span> index) noexcept {</div>
<div class="line">    <span class="keywordflow">return</span> array_of_arrays.at(index % OuterArraySize)</div>
<div class="line">        .at(index / OuterArraySize);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> which would index the data structure in a manner in which the outer array index varies fastest. The indexing function must take as arguments the applicable container and a <code>size_t</code> index, in that order. This follows the convention of <code><a class="el" href="group__UtilitiesGroup.html#ga818f101f2f8bd824a3bc7c2c2361c560" title="Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.">gsl::at</a></code>. </p><dl class="section note"><dt>Note</dt><dd><code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> are regarded as non-indexable (despite a predictable memory layout), so this function acts as the identity on <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of fundamental types </dd></dl>

</div>
</div>
<a id="ga48f1ae622586a451d95b26daaac2378e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga48f1ae622586a451d95b26daaac2378e">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SizeFunction  = GetContainerSize&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) get_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFunction&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="structGetContainerSize.html">GetContainerSize</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the size of <code>t</code> if <code>t.size()</code> is a valid expression, otherwise if <code>T</code> is fundamental or a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type, returns 1. </p>
<h3>Details</h3>
<p>This function also optionally takes the user-defined <code>size</code> function, which can be used to specify a custom size function. For instance, for a type which is a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code> of a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>, the size function could be the below callable struct: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayOfArraysSizeFunctor {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> OuterArraySize, <span class="keywordtype">size_t</span> InnerArraySize, <span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keywordtype">size_t</span> operator()(</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;T, InnerArraySize&gt;</a>, OuterArraySize&gt;&amp;</div>
<div class="line">      <span class="comment">/*array_of_arrays*/</span>) noexcept {</div>
<div class="line">    <span class="keywordflow">return</span> OuterArraySize * InnerArraySize;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> The <code>size</code> function must take the single argument of the applicable container, and should return a <code>size_t</code>. This follows the convention of <code>std::size()</code> as of C++17. </p><dl class="section note"><dt>Note</dt><dd><code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> are regarded as non-indexable (despite a predictable memory layout), so this function will return 1 for a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a></code> of a fundamental type </dd></dl>

</div>
</div>
<a id="ga218ddc950e1c70d86bf6455664d0b5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga218ddc950e1c70d86bf6455664d0b5f1">&#9670;&nbsp;</a></span>iota()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIterator , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp2b::iota </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::iota that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/numeric">https://github.com/llvm-mirror/libcxx/blob/master/include/numeric</a> </p>

</div>
</div>
<a id="ga2f41a812c1350575cf0e202b59902983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f41a812c1350575cf0e202b59902983">&#9670;&nbsp;</a></span>iter_swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt1 , class ForwardIt2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::iter_swap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt1&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt2&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::iter_swap that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits">https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits</a> </p>

</div>
</div>
<a id="ga05223223c63459beb75c170fa104ca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05223223c63459beb75c170fa104ca57">&#9670;&nbsp;</a></span>magnitude()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) magnitude </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Euclidean magnitude of the elements of the array. </p>
<h3>Details</h3>
<p>If T is a container the magnitude is computed separately for each element of the container.</p>
<p><em>Requires:</em> If T is a container, T must have following mathematical operators: abs(), sqrt(), and element-wise addition and multiplication. In addition, each T in the array must have the same size. </p>

</div>
</div>
<a id="ga08ed7eef85864542bf2c2e212f86a533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08ed7eef85864542bf2c2e212f86a533">&#9670;&nbsp;</a></span>make_array() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, Size&gt;{{T(args...), T(args...), ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
    <tr><td class="paramname">T</td><td>the type of the element in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaea51ad2c5ef8f8f99279545e1389d056"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea51ad2c5ef8f8f99279545e1389d056">&#9670;&nbsp;</a></span>make_array() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t size, typename Seq &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt; make_array </td>
          <td>(</td>
          <td class="paramtype">Seq &amp;&amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;T, size&gt;</code> from the first <code>size</code> values of <code>seq</code> </p>
<p><em>Requires:</em> <code>Seq</code> has a <code>begin</code> function </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type held by the array </td></tr>
    <tr><td class="paramname">size</td><td>the size of the created array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8f67df443d6136a55de6328f7753ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8f67df443d6136a55de6328f7753ffb">&#9670;&nbsp;</a></span>make_array() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto make_array </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;T&gt;, Size&gt;{{t, t, ...}}</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Size</td><td>the size of the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga188c2766e601fb537e7d34ae70c6ff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga188c2766e601fb537e7d34ae70c6ff9d">&#9670;&nbsp;</a></span>make_span()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ElementType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classgsl_1_1span.html">span</a>&lt;ElementType&gt; gsl::make_span </td>
          <td>(</td>
          <td class="paramtype">ElementType *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classgsl_1_1span.html">span</a>&lt; ElementType &gt;::index_type&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Utility function for creating spans </p>

</div>
</div>
<a id="gab5051536555a38beaf3cbe4784bb4002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5051536555a38beaf3cbe4784bb4002">&#9670;&nbsp;</a></span>make_static_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ranges, typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto make_static_cache </td>
          <td>(</td>
          <td class="paramtype">Generator &amp;&amp;&#160;</td>
          <td class="paramname"><em>generator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classStaticCache.html">StaticCache</a>, inferring the cached type from the generator. </p>

</div>
</div>
<a id="gaa9752049086a20f017376e22ad169e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9752049086a20f017376e22ad169e47">&#9670;&nbsp;</a></span>map_array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , size_t Dim, typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto map_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a function to each element of an array, producing a new array of the results. The elements of the new array are constructed in place, so they need not be default constructible. </p>

</div>
</div>
<a id="gaf0a66c125713e4158f86b06644a309eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0a66c125713e4158f86b06644a309eb">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cpp20::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::next_permutation that is constexpr, with less as the comparator; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="gac4ff3f48d2db8cb4a7101602d5f6ed3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4ff3f48d2db8cb4a7101602d5f6ed3d">&#9670;&nbsp;</a></span>next_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Compare , class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool cpp20::next_permutation </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::next_permutation that is constexpr, for a generic comparator; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="gaf9fcbbaa07506a5df5379b64772333d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9fcbbaa07506a5df5379b64772333d9">&#9670;&nbsp;</a></span>operator&quot;&quot;_st()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t operator&quot;&quot;_st </td>
          <td>(</td>
          <td class="paramtype">const unsigned long long&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Defines the _st size_t suffix </p>

</div>
</div>
<a id="gadae6888e4cbdcbc1166e32898ae9429a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadae6888e4cbdcbc1166e32898ae9429a">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LhsVectorType , typename RhsVectorType , typename ResultVectorType  = typename blaze::MultTrait&lt;LhsVectorType, RhsVectorType&gt;::Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; ResultVectorType * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RhsVectorType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the outer product between two vectors. </p>
<h3>Details</h3>
<p>For vectors \(A\) and \(B\), the resulting outer product is \(\{A_1 B_1,\, A_2 B_1\, \dots\, A_N B_1,\, A_1 B_2\, \dots\, A_N B_M\}\). This is useful for generating separable volume data from its constituent inputs. </p>

</div>
</div>
<a id="ga0465ea9937545d1d3404c6ab6e71b15c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0465ea9937545d1d3404c6ab6e71b15c">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BidirectionalIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::reverse </td>
          <td>(</td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BidirectionalIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::reverse that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm">https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm</a> </p>

</div>
</div>
<a id="ga6c00908b8856ad6d441d443d22586d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c00908b8856ad6d441d443d22586d0a">&#9670;&nbsp;</a></span>simplest_fraction_in_interval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fraction , typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Fraction simplest_fraction_in_interval </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>end2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the fraction in the supplied interval with the smallest denominator. </p>
<p>The endpoints are considered to be in the interval. The order of the arguments is not significant. The answer is unique as long as the interval has length less than 1; for longer intervals, an integer in the range will be returned. </p>

</div>
</div>
<a id="ga8be93b92f1d0720fb1f36cb6803d71e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8be93b92f1d0720fb1f36cb6803d71e3">&#9670;&nbsp;</a></span>smoothstep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N, typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DataType smoothstep </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lower_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>upper_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smoothly interpolates from 0 to 1 between <code>lower_edge</code> and <code>upper_edge</code> with a Hermite polynomial of degree <code>2 * N + 1</code>. </p>
<p>The smoothstep function is</p>
<p class="formulaDsp">
\begin{align*} S_N(x) = \begin{cases} 0 &amp;\quad \text{for} \quad x\leq x_0 \\ \tilde{S}_N((x - x_0) / (x_1 - x_0)) &amp;\quad \text{for} \quad x_0 \leq x\leq x_1 \\ 1 &amp;\quad \text{for} \quad x_1\leq x \\ \end{cases} \end{align*}
</p>
<p>where \(x_0\) is <code>lower_edge</code>, \(x_1\) is <code>upper_edge</code>, and, up to \(N=3\),</p>
<p class="formulaDsp">
\begin{align*} \tilde{S}_0(x) &amp;= x \\ \tilde{S}_1(x) &amp;= 3x^2 - 2x^3 \\ \tilde{S}_2(x) &amp;= 10x^3 - 15x^4 + 6x^5 \\ \tilde{S}_3(x) &amp;= 35x^4 - 84x^5 + 70x^6 - 20x^7 \text{.} \end{align*}
</p>
 
</div>
</div>
<a id="gacb1b5375ffa8efe0793310220d2b1d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb1b5375ffa8efe0793310220d2b1d5e">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void cpp20::swap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reimplementation of std::swap that is constexpr; taken from the LLVM source at <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits">https://github.com/llvm-mirror/libcxx/blob/master/include/type_traits</a> </p>

</div>
</div>
<a id="ga91227dc4aa14972b7b2e7070719d061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91227dc4aa14972b7b2e7070719d061b">&#9670;&nbsp;</a></span>tuple_fold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a fold over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right (left fold) calling <code>op(element, args...)</code> on each element in <code>tuple</code>. A right fold can be done by explicitly setting the first template parameter to true. Folds are easily implemented using <code>tuple_fold</code> by updating one of the <code>args...</code> at each iteration. If you need the index of the current element you can use the <code>tuple_counted_fold</code> variant. <code>tuple_counted_fold</code> passes the current index as the second argument to the Callable <code>op</code>. That is, <code>op(element, index, args...)</code>.</p>
<h3>Example</h3>
<p>The sum of a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> of Arithmetics can be computed in several ways. First, you can use a lambda: </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    <span class="keywordtype">double</span> sum_value = 0.0;</div>
<div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull,</div>
<div class="line">               [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keywordtype">double</span>&amp; state) { state += element; },</div>
<div class="line">               sum_value);</div>
<div class="line">    CHECK(sum_value == approx(26.1));</div>
</div><!-- fragment --><p>You'll notice that <code>state</code> is taken by reference and mutated.</p>
<p>You can do the same thing with a struct defined as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">struct </span>tuple_fold_plus {</div>
<div class="line">  T value = 0.0;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> S&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> S&amp; element) {</div>
<div class="line">    value += element;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>and then using an instance of the struct </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">    tuple_fold_plus&lt;double&gt; sum_value{};</div>
<div class="line">    <a class="code" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a>(my_tupull, sum_value);</div>
<div class="line">    CHECK(sum_value.value == approx(26.1));</div>
</div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You are not able to pass a function pointer to <code>tuple_fold</code> or <code>tuple_counted_fold</code> because you cannot pass a pointer to a function template, only a function.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302" title="Perform a transform over a std::tuple.">tuple_transform</a> <a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple.">tuple_fold</a> tuple_counted_fold <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="gaaee29910f2f9d5bc27cdc77cf604bd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaee29910f2f9d5bc27cdc77cf604bd41">&#9670;&nbsp;</a></span>tuple_head()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tuple_head </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The first <code>Size</code> elements in <code>tuple</code> </p>

</div>
</div>
<a id="ga1f2550f464834199603ab935620cfb46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f2550f464834199603ab935620cfb46">&#9670;&nbsp;</a></span>tuple_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Start, size_t Stop, typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tuple_slice </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The subset of elements in <code>tuple</code> from index <code>Start</code> to (excluding) <code>Stop</code> </p>

</div>
</div>
<a id="ga4355f2be0dea656e459cab9a500c6a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4355f2be0dea656e459cab9a500c6a8e">&#9670;&nbsp;</a></span>tuple_tail()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tuple_tail </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The last <code>Size</code> elements in <code>tuple</code> </p>

</div>
</div>
<a id="gad65147320c04e61267089a58d71a6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad65147320c04e61267089a58d71a6302">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool ReverseIteration = false, typename... Elements, typename N_aryOp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void tuple_transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Elements... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">N_aryOp &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a transform over a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>. </p>
<h3>Details</h3>
<p>Iterates over the elements in a <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> <code>tuple</code> from left to right calling <code>op.operator()(element, index, args...)</code> on each element in <code>tuple</code>. A right-to-left transform can be done by explicitly setting the first template parameter to true. The second argument of the invokable will be a deduced <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt;size_t, value&gt;</code>, from which the current index can be extracted by using <code>decltype(index)::value</code>. For a function object the <code>decltype(index)</code> can be replaced by the deduced type of <code>index</code>. For example, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>negate {</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Index, <span class="keyword">typename</span> S&gt;</div>
<div class="line">  <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> T&amp; element, <a class="code" href="classIndex.html">Index</a> <span class="comment">/*index*/</span>,</div>
<div class="line">                  S&amp; second_tuple_element) <span class="keyword">const</span> noexcept {</div>
<div class="line">    std::get&lt;Index::value&gt;(second_tuple_element) = -element;</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> Using <code>tuple_transform</code> with a generic lambda goes as follows, </p><div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> my_tupull = std::make_tuple(2, 7, -3.8, 20.9);</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;decltype(my_tupull)&gt; out_tupull;</div>
<div class="line">  <a class="code" href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a>(my_tupull,</div>
<div class="line">                  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element, <span class="keyword">auto</span> index, <span class="keyword">auto</span>&amp; out_tuple) {</div>
<div class="line">                    constexpr <span class="keywordtype">size_t</span> index_v = decltype(index)::value;</div>
<div class="line">                    std::get&lt;index_v&gt;(out_tuple) = -element;</div>
<div class="line">                  },</div>
<div class="line">                  out_tupull);</div>
<div class="line"> </div>
<div class="line">  CHECK(std::get&lt;0&gt;(out_tupull) == -2);</div>
<div class="line">  CHECK(std::get&lt;1&gt;(out_tupull) == -7);</div>
<div class="line">  CHECK(std::get&lt;2&gt;(out_tupull) == 3.8);</div>
<div class="line">  CHECK(std::get&lt;3&gt;(out_tupull) == -20.9);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c" title="Allows zero-cost unordered expansion of a parameter.">expand_pack</a> <a class="el" href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b" title="Perform a fold over a std::tuple.">tuple_fold</a> tuple_counted_fold <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a> </dd></dl>

</div>
</div>
<a id="gaa86214e3a4760293a956acb6ad56942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa86214e3a4760293a956acb6ad56942d">&#9670;&nbsp;</a></span>unordered_print_helper()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIt , typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unordered_print_helper </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt &amp;&amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like sequence_print_helper, but sorts the string representations. </p>

</div>
</div>
<a id="ga7ef3eefc9ddb3dc4befdc2c232a1c541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ef3eefc9ddb3dc4befdc2c232a1c541">&#9670;&nbsp;</a></span>wrap_text()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> wrap_text </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>indentation</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wrap the string <code>str</code> so that it is no longer than <code>line_length</code> and indent each new line with <code>indentation</code>. The first line is also indented. </p>
<p>Single words longer than <code>line_length</code> are hyphenated. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gab78389fadf763e3693ce893fad5d7fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab78389fadf763e3693ce893fad5d7fba">&#9670;&nbsp;</a></span>flat_all_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_all_v = <a class="el" href="group__UtilitiesGroup.html#ga01ee1794935080949a6995ae7d5e08cc">flat_all</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A non-short-circuiting logical AND between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
<a id="ga8a328cb983ebb1947b0eb9d924f40253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a328cb983ebb1947b0eb9d924f40253">&#9670;&nbsp;</a></span>flat_any_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool... Bs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tmpl2::flat_any_v = <a class="el" href="group__UtilitiesGroup.html#ga6e25dbfa539ff4513329969dbcd81c40">flat_any</a>&lt;Bs...&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A non-short-circuiting logical OR between bools 'B"". </p>
<p>Useful when arbitrarily large parameter packs need to be evaluated, since <a class="elRef" href="http://en.cppreference.com/w/cpp/types/conjunction.html">std::conjunction</a> and <a class="elRef" href="http://en.cppreference.com/w/cpp/types/disjunction.html">std::disjunction</a> use recursion </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__UtilitiesGroup_html_ga45da409b9b03a4ad18e76036ab5a853c"><div class="ttname"><a href="group__UtilitiesGroup.html#ga45da409b9b03a4ad18e76036ab5a853c">expand_pack</a></div><div class="ttdeci">constexpr void expand_pack(Ts &amp;&amp;...) noexcept</div><div class="ttdoc">Allows zero-cost unordered expansion of a parameter.</div><div class="ttdef"><b>Definition:</b> TMPL.hpp:547</div></div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga902d1cefbb10846eb8f5be9f6be5c340"><div class="ttname"><a href="group__UtilitiesGroup.html#ga902d1cefbb10846eb8f5be9f6be5c340">EXPAND_PACK_LEFT_TO_RIGHT</a></div><div class="ttdeci">#define EXPAND_PACK_LEFT_TO_RIGHT(...)</div><div class="ttdoc">Expand a parameter pack evaluating the terms from left to right.</div><div class="ttdef"><b>Definition:</b> TMPL.hpp:563</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad65147320c04e61267089a58d71a6302"><div class="ttname"><a href="group__UtilitiesGroup.html#gad65147320c04e61267089a58d71a6302">tuple_transform</a></div><div class="ttdeci">constexpr void tuple_transform(const std::tuple&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_transform_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), std::make_index_sequence&lt; sizeof...(Elements)&gt;{}, args...)))</div><div class="ttdoc">Perform a transform over a std::tuple.</div><div class="ttdef"><b>Definition:</b> Tuple.hpp:164</div></div>
<div class="ttc" id="alist_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/list.html">std::list</a></div></div>
<div class="ttc" id="aoperator_cmp_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/rel_ops/operator_cmp.html">std::rel_ops::operator!=</a></div><div class="ttdeci">T operator!=(T... args)</div></div>
<div class="ttc" id="ainteger_sequence_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/integer_sequence.html">std::index_sequence</a></div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
<div class="ttc" id="aclassIndex_html"><div class="ttname"><a href="classIndex.html">Index</a></div><div class="ttdef"><b>Definition:</b> Index.hpp:31</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga91227dc4aa14972b7b2e7070719d061b"><div class="ttname"><a href="group__UtilitiesGroup.html#ga91227dc4aa14972b7b2e7070719d061b">tuple_fold</a></div><div class="ttdeci">constexpr void tuple_fold(const std::tuple&lt; Elements... &gt; &amp;tuple, N_aryOp &amp;&amp;op, Args &amp;&amp;... args) noexcept(noexcept(tuple_impl_detail::tuple_fold_impl&lt; ReverseIteration &gt;(tuple, std::forward&lt; N_aryOp &gt;(op), std::make_index_sequence&lt; sizeof...(Elements)&gt;{}, args...)))</div><div class="ttdoc">Perform a fold over a std::tuple.</div><div class="ttdef"><b>Definition:</b> Tuple.hpp:112</div></div>
<div class="ttc" id="anamespacepypp_html_a0b8520e3e6d5c1abb3110b134c10683f"><div class="ttname"><a href="namespacepypp.html#a0b8520e3e6d5c1abb3110b134c10683f">pypp::call</a></div><div class="ttdeci">ReturnType call(const std::string &amp;module_name, const std::string &amp;function_name, const Args &amp;... t)</div><div class="ttdoc">Calls a Python function from a module/file with given parameters.</div><div class="ttdef"><b>Definition:</b> Pypp.hpp:539</div></div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></div></div>
<div class="ttc" id="aclasstuples_1_1TaggedTuple_html"><div class="ttname"><a href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a></div><div class="ttdoc">An associative container that is indexed by structs.</div><div class="ttdef"><b>Definition:</b> TaggedTuple.hpp:271</div></div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:42</div></div>
<div class="ttc" id="atransform_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/algorithm/transform.html">std::transform</a></div><div class="ttdeci">T transform(T... args)</div></div>
<div class="ttc" id="adecay_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a></div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_ga265f35910bd218c59dd33acffe0c0b69"><div class="ttname"><a href="group__UtilitiesGroup.html#ga265f35910bd218c59dd33acffe0c0b69">DEFINE_FAKE_VIRTUAL</a></div><div class="ttdeci">#define DEFINE_FAKE_VIRTUAL(function)</div><div class="ttdoc">Define a function that acts similarly to a virtual function, but can take template parameters.</div><div class="ttdef"><b>Definition:</b> FakeVirtual.hpp:50</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad7b776398a66e9a6bd561c8decf08b47"><div class="ttname"><a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a></div><div class="ttdeci">#define GENERATE_INSTANTIATIONS(INSTANTIATION_MACRO,...)</div><div class="ttdoc">Macro useful for generating many explicit instantiations of function or class templates.</div><div class="ttdef"><b>Definition:</b> GenerateInstantiations.hpp:160</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
