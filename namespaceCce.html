<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Cce Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cce Namespace Reference<div class="ingroups"><a class="el" href="group__EvolutionSystemsGroup.html">Evolution Systems</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The set of utilities for performing Cauchy characteristic evolution and Cauchy characteristic matching.  
<a href="namespaceCce.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCce_1_1Actions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1Actions.html">Actions</a></td></tr>
<tr class="memdesc:namespaceCce_1_1Actions"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of actions for use in the CCE evolution system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCce_1_1InitializeJ"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1InitializeJ.html">InitializeJ</a></td></tr>
<tr class="memdesc:namespaceCce_1_1InitializeJ"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities and <a class="el" href="group__DataBoxGroup.html">DataBox</a> mutators for generating data for \(J\) on the initial CCE hypersurface. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCce_1_1InterfaceManagers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1InterfaceManagers.html">InterfaceManagers</a></td></tr>
<tr class="memdesc:namespaceCce_1_1InterfaceManagers"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains utilities for collecting, interpolating, and providing worldtube data for CCE that originates from other components in a running simulation. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceCce_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceCce_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCce_1_1Tags.html" title="Tags for Cauchy Characteristic Extraction routines.">Tags</a> for Cauchy Characteristic Extraction routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1AnalyticBoundaryDataManager.html">AnalyticBoundaryDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A boundary data manager that constructs the desired boundary data into the <code>Variables</code> from the data provided by the analytic solution.  <a href="classCce_1_1AnalyticBoundaryDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace.html">ApplySwshJacobianInplace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mutation to a spin-weighted spherical harmonic derivative value from the numerical coordinate (the spin-weighted derivative at fixed \(y\)) to the Bondi coordinates (the spin-weighted derivative at fixed \(r\)), inplace to the requested tag.  <a href="structCce_1_1ApplySwshJacobianInplace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Eth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Ethbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1BondiWorldtubeDataManager.html">BondiWorldtubeDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the 'reduced' cached buffer dataset associated with a CCE worldtube and interpolates to requested time points to provide worldtube boundary data to the main evolution routines.  <a href="classCce_1_1BondiWorldtubeDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1BondiWorldtubeH5BufferUpdater.html">BondiWorldtubeH5BufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html" title="Abstract base class for utilities that are able to perform the buffer updating procedure needed by th...">WorldtubeBufferUpdater</a></code> specialized to the CCE input worldtube H5 file produced by the reduced SpEC format.  <a href="classCce_1_1BondiWorldtubeH5BufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue.html">CalculateScriPlusValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1EthInertialRetardedTime_01_4.html">CalculateScriPlusValue&lt; Tags::EthInertialRetardedTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the angular derivative of the asymptotic inertial time, useful for asymptotic coordinate transformations.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1EthInertialRetardedTime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1News_01_4.html">CalculateScriPlusValue&lt; Tags::News &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi news from the evolution quantities.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1News_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi0_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi0 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_0\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi0_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi1_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi1 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_1\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi1_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi2_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_2\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi3_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Psi3 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of \(\Psi_3\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi3_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Strain_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::ScriPlus&lt; Tags::Strain &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the leading part of the strain \(h\) near \(\mathcal I^+\).  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1ScriPlus_3_01Tags_1_1Strain_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1TimeIntegral_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi4_01_4_01_4_01_4.html">CalculateScriPlusValue&lt; Tags::TimeIntegral&lt; Tags::ScriPlus&lt; Tags::Psi4 &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the contribution to the leading \(\Psi_4\) that corresponds to a total time derivative.  <a href="structCce_1_1CalculateScriPlusValue_3_01Tags_1_1TimeIntegral_3_01Tags_1_1ScriPlus_3_01Tags_1_1Psi4_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CalculateScriPlusValue_3_1_1Tags_1_1dt_3_01Tags_1_1InertialRetardedTime_01_4_01_4.html">CalculateScriPlusValue&lt;::Tags::dt&lt; Tags::InertialRetardedTime &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the time derivative of the asymptotically inertial time coordinate.  <a href="structCce_1_1CalculateScriPlusValue_3_1_1Tags_1_1dt_3_01Tags_1_1InertialRetardedTime_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1CharacteristicEvolution.html">CharacteristicEvolution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The component for handling the CCE evolution and waveform output.  <a href="structCce_1_1CharacteristicEvolution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.  <a href="structCce_1_1ComputeBondiIntegrand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(\beta\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(U\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactor&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(H\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactorForConjugate&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(\bar{H}\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue.html">GaugeAdjustedBoundaryValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gauge-transformed <code><a class="el" href="structCce_1_1Tags_1_1EvolutionGaugeBoundaryValue.html" title="A prefix tag representing the gauge-transformed boundary data for a quantity on the extraction surfac...">Tags::EvolutionGaugeBoundaryValue</a>&lt;Tag&gt;</code> for any of the boundary tags needed in the evolution.  <a href="structCce_1_1GaugeAdjustedBoundaryValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiBeta_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiBeta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat \beta\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiBeta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiH_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiH &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat H\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiH_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiJ_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiJ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat J\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiJ_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiQ_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiQ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat Q\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiQ_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiR_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge Bondi \(\hat R\) on the worldtube from Cauchy gauge quantities.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiU_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiU &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\mathcal U\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiU_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiW_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::BondiW &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\hat W\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1BondiW_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1Dr_3_01Tags_1_1BondiJ_01_4_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::Dr&lt; Tags::BondiJ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge quantity \(\partial_{\hat r} \hat J\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1Dr_3_01Tags_1_1BondiJ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1DuRDividedByR_01_4.html">GaugeAdjustedBoundaryValue&lt; Tags::DuRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the evolution gauge \(\partial_{\hat u} \hat R / \hat R\) on the worldtube.  <a href="structCce_1_1GaugeAdjustedBoundaryValue_3_01Tags_1_1DuRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateAngularFromCartesian.html">GaugeUpdateAngularFromCartesian</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the angular coordinates stored in <code>AngularTag</code> via trigonometric operations applied to the Cartesian coordinates stored in <code>CartesianTag</code>.  <a href="structCce_1_1GaugeUpdateAngularFromCartesian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateInterpolator.html">GaugeUpdateInterpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the interpolator stored in <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshInterpolator.html" title="Tag for a SwshInterpolator associated with a particular set of angular coordinates.">Spectral::Swsh::Tags::SwshInterpolator</a>&lt;AngularCoordinates&gt;</code>.  <a href="structCce_1_1GaugeUpdateInterpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateJacobianFromCoordinates.html">GaugeUpdateJacobianFromCoordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">From the angular coordinates <code>AngularCoordinateTag</code> and the Cartesian coordinates <code>CartesianCoordinateTag</code>, determine the spin-weighted Jacobian factors <code>GaugeFactorSpin2</code> and <code>GaugeFactorSpin0</code>.  <a href="structCce_1_1GaugeUpdateJacobianFromCoordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateOmega.html">GaugeUpdateOmega</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the quantity \(\hat \omega\) and \(\hat \eth \hat \omega\) for updated spin-weighted Jacobian quantities \(\hat c\) and \(\hat d\).  <a href="structCce_1_1GaugeUpdateOmega.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GaugeUpdateTimeDerivatives.html">GaugeUpdateTimeDerivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the Cauchy gauge cartesian coordinate derivative \(\partial_u x(\hat x)\), as well as remaining gauge quantities \(\mathcal U^{(0)}\), \(\hat U \equiv \mathcal U - \mathcal U^{(0)}\), and \(\partial_{\hat u} \hat \omega\) to maintain asymptotically inertial angular coordinates.  <a href="structCce_1_1GaugeUpdateTimeDerivatives.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1GhWorldtubeBoundary.html">GhWorldtubeBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component that supplies CCE worldtube boundary data sourced from a running GH system.  <a href="structCce_1_1GhWorldtubeBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1H5WorldtubeBoundary.html">H5WorldtubeBoundary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Component that supplies CCE worldtube boundary data.  <a href="structCce_1_1H5WorldtubeBoundary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeGauge.html">InitializeGauge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize to default values (identity transform) all of the angular gauge quantities for the boundary gauge transforms.  <a href="structCce_1_1InitializeGauge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeScriPlusValue.html">InitializeScriPlusValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the \(\mathcal I^+\) value <code>Tag</code> for the first hypersurface.  <a href="structCce_1_1InitializeScriPlusValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeScriPlusValue_3_01Tags_1_1InertialRetardedTime_01_4.html">InitializeScriPlusValue&lt; Tags::InertialRetardedTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the inertial retarded time to the value provided in the mutator arguments.  <a href="structCce_1_1InitializeScriPlusValue_3_01Tags_1_1InertialRetardedTime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1MetricWorldtubeDataManager.html">MetricWorldtubeDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manages the cached buffer data associated with a CCE worldtube and interpolates to requested time points to provide worldtube boundary data to the main evolution routines.  <a href="classCce_1_1MetricWorldtubeDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1MetricWorldtubeH5BufferUpdater.html">MetricWorldtubeH5BufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html" title="Abstract base class for utilities that are able to perform the buffer updating procedure needed by th...">WorldtubeBufferUpdater</a></code> specialized to the CCE input worldtube H5 file produced by SpEC.  <a href="classCce_1_1MetricWorldtubeH5BufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1mock__gh__worldtube__boundary.html">mock_gh_worldtube_boundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1mock__h5__worldtube__boundary.html">mock_h5_worldtube_boundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>ComputePreSwshDerivatives</code>.  <a href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies.html">PrecomputeCceDependencies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that can be computed before any of the intermediate integrands are evaluated.  <a href="structCce_1_1PrecomputeCceDependencies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiK &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(K = \sqrt{1 + J \bar{J}}\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a volume version of Bondi radius of the worldtube \(R\) from its boundary value (by repeating it over the radial dimension)  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::DuRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\partial_u R / R\) from its boundary value (by repeating it over the radial dimension).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthbarRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \bar{\eth} R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::OneMinusY &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(1 - y\) for the CCE system.  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives.html">PreSwshDerivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that are to be performed prior to the spin-weighted spherical harmonic differentiation (and for the first step in the series of integrations, after the <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>)  <a href="structCce_1_1PreSwshDerivatives.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiJbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiQbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiQbar &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiUbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{U}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1ComplexInertialRetardedTime_01_4.html">PreSwshDerivatives&lt; Tags::ComplexInertialRetardedTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the values of the inertial retarded time into a spin-weighted container so that spin-weighted derivatives can be taken.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1ComplexInertialRetardedTime_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Du_3_01Tags_1_1BondiJ_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Du&lt; Tags::BondiJ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\partial_u J\) from \(H\) and the Jacobian factors.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Du_3_01Tags_1_1BondiJ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Spectral::Swsh::Tags::Derivative&lt; Tag, DerivKind &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative with respect to the numerical radial coordinate \(y\) of a quantity which is a spin-weighted spherical harmonic derivative.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of the quantity represented by <code>Tag</code> with respect to the numerical radial coordinate \(y\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiBeta.html" title="Bondi parameter .">Tags::BondiBeta</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiU.html" title="Bondi parameter .">Tags::BondiU</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html">PreSwshDerivatives&lt; Tags::Exp2Beta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\exp(2 \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html">PreSwshDerivatives&lt; Tags::JbarQMinus2EthBeta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J} * (Q - 2 \eth \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of <code>Lhs</code> and <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Tags::BondiJbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiJbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiUbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{U}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi.html">RadialIntegrateBondi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational structs for evaluating the hypersurface integrals during CCE evolution. These are compatible with use in <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>.  <a href="structCce_1_1RadialIntegrateBondi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01BoundaryPrefix_00_01Tags_1_1BondiH_01_4.html">RadialIntegrateBondi&lt; BoundaryPrefix, Tags::BondiH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01BoundaryPrefix_00_01Tags_1_1BondiQ_01_4.html">RadialIntegrateBondi&lt; BoundaryPrefix, Tags::BondiQ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01BoundaryPrefix_00_01Tags_1_1BondiW_01_4.html">RadialIntegrateBondi&lt; BoundaryPrefix, Tags::BondiW &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ReducedWorldtubeModeRecorder.html">ReducedWorldtubeModeRecorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Records a compressed representation of SpEC-like worldtube data associated with just the spin-weighted scalars required to perform the CCE algorithm.  <a href="structCce_1_1ReducedWorldtubeModeRecorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager.html">ScriPlusInterpolationManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+.  <a href="structCce_1_1ScriPlusInterpolationManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html">ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, ::Tags::Multiplies&lt; MultipliesLhs, MultipliesRhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+, multiplying two results together before supplying the result.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01_1_1Tags_1_1Multiplied29350d354cf4ec0a3881546a39c0e8b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01Tags_1_1Du_3_01Tag_01_4_01_4.html">ScriPlusInterpolationManager&lt; VectorTypeToInterpolate, Tags::Du&lt; Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores necessary data and interpolates on to new time points at scri+, differentiating before supplying the result.  <a href="structCce_1_1ScriPlusInterpolationManager_3_01VectorTypeToInterpolate_00_01Tags_1_1Du_3_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by single spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1System.html">System</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1VolumeWeyl_3_01Tags_1_1Psi0_01_4.html">VolumeWeyl&lt; Tags::Psi0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Weyl scalar \(\Psi_0\) in the volume according to a standard set of Newman-Penrose vectors.  <a href="structCce_1_1VolumeWeyl_3_01Tags_1_1Psi0_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1WorldtubeBufferUpdater.html">WorldtubeBufferUpdater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for utilities that are able to perform the buffer updating procedure needed by the <code><a class="el" href="classCce_1_1WorldtubeDataManager.html" title="Abstract base class for managers of CCE worldtube data that is provided in large time-series chunks,...">WorldtubeDataManager</a></code>.  <a href="classCce_1_1WorldtubeBufferUpdater.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCce_1_1WorldtubeDataManager.html">WorldtubeDataManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class for managers of CCE worldtube data that is provided in large time-series chunks, especially the type provided by input <a class="el" href="namespaceh5.html" title="Contains functions and classes for manipulating HDF5 files.">h5</a> files.  <a href="classCce_1_1WorldtubeDataManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab0dea207566763a18d7d2f6532bd5dfd"><td class="memItemLeft" align="right" valign="top"><a id="ab0dea207566763a18d7d2f6532bd5dfd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericaliCartesianJ</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:ab0dea207566763a18d7d2f6532bd5dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2357637bb167d0426e1a45672def65"><td class="memItemLeft" align="right" valign="top"><a id="abe2357637bb167d0426e1a45672def65"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CartesianiSphericalJ</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:abe2357637bb167d0426e1a45672def65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa681669edbebc79cba9ee0b268db7230"><td class="memItemLeft" align="right" valign="top"><a id="aa681669edbebc79cba9ee0b268db7230"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AngulariCartesianA</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 2, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">SpacetimeIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:aa681669edbebc79cba9ee0b268db7230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f2be398a836fdcf44ea1d29c080b6f"><td class="memItemLeft" align="right" valign="top"><a id="a73f2be398a836fdcf44ea1d29c080b6f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>SphericaliCartesianjj</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a73f2be398a836fdcf44ea1d29c080b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplParams" colspan="2"><a id="a613ab75a0e0153ef33518a6b3f358457"></a>
template&lt;typename BondiVariable &gt; </td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a613ab75a0e0153ef33518a6b3f358457">integrand_terms_to_compute_for_bondi_variable</a> = typename detail::integrand_terms_to_compute_for_bondi_variable_impl&lt; BondiVariable &gt;::type</td></tr>
<tr class="memdesc:a613ab75a0e0153ef33518a6b3f358457"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for providing a <code>tmpl::list</code> of integrand tags that need to be computed before integration can proceed for a given Bondi variable tag. <br /></td></tr>
<tr class="separator:a613ab75a0e0153ef33518a6b3f358457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="memItemLeft" align="right" valign="top"><a id="a8b589ed5dc0a4995bee4ef742972e7a0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8b589ed5dc0a4995bee4ef742972e7a0">gauge_adjustments_setup_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a>, <a class="el" href="structCce_1_1Tags_1_1Dr.html">Tags::Dr</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;</td></tr>
<tr class="memdesc:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The set of tags that should be calculated before the initial data is computed on the first hypersurface. <br /></td></tr>
<tr class="separator:a8b589ed5dc0a4995bee4ef742972e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="namespaceCce_1_1Tags.html#a1987e592fa6f5a8aafaa0273b4e94505">Tags::BondiH</a> &gt;</td></tr>
<tr class="separator:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">integrand_temporary_tags</a> = typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt; Tag &gt;::temporary_tags</td></tr>
<tr class="separator:a393d5c196acb92779ba89acbc1fa686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">pre_computation_boundary_tags</a> = tmpl::list&lt; BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;, BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa00307a414eb1f569706cb7d7449fa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>.  <a href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">More...</a><br /></td></tr>
<tr class="separator:aa00307a414eb1f569706cb7d7449fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474">pre_computation_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;</td></tr>
<tr class="memdesc:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>.  <a href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474">More...</a><br /></td></tr>
<tr class="separator:a7a4a1a7fe54a9f77fbf034fb95f46474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplParams" colspan="2"><a id="ae3c2adc1f0d1a2b33905452c9b9a645b"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pre_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplParams" colspan="2"><a id="a70495dd357c5c456b5ed2fd65cbcd2de"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>single_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84087fc88c281ff3c42ddcc63abf652"><td class="memTemplParams" colspan="2"><a id="aa84087fc88c281ff3c42ddcc63abf652"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aa84087fc88c281ff3c42ddcc63abf652"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>second_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:aa84087fc88c281ff3c42ddcc63abf652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4911f02776875e5d7fbb3d6f66ef5a55"><td class="memItemLeft" align="right" valign="top"><a id="a4911f02776875e5d7fbb3d6f66ef5a55"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a4911f02776875e5d7fbb3d6f66ef5a55">all_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Eth.html">Spectral::Swsh::Tags::Eth</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1EthEthbar.html">Spectral::Swsh::Tags::EthEthbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Ethbar.html">Spectral::Swsh::Tags::Ethbar</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Eth.html">Spectral::Swsh::Tags::Eth</a> &gt; &gt;</td></tr>
<tr class="memdesc:a4911f02776875e5d7fbb3d6f66ef5a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code>SwshDerivatives</code> mutations called on volume quantities needed for scri+ computations. <br /></td></tr>
<tr class="separator:a4911f02776875e5d7fbb3d6f66ef5a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ee1fe370aef231d5c9a213f307f9cc"><td class="memItemLeft" align="right" valign="top"><a id="a82ee1fe370aef231d5c9a213f307f9cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a82ee1fe370aef231d5c9a213f307f9cc">all_boundary_pre_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1ComplexInertialRetardedTime.html">Tags::ComplexInertialRetardedTime</a> &gt;</td></tr>
<tr class="memdesc:a82ee1fe370aef231d5c9a213f307f9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code><a class="el" href="structCce_1_1PreSwshDerivatives.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that are to be ...">PreSwshDerivatives</a></code> mutations called on boundary (angular grid only) quantities needed for scri+ computations. <br /></td></tr>
<tr class="separator:a82ee1fe370aef231d5c9a213f307f9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f7f7d9ff20deabef15333769ea919c2"><td class="memItemLeft" align="right" valign="top"><a id="a2f7f7d9ff20deabef15333769ea919c2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a2f7f7d9ff20deabef15333769ea919c2">all_boundary_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1ComplexInertialRetardedTime.html">Tags::ComplexInertialRetardedTime</a>, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1EthEth.html">Spectral::Swsh::Tags::EthEth</a> &gt; &gt;</td></tr>
<tr class="memdesc:a2f7f7d9ff20deabef15333769ea919c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code>SwshDerivatives</code> mutations called on boundary (angular grid only) quantities needed for scri+ computations. <br /></td></tr>
<tr class="separator:a2f7f7d9ff20deabef15333769ea919c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c937a1e34a4865805c5680f8f7872d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d">all_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt; &gt;&gt;, <a class="el" href="namespaceCce.html#a4911f02776875e5d7fbb3d6f66ef5a55">all_swsh_derivative_tags_for_scri</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ad8c937a1e34a4865805c5680f8f7872d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d">More...</a><br /></td></tr>
<tr class="separator:ad8c937a1e34a4865805c5680f8f7872d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">all_transform_buffer_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d">all_swsh_derivative_tags</a>, tmpl::bind&lt; <a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>.  <a href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">More...</a><br /></td></tr>
<tr class="separator:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0ceab2533f417cc55b2430cd136046"><td class="memItemLeft" align="right" valign="top"><a id="adf0ceab2533f417cc55b2430cd136046"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#adf0ceab2533f417cc55b2430cd136046">all_pre_swsh_derivative_tags_for_scri</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt; &gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1Derivative.html">Spectral::Swsh::Tags::Derivative</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1EthEthbar.html">Spectral::Swsh::Tags::EthEthbar</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:adf0ceab2533f417cc55b2430cd136046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typelist of steps for <code><a class="el" href="structCce_1_1PreSwshDerivatives.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that are to be ...">PreSwshDerivatives</a></code> mutations needed for scri+ computations. <br /></td></tr>
<tr class="separator:adf0ceab2533f417cc55b2430cd136046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd34947472e61d70007727517310500"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500">all_pre_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, detail::additional_pre_swsh_derivative_tags_for&lt; tmpl::_1 &gt; &gt;&gt;, <a class="el" href="namespaceCce.html#adf0ceab2533f417cc55b2430cd136046">all_pre_swsh_derivative_tags_for_scri</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a7dd34947472e61d70007727517310500"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>.  <a href="namespaceCce.html#a7dd34947472e61d70007727517310500">More...</a><br /></td></tr>
<tr class="separator:a7dd34947472e61d70007727517310500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada9e323f3e8e68e01f9d35d4575a04"><td class="memItemLeft" align="right" valign="top"><a id="a1ada9e323f3e8e68e01f9d35d4575a04"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a1ada9e323f3e8e68e01f9d35d4575a04">scri_plus_interpolation_set</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1News.html">Tags::News</a>, <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Strain.html">Tags::Strain</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Psi3.html">Tags::Psi3</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Psi2.html">Tags::Psi2</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Psi1.html">Tags::Psi1</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Psi0.html">Tags::Psi0</a> &gt;, <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1TimeIntegral.html">Tags::TimeIntegral</a>&lt; <a class="el" href="structCce_1_1Tags_1_1ScriPlus.html">Tags::ScriPlus</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Psi4.html">Tags::Psi4</a> &gt; &gt;&gt;, <a class="el" href="structCce_1_1Tags_1_1EthInertialRetardedTime.html">Tags::EthInertialRetardedTime</a> &gt;</td></tr>
<tr class="memdesc:a1ada9e323f3e8e68e01f9d35d4575a04"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tags that are needed to be interpolated at scri+ for the available observation tags. <br /></td></tr>
<tr class="separator:a1ada9e323f3e8e68e01f9d35d4575a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplParams" colspan="2"><a id="aad3fb4002f488cbb49de99c785b1c1b5"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aad3fb4002f488cbb49de99c785b1c1b5">OnDemandInputsForSwshJacobian</a> = detail::OnDemandInputsForSwshJacobianImpl&lt; Tag, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; int, Tag::type::type::spin &gt;, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> &gt;</td></tr>
<tr class="memdesc:aad3fb4002f488cbb49de99c785b1c1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an expression template or reference to <code>Tag</code>, intended for situations for which a repeated computation is more desirable than storing a value in the <a class="el" href="group__DataBoxGroup.html">DataBox</a> (e.g. for conjugation and simple product rule expansion). <br /></td></tr>
<tr class="separator:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52426e67ced266a64ad90e0b287b739c"><td class="memItemLeft" align="right" valign="top"><a id="a52426e67ced266a64ad90e0b287b739c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a52426e67ced266a64ad90e0b287b739c">cce_metric_input_tags</a> = tmpl::list&lt; <a class="el" href="structgr_1_1Tags_1_1SpatialMetric.html">Tags::detail::SpatialMetric</a>, Tags::detail::Dr&lt; <a class="el" href="structgr_1_1Tags_1_1SpatialMetric.html">Tags::detail::SpatialMetric</a> &gt;, ::<a class="el" href="structTags_1_1dt.html">Tags::dt</a>&lt; <a class="el" href="structgr_1_1Tags_1_1SpatialMetric.html">Tags::detail::SpatialMetric</a> &gt;, <a class="el" href="structgr_1_1Tags_1_1Shift.html">Tags::detail::Shift</a>, Tags::detail::Dr&lt; <a class="el" href="structgr_1_1Tags_1_1Shift.html">Tags::detail::Shift</a> &gt;, ::<a class="el" href="structTags_1_1dt.html">Tags::dt</a>&lt; <a class="el" href="structgr_1_1Tags_1_1Shift.html">Tags::detail::Shift</a> &gt;, <a class="el" href="structgr_1_1Tags_1_1Lapse.html">Tags::detail::Lapse</a>, Tags::detail::Dr&lt; <a class="el" href="structgr_1_1Tags_1_1Lapse.html">Tags::detail::Lapse</a> &gt;, ::<a class="el" href="structTags_1_1dt.html">Tags::dt</a>&lt; <a class="el" href="structgr_1_1Tags_1_1Lapse.html">Tags::detail::Lapse</a> &gt; &gt;</td></tr>
<tr class="memdesc:a52426e67ced266a64ad90e0b287b739c"><td class="mdescLeft">&#160;</td><td class="mdescRight">the full set of tensors to be extracted from the worldtube <a class="el" href="namespaceh5.html" title="Contains functions and classes for manipulating HDF5 files.">h5</a> file <br /></td></tr>
<tr class="separator:a52426e67ced266a64ad90e0b287b739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56e5809bbb71c54f4bae68c190aaf1d"><td class="memItemLeft" align="right" valign="top"><a id="ae56e5809bbb71c54f4bae68c190aaf1d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ae56e5809bbb71c54f4bae68c190aaf1d">cce_bondi_input_tags</a> = tmpl::list&lt; <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Dr.html">Tags::Dr</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiJ.html">Tags::BondiJ</a> &gt; &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;, <a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1SwshTransform.html">Spectral::Swsh::Tags::SwshTransform</a>&lt; <a class="el" href="structCce_1_1Tags_1_1Du.html">Tags::Du</a>&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ae56e5809bbb71c54f4bae68c190aaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">the full set of tensors to be extracted from the reduced form of the worldtube <a class="el" href="namespaceh5.html" title="Contains functions and classes for manipulating HDF5 files.">h5</a> file <br /></td></tr>
<tr class="separator:ae56e5809bbb71c54f4bae68c190aaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3dda5971b9476e59f67ec69b3f10a5da"><td class="memItemLeft" align="right" valign="top"><a id="a3dda5971b9476e59f67ec69b3f10a5da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trigonometric_functions_on_swsh_collocation</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cos_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cos_theta, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; sin_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; sin_theta, const size_t l_max) noexcept</td></tr>
<tr class="separator:a3dda5971b9476e59f67ec69b3f10a5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fa2c53bdae29aadb60939aa9e7f9fe"><td class="memItemLeft" align="right" valign="top"><a id="a31fa2c53bdae29aadb60939aa9e7f9fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_to_spherical_coordinates_and_jacobians</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; unit_cartesian_coords, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ * &gt; cartesian_to_spherical_jacobian, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ * &gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const double extraction_radius) noexcept</td></tr>
<tr class="separator:a31fa2c53bdae29aadb60939aa9e7f9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d2c2def915f4355ad4b062152c5ce4"><td class="memItemLeft" align="right" valign="top"><a id="af3d2c2def915f4355ad4b062152c5ce4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; inverse_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:af3d2c2def915f4355ad4b062152c5ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab9abf0b4cc2302c83de7a5ad4df70e"><td class="memItemLeft" align="right" valign="top"><a id="a2ab9abf0b4cc2302c83de7a5ad4df70e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_shift_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:a2ab9abf0b4cc2302c83de7a5ad4df70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84585f167795f2b236d2cb3de17486ee"><td class="memItemLeft" align="right" valign="top"><a id="a84585f167795f2b236d2cb3de17486ee"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_lapse_and_derivatives_from_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; dt_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const size_t l_max) noexcept</td></tr>
<tr class="separator:a84585f167795f2b236d2cb3de17486ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f19b975c46ad321e43341c6c9a432e7"><td class="memItemLeft" align="right" valign="top"><a id="a2f19b975c46ad321e43341c6c9a432e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_metric_and_derivative</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; du_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; null_metric, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:a2f19b975c46ad321e43341c6c9a432e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f602f916bb2ddf7b051f563c7b82011"><td class="memItemLeft" align="right" valign="top"><a id="a4f602f916bb2ddf7b051f563c7b82011"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>worldtube_normal_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; worldtube_normal, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="separator:a4f602f916bb2ddf7b051f563c7b82011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8d32c182fe16fde0e42c1d8e1ec36d"><td class="memItemLeft" align="right" valign="top"><a id="a4a8d32c182fe16fde0e42c1d8e1ec36d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_vector_l_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; du_null_l, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="separator:a4a8d32c182fe16fde0e42c1d8e1ec36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61064b985207950dac4731ae7d9c54b"><td class="memItemLeft" align="right" valign="top"><a id="ab61064b985207950dac4731ae7d9c54b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dlambda_null_metric_and_inverse</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; dlambda_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; dlambda_inverse_null_metric, const AngulariCartesianA &amp;angular_d_null_l, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:ab61064b985207950dac4731ae7d9c54b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba498ecf9e9a05c1561ee4729234cfbd"><td class="memItemLeft" align="right" valign="top"><a id="aba498ecf9e9a05c1561ee4729234cfbd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric) noexcept</td></tr>
<tr class="separator:aba498ecf9e9a05c1561ee4729234cfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb37ce4b4afab7cc74c03a123b433be"><td class="memItemLeft" align="right" valign="top"><a id="a3cb37ce4b4afab7cc74c03a123b433be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>d_bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const size_t l_max) noexcept</td></tr>
<tr class="separator:a3cb37ce4b4afab7cc74c03a123b433be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff77c30b8b1b18f19b36d16163e6a135"><td class="memItemLeft" align="right" valign="top"><a id="aff77c30b8b1b18f19b36d16163e6a135"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dyads</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; down_dyad, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; up_dyad) noexcept</td></tr>
<tr class="separator:aff77c30b8b1b18f19b36d16163e6a135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a69f7421409b657370ae278f47c57"><td class="memItemLeft" align="right" valign="top"><a id="a285a69f7421409b657370ae278f47c57"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>beta_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; beta, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r) noexcept</td></tr>
<tr class="separator:a285a69f7421409b657370ae278f47c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5525d645705e299b488898255b313b"><td class="memItemLeft" align="right" valign="top"><a id="a7d5525d645705e299b488898255b313b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_u_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; bondi_u, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric) noexcept</td></tr>
<tr class="separator:a7d5525d645705e299b488898255b313b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96addb2ec1d1f7db574294d4d3527ce"><td class="memItemLeft" align="right" valign="top"><a id="ad96addb2ec1d1f7db574294d4d3527ce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_w_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; bondi_w, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="separator:ad96addb2ec1d1f7db574294d4d3527ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34670afc18057185364b9fda192db10"><td class="memItemLeft" align="right" valign="top"><a id="ae34670afc18057185364b9fda192db10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_j_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:ae34670afc18057185364b9fda192db10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b6b6c1fceb058c916856d07e58844c"><td class="memItemLeft" align="right" valign="top"><a id="a91b6b6c1fceb058c916856d07e58844c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dr_bondi_j</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; dr_bondi_j, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; denominator_buffer, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:a91b6b6c1fceb058c916856d07e58844c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115628ca5136181ddd63c12b3bbdbb64"><td class="memItemLeft" align="right" valign="top"><a id="a115628ca5136181ddd63c12b3bbdbb64"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>d2lambda_bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; d2lambda_bondi_r, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;dr_bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="separator:a115628ca5136181ddd63c12b3bbdbb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd68ef884fc362404559637f02ac1e96"><td class="memItemLeft" align="right" valign="top"><a id="acd68ef884fc362404559637f02ac1e96"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_q_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; bondi_q, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; dr_bondi_u, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;d2lambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_inverse_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;angular_d_dlambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;bondi_u) noexcept</td></tr>
<tr class="separator:acd68ef884fc362404559637f02ac1e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d47af13868996789b72122b5ed6190"><td class="memItemLeft" align="right" valign="top"><a id="ab1d47af13868996789b72122b5ed6190"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bondi_h_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; bondi_h, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:ab1d47af13868996789b72122b5ed6190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5232bac341dc737afcb776d02813b0f0"><td class="memItemLeft" align="right" valign="top"><a id="a5232bac341dc737afcb776d02813b0f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>du_j_worldtube_data</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; du_bondi_j, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="separator:a5232bac341dc737afcb776d02813b0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeafc63c7c01088a03aef934f9bf2ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aeeafc63c7c01088a03aef934f9bf2ae4">trigonometric_functions_on_swsh_collocation</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cos_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cos_theta, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; sin_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; sin_theta, size_t l_max) noexcept</td></tr>
<tr class="memdesc:aeeafc63c7c01088a03aef934f9bf2ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order.  <a href="namespaceCce.html#aeeafc63c7c01088a03aef934f9bf2ae4">More...</a><br /></td></tr>
<tr class="separator:aeeafc63c7c01088a03aef934f9bf2ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5ea199fec6321ecfaef02e23913def"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#abf5ea199fec6321ecfaef02e23913def">cartesian_to_spherical_coordinates_and_jacobians</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; unit_cartesian_coords, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ * &gt; cartesian_to_spherical_jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ * &gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, double extraction_radius) noexcept</td></tr>
<tr class="memdesc:abf5ea199fec6321ecfaef02e23913def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves.  <a href="namespaceCce.html#abf5ea199fec6321ecfaef02e23913def">More...</a><br /></td></tr>
<tr class="separator:abf5ea199fec6321ecfaef02e23913def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c079e3e99fa77193ff66426b76ebd"><td class="memItemLeft" align="right" valign="top"><a id="a506c079e3e99fa77193ff66426b76ebd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_modes</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; inverse_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="separator:a506c079e3e99fa77193ff66426b76ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051bc858cc4a2d582968c38c7d2d7b44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a051bc858cc4a2d582968c38c7d2d7b44">cartesian_shift_and_derivatives_from_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a051bc858cc4a2d582968c38c7d2d7b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="namespaceCce.html#a051bc858cc4a2d582968c38c7d2d7b44">More...</a><br /></td></tr>
<tr class="separator:a051bc858cc4a2d582968c38c7d2d7b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1da9eb6a9e2d127eaf95c1ab3f7b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7d1da9eb6a9e2d127eaf95c1ab3f7b03">cartesian_lapse_and_derivatives_from_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; dt_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a7d1da9eb6a9e2d127eaf95c1ab3f7b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="namespaceCce.html#a7d1da9eb6a9e2d127eaf95c1ab3f7b03">More...</a><br /></td></tr>
<tr class="separator:a7d1da9eb6a9e2d127eaf95c1ab3f7b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c09ce690887bbc85cc2795f46d4ea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a92c09ce690887bbc85cc2795f46d4ea2">null_metric_and_derivative</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; du_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; null_metric, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:a92c09ce690887bbc85cc2795f46d4ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime metric and its first derivative in the intermediate radial null coordinates.  <a href="namespaceCce.html#a92c09ce690887bbc85cc2795f46d4ea2">More...</a><br /></td></tr>
<tr class="separator:a92c09ce690887bbc85cc2795f46d4ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41670f303c4b35dbde41cba79a8f638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ac41670f303c4b35dbde41cba79a8f638">worldtube_normal_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; worldtube_normal, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="memdesc:ac41670f303c4b35dbde41cba79a8f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative.  <a href="namespaceCce.html#ac41670f303c4b35dbde41cba79a8f638">More...</a><br /></td></tr>
<tr class="separator:ac41670f303c4b35dbde41cba79a8f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7b45583c0c7a0133374d9ec2fb8dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aeb7b45583c0c7a0133374d9ec2fb8dde">null_vector_l_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; du_null_l, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="memdesc:aeb7b45583c0c7a0133374d9ec2fb8dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\).  <a href="namespaceCce.html#aeb7b45583c0c7a0133374d9ec2fb8dde">More...</a><br /></td></tr>
<tr class="separator:aeb7b45583c0c7a0133374d9ec2fb8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346aed34f7eac2b1cf1c7ec1cc77b2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a346aed34f7eac2b1cf1c7ec1cc77b2c8">dlambda_null_metric_and_inverse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; dlambda_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; dlambda_inverse_null_metric, const AngulariCartesianA &amp;angular_d_null_l, const SphericaliCartesianJ &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:a346aed34f7eac2b1cf1c7ec1cc77b2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\).  <a href="namespaceCce.html#a346aed34f7eac2b1cf1c7ec1cc77b2c8">More...</a><br /></td></tr>
<tr class="separator:a346aed34f7eac2b1cf1c7ec1cc77b2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d58c5d828563b7be381f2ef4358c24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a3d58c5d828563b7be381f2ef4358c24e">bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric) noexcept</td></tr>
<tr class="memdesc:a3d58c5d828563b7be381f2ef4358c24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Bondi radius of the worldtube.  <a href="namespaceCce.html#a3d58c5d828563b7be381f2ef4358c24e">More...</a><br /></td></tr>
<tr class="separator:a3d58c5d828563b7be381f2ef4358c24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded277b1cb65d5c34a0a55b4bd2f6b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aded277b1cb65d5c34a0a55b4bd2f6b34">d_bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, size_t l_max) noexcept</td></tr>
<tr class="memdesc:aded277b1cb65d5c34a0a55b4bd2f6b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates.  <a href="namespaceCce.html#aded277b1cb65d5c34a0a55b4bd2f6b34">More...</a><br /></td></tr>
<tr class="separator:aded277b1cb65d5c34a0a55b4bd2f6b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9857365c0887c3233aff0ced1b96e738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9857365c0887c3233aff0ced1b96e738">dyads</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; down_dyad, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt; up_dyad) noexcept</td></tr>
<tr class="memdesc:a9857365c0887c3233aff0ced1b96e738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system.  <a href="namespaceCce.html#a9857365c0887c3233aff0ced1b96e738">More...</a><br /></td></tr>
<tr class="separator:a9857365c0887c3233aff0ced1b96e738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6fb09ea34d9ca7e9095e873d85dbe3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#acb6fb09ea34d9ca7e9095e873d85dbe3">beta_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; beta, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r) noexcept</td></tr>
<tr class="memdesc:acb6fb09ea34d9ca7e9095e873d85dbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(\beta\) (lapse) function for the CCE Bondi-like metric.  <a href="namespaceCce.html#acb6fb09ea34d9ca7e9095e873d85dbe3">More...</a><br /></td></tr>
<tr class="separator:acb6fb09ea34d9ca7e9095e873d85dbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadca2284f5bc7c2cbfbd6edb09198d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aadca2284f5bc7c2cbfbd6edb09198d3f">bondi_u_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; bondi_u, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric) noexcept</td></tr>
<tr class="memdesc:aadca2284f5bc7c2cbfbd6edb09198d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(U\) (shift) function for the CCE Bondi-like metric.  <a href="namespaceCce.html#aadca2284f5bc7c2cbfbd6edb09198d3f">More...</a><br /></td></tr>
<tr class="separator:aadca2284f5bc7c2cbfbd6edb09198d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44787f40e187fcf6c875424df8e10624"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a44787f40e187fcf6c875424df8e10624">bondi_w_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; bondi_w, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="memdesc:a44787f40e187fcf6c875424df8e10624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(W\) (mass aspect) function for the CCE Bondi-like metric.  <a href="namespaceCce.html#a44787f40e187fcf6c875424df8e10624">More...</a><br /></td></tr>
<tr class="separator:a44787f40e187fcf6c875424df8e10624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a8fc67e25101bfb7ac540af4ad1b51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a31a8fc67e25101bfb7ac540af4ad1b51">bondi_j_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a31a8fc67e25101bfb7ac540af4ad1b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the \(J\) (intuitively similar to the transverse-traceless part of the angular metric) function for the CCE Bondi-like metric.  <a href="namespaceCce.html#a31a8fc67e25101bfb7ac540af4ad1b51">More...</a><br /></td></tr>
<tr class="separator:a31a8fc67e25101bfb7ac540af4ad1b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ae659867e50f28936e38a46b2d576d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a03ae659867e50f28936e38a46b2d576d">dr_bondi_j</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; dr_bondi_j, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; denominator_buffer, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a03ae659867e50f28936e38a46b2d576d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the radial derivative of the angular metric spin-weighted scalar \(\partial_r J\) in the CCE Bondi-like metric.  <a href="namespaceCce.html#a03ae659867e50f28936e38a46b2d576d">More...</a><br /></td></tr>
<tr class="separator:a03ae659867e50f28936e38a46b2d576d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d7cd96510ef0162f8ed24c40962248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ab2d7cd96510ef0162f8ed24c40962248">d2lambda_bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; d2lambda_bondi_r, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;dr_bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r) noexcept</td></tr>
<tr class="memdesc:ab2d7cd96510ef0162f8ed24c40962248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the second derivative of the Bondi radius with respect to the intermediate null coordinate radius \(\partial_\lambda^2 r\).  <a href="namespaceCce.html#ab2d7cd96510ef0162f8ed24c40962248">More...</a><br /></td></tr>
<tr class="separator:ab2d7cd96510ef0162f8ed24c40962248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce844948054444e8eaf3f962da770a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9ce844948054444e8eaf3f962da770a4">bondi_q_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; bondi_q, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; dr_bondi_u, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;d2lambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_inverse_null_metric, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad, const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;angular_d_dlambda_r, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;bondi_u) noexcept</td></tr>
<tr class="memdesc:a9ce844948054444e8eaf3f962da770a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \(Q\) (radial derivative of shift).  <a href="namespaceCce.html#a9ce844948054444e8eaf3f962da770a4">More...</a><br /></td></tr>
<tr class="separator:a9ce844948054444e8eaf3f962da770a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6def3d12e2e4937975dbe417640d4159"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a6def3d12e2e4937975dbe417640d4159">bondi_h_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; bondi_h, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a6def3d12e2e4937975dbe417640d4159"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \((\partial_u J)_{y} \equiv H\) (the retarded time derivative evaluated at fixed $y$ coordinate) on the worldtube boundary.  <a href="namespaceCce.html#a6def3d12e2e4937975dbe417640d4159">More...</a><br /></td></tr>
<tr class="separator:a6def3d12e2e4937975dbe417640d4159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da095a13b8076ad9c705507a73bcbb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a7da095a13b8076ad9c705507a73bcbb5">du_j_worldtube_data</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt; du_bondi_j, const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;bondi_j, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dyad) noexcept</td></tr>
<tr class="memdesc:a7da095a13b8076ad9c705507a73bcbb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Bondi metric contribution \((\partial_u J)_r\) (the retarded time derivative at fixed coordinate $r$) on the worldtube boundary.  <a href="namespaceCce.html#a7da095a13b8076ad9c705507a73bcbb5">More...</a><br /></td></tr>
<tr class="separator:a7da095a13b8076ad9c705507a73bcbb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fcb28e3a34d986808172243ae7737b"><td class="memTemplParams" colspan="2">template&lt;typename BoundaryTagList &gt; </td></tr>
<tr class="memitem:a63fcb28e3a34d986808172243ae7737b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a63fcb28e3a34d986808172243ae7737b">create_bondi_boundary_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; BoundaryTagList &gt; * &gt; bondi_boundary_data, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;pi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:a63fcb28e3a34d986808172243ae7737b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from generalized harmonic quantities to desired Bondi quantities, placing the result in the passed <code>Variables</code>.  <a href="namespaceCce.html#a63fcb28e3a34d986808172243ae7737b">More...</a><br /></td></tr>
<tr class="separator:a63fcb28e3a34d986808172243ae7737b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918a7d65e199495fd2542a9c0cb4536c"><td class="memTemplParams" colspan="2">template&lt;typename BoundaryTagList &gt; </td></tr>
<tr class="memitem:a918a7d65e199495fd2542a9c0cb4536c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a918a7d65e199495fd2542a9c0cb4536c">create_bondi_boundary_data</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; BoundaryTagList &gt; * &gt; bondi_boundary_data, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:a918a7d65e199495fd2542a9c0cb4536c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from modal metric components and derivatives to desired Bondi quantities, placing the result in the passed <code>Variables</code>.  <a href="namespaceCce.html#a918a7d65e199495fd2542a9c0cb4536c">More...</a><br /></td></tr>
<tr class="separator:a918a7d65e199495fd2542a9c0cb4536c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656b8aae9d18e642af5d45de0a70b98"><td class="memItemLeft" align="right" valign="top"><a id="a1656b8aae9d18e642af5d45de0a70b98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>logical_partial_directional_derivative_of_complex</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, const size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="separator:a1656b8aae9d18e642af5d45de0a70b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9226695b7ca3a785963b8712b9c1b303"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9226695b7ca3a785963b8712b9c1b303">logical_partial_directional_derivative_of_complex</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="memdesc:a9226695b7ca3a785963b8712b9c1b303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>.  <a href="namespaceCce.html#a9226695b7ca3a785963b8712b9c1b303">More...</a><br /></td></tr>
<tr class="separator:a9226695b7ca3a785963b8712b9c1b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#af367dfeb1f3ee40aca23c628e9809ac1">precomputed_cce_q_integrator</a> (size_t number_of_radial_grid_points) noexcept</td></tr>
<tr class="memdesc:af367dfeb1f3ee40aca23c628e9809ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation.  <a href="namespaceCce.html#af367dfeb1f3ee40aca23c628e9809ac1">More...</a><br /></td></tr>
<tr class="separator:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87968a4f34802158f6bde03a693d0912"><td class="memItemLeft" align="right" valign="top"><a id="a87968a4f34802158f6bde03a693d0912"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radial_integrate_cce_pole_equations</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, const size_t l_max, const size_t number_of_radial_points) noexcept</td></tr>
<tr class="separator:a87968a4f34802158f6bde03a693d0912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ceddf5716fd1d0f97c862f63c6bc156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a4ceddf5716fd1d0f97c862f63c6bc156">radial_integrate_cce_pole_equations</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, size_t l_max, size_t number_of_radial_points) noexcept</td></tr>
<tr class="memdesc:a4ceddf5716fd1d0f97c862f63c6bc156"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution.  <a href="namespaceCce.html#a4ceddf5716fd1d0f97c862f63c6bc156">More...</a><br /></td></tr>
<tr class="separator:a4ceddf5716fd1d0f97c862f63c6bc156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f962054bfdc47d30af4658af9b691"><td class="memItemLeft" align="right" valign="top"><a id="a618f962054bfdc47d30af4658af9b691"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>weyl_psi0_impl</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt; * &gt; psi_0, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt; &amp;bondi_j, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt; &amp;dy_j, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt; &amp;dy_dy_j, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt; &amp;bondi_k, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt; &amp;bondi_r, const <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt; &amp;one_minus_y) noexcept</td></tr>
<tr class="separator:a618f962054bfdc47d30af4658af9b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a84b3c3c233bceb58f2cac20716f66"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </td></tr>
<tr class="memitem:a91a84b3c3c233bceb58f2cac20716f66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a91a84b3c3c233bceb58f2cac20716f66">mutate_all_precompute_cce_dependencies</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType * &gt; box) noexcept</td></tr>
<tr class="memdesc:a91a84b3c3c233bceb58f2cac20716f66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands.  <a href="namespaceCce.html#a91a84b3c3c233bceb58f2cac20716f66">More...</a><br /></td></tr>
<tr class="separator:a91a84b3c3c233bceb58f2cac20716f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b463a00a6b2ed71f0008f5aedeca0f"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxType &gt; </td></tr>
<tr class="memitem:a07b463a00a6b2ed71f0008f5aedeca0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a07b463a00a6b2ed71f0008f5aedeca0f">mutate_all_pre_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType * &gt; box) noexcept</td></tr>
<tr class="memdesc:a07b463a00a6b2ed71f0008f5aedeca0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation.  <a href="namespaceCce.html#a07b463a00a6b2ed71f0008f5aedeca0f">More...</a><br /></td></tr>
<tr class="separator:a07b463a00a6b2ed71f0008f5aedeca0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea62aa3f794b4db28493d91fa620dff0"><td class="memTemplParams" colspan="2"><a id="aea62aa3f794b4db28493d91fa620dff0"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aea62aa3f794b4db28493d91fa620dff0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aea62aa3f794b4db28493d91fa620dff0">dataset_label_for_tag</a> () noexcept</td></tr>
<tr class="memdesc:aea62aa3f794b4db28493d91fa620dff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The dataset string associated with each scalar that will be output in the reduced set of SpEC-like worldtube boundary data. <br /></td></tr>
<tr class="separator:aea62aa3f794b4db28493d91fa620dff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88dfe524596d0b75563d6847440f90f3"><td class="memItemLeft" align="right" valign="top"><a id="a88dfe524596d0b75563d6847440f90f3"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a88dfe524596d0b75563d6847440f90f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiBeta &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a88dfe524596d0b75563d6847440f90f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae883685ec4399565f0e8249ea137f28a"><td class="memItemLeft" align="right" valign="top"><a id="ae883685ec4399565f0e8249ea137f28a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae883685ec4399565f0e8249ea137f28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiU &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:ae883685ec4399565f0e8249ea137f28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memItemLeft" align="right" valign="top"><a id="a36b57bbdc7fe9c1e0922b3e51f0bfbc2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiQ &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a36b57bbdc7fe9c1e0922b3e51f0bfbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memItemLeft" align="right" valign="top"><a id="a2835060732d66cc0d7b11e2acd4f3dfa"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiW &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a2835060732d66cc0d7b11e2acd4f3dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6762043acd3580c812dbebb326f125b4"><td class="memItemLeft" align="right" valign="top"><a id="a6762043acd3580c812dbebb326f125b4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6762043acd3580c812dbebb326f125b4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiJ &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a6762043acd3580c812dbebb326f125b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3ed8eee465fac8249917d48b32dd35"><td class="memItemLeft" align="right" valign="top"><a id="a5b3ed8eee465fac8249917d48b32dd35"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5b3ed8eee465fac8249917d48b32dd35"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Dr&lt; Cce::Tags::BondiJ &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a5b3ed8eee465fac8249917d48b32dd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memItemLeft" align="right" valign="top"><a id="ae5e4cbef470d91d8ff8cefbc08dd581f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Du&lt; Cce::Tags::BondiJ &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:ae5e4cbef470d91d8ff8cefbc08dd581f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3757069588a164d737303fd1f558a74"><td class="memItemLeft" align="right" valign="top"><a id="aa3757069588a164d737303fd1f558a74"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aa3757069588a164d737303fd1f558a74"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::BondiR &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:aa3757069588a164d737303fd1f558a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memItemLeft" align="right" valign="top"><a id="a6d8b3e7858bbb3e16ea6d7aa5571b347"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dataset_label_for_tag&lt; Cce::Tags::BoundaryValue&lt; Cce::Tags::Du&lt; Cce::Tags::BondiR &gt; &gt; &gt;</b> () noexcept</td></tr>
<tr class="separator:a6d8b3e7858bbb3e16ea6d7aa5571b347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05288e45fbe503242b6abf94fc733c54"><td class="memItemLeft" align="right" valign="top"><a id="a05288e45fbe503242b6abf94fc733c54"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; inverse_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_spatial_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; radial_correction_factor, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;unit_cartesian_coords, const size_t l_max) noexcept</td></tr>
<tr class="separator:a05288e45fbe503242b6abf94fc733c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d607ef85e660da0e446437d44df58d"><td class="memItemLeft" align="right" valign="top"><a id="ae2d607ef85e660da0e446437d44df58d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_shift_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_shift, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, const size_t l_max) noexcept</td></tr>
<tr class="separator:ae2d607ef85e660da0e446437d44df58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfb968512e6c1e28b0055247329a6ba"><td class="memItemLeft" align="right" valign="top"><a id="aecfb968512e6c1e28b0055247329a6ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; dt_cartesian_lapse, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, const size_t l_max) noexcept</td></tr>
<tr class="separator:aecfb968512e6c1e28b0055247329a6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5111d1ccae8c6e4a01280a9958d6ba"><td class="memItemLeft" align="right" valign="top"><a id="aae5111d1ccae8c6e4a01280a9958d6ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes</b> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; inverse_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ijj&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::ii&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_spatial_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; radial_correction_factor, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;unit_cartesian_coords, size_t l_max) noexcept</td></tr>
<tr class="separator:aae5111d1ccae8c6e4a01280a9958d6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a46e7fb3b7ed596e8f8e89b4463e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aa6a46e7fb3b7ed596e8f8e89b4463e5b">cartesian_shift_and_derivatives_from_unnormalized_spec_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; dt_cartesian_shift, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, size_t l_max) noexcept</td></tr>
<tr class="memdesc:aa6a46e7fb3b7ed596e8f8e89b4463e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="namespaceCce.html#aa6a46e7fb3b7ed596e8f8e89b4463e5b">More...</a><br /></td></tr>
<tr class="separator:aa6a46e7fb3b7ed596e8f8e89b4463e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9764a69773e3fdee13741c95449e87b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9764a69773e3fdee13741c95449e87b1">cartesian_lapse_and_derivatives_from_unnormalized_spec_modes</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt; d_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt; dt_cartesian_lapse, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt; interpolation_modal_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt; interpolation_buffer, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt; eth_buffer, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const CartesianiSphericalJ &amp;inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;radial_derivative_correction_factor, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a9764a69773e3fdee13741c95449e87b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities.  <a href="namespaceCce.html#a9764a69773e3fdee13741c95449e87b1">More...</a><br /></td></tr>
<tr class="separator:a9764a69773e3fdee13741c95449e87b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452af512f570222ce58fdb7bd0d384b7"><td class="memTemplParams" colspan="2">template&lt;typename TagList &gt; </td></tr>
<tr class="memitem:a452af512f570222ce58fdb7bd0d384b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a452af512f570222ce58fdb7bd0d384b7">create_bondi_boundary_data_from_unnormalized_spec_modes</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; TagList &gt; * &gt; bondi_boundary_data, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_spatial_metric_coefficients, const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_spatial_metric_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dt_shift_coefficients, const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;dr_shift_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dt_lapse_coefficients, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;dr_lapse_coefficients, const double extraction_radius, const size_t l_max) noexcept</td></tr>
<tr class="memdesc:a452af512f570222ce58fdb7bd0d384b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process the worldtube data from modal metric components and derivatives with incorrectly normalized radial derivatives from an old version of SpEC to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>.  <a href="namespaceCce.html#a452af512f570222ce58fdb7bd0d384b7">More...</a><br /></td></tr>
<tr class="separator:a452af512f570222ce58fdb7bd0d384b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806d20a6c6a5298c89f6335eaa461105"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:a806d20a6c6a5298c89f6335eaa461105"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a806d20a6c6a5298c89f6335eaa461105">mutate_all_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DataBoxTagList &gt; * &gt; box) noexcept</td></tr>
<tr class="memdesc:a806d20a6c6a5298c89f6335eaa461105"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives.  <a href="namespaceCce.html#a806d20a6c6a5298c89f6335eaa461105">More...</a><br /></td></tr>
<tr class="separator:a806d20a6c6a5298c89f6335eaa461105"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The set of utilities for performing Cauchy characteristic evolution and Cauchy characteristic matching. </p>
<h3>Details</h3>
<p>Cauchy characteristic evolution (CCE) is a secondary nonlinear GR evolution system that covers the domain extending from a spherical boundary away from the strong-field regime, and extending all the way to future null infinity \(\mathcal I^+\). The evolution system is governed by five hypersurface equations that are integrated radially along future null slices, and one evolution equation that governs the evolution of one hypersurface to the next.</p>
<p>The mathematics of CCE are intricate, and SpECTRE's version implements a number of tricks and improvements that are not yet present in other contexts. For introductions to CCE generally, see papers <a class="el" href="citelist.html#CITEREF_Bishop1997ik">[10]</a>, <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a>, and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>. Here we do not present a full description of all of the mathematics, but instead just provide a high-level roadmap of the SpECTRE utilities and how they come together in the CCE system. This is intended as a map for maintainers of the codebase.</p>
<p>First, worldtube data from a completed or running Cauchy evolution of the Einstein field equations (currently the only one implemented in SpECTRE is Generalized Harmonic) must be translated to Bondi spin-weighted scalars at the extraction sphere. Relevant utilities for this conversion are <code><a class="el" href="classCce_1_1WorldtubeDataManager.html" title="Abstract base class for managers of CCE worldtube data that is provided in large time-series chunks,...">Cce::WorldtubeDataManager</a></code>, <code>Cce::ReducedWorldtubeDataManager</code>, <code><a class="el" href="namespaceCce.html#a63fcb28e3a34d986808172243ae7737b" title="Process the worldtube data from generalized harmonic quantities to desired Bondi quantities,...">Cce::create_bondi_boundary_data</a></code>. Relevant parts of the parallel infrastructure are <code><a class="el" href="structCce_1_1H5WorldtubeBoundary.html" title="Component that supplies CCE worldtube boundary data.">Cce::H5WorldtubeBoundary</a></code>, <code><a class="el" href="structCce_1_1Actions_1_1BoundaryComputeAndSendToEvolution.html" title="Obtains the CCE boundary data at the specified time, and reports it to the EvolutionComponent via Act...">Cce::Actions::BoundaryComputeAndSendToEvolution</a></code>, <code><a class="el" href="structCce_1_1Actions_1_1RequestBoundaryData.html" title="Requests boundary data be sent from WorldtubeBoundaryComponent to EvolutionComponent (template parame...">Cce::Actions::RequestBoundaryData</a></code>, and <code><a class="el" href="structCce_1_1Actions_1_1ReceiveWorldtubeData.html" title="Takes the boundary data needed to perform the CCE linear solves as arguments and puts them in the Dat...">Cce::Actions::ReceiveWorldtubeData</a></code>.</p>
<p>The first hypersurface must be initialized with some reasonable starting value for the evolved Bondi quantity \(J\). There isn't a universal perfect prescription for this, as a complete description would require, like the Cauchy initial data problem, knowledge of the system arbitrarily far in the past. A utility for assigning the initial data is <code><a class="el" href="namespaceCce_1_1InitializeJ.html" title="Contains utilities and DataBox mutators for generating data for  on the initial CCE hypersurface.">Cce::InitializeJ</a></code>.</p>
<p>SpECTRE CCE is currently unique in implementing an additional gauge transform after the worldtube boundary data is derived. This is performed to obtain an asymptotically well-behaved gauge that is guaranteed to avoid logarithmic behavior that has plagued other CCE implementations, and so that the asymptotic computations can be as simple, fast, and reliable as possible. Relevant utilities for the gauge transformation are <code><a class="el" href="structCce_1_1GaugeAdjustedBoundaryValue.html" title="Computes the gauge-transformed Tags::EvolutionGaugeBoundaryValue&lt;Tag&gt; for any of the boundary tags ne...">Cce::GaugeAdjustedBoundaryValue</a></code> (see template specializations), <code><a class="el" href="structCce_1_1GaugeUpdateTimeDerivatives.html" title="Update the Cauchy gauge cartesian coordinate derivative , as well as remaining gauge quantities ,...">Cce::GaugeUpdateTimeDerivatives</a></code>, <code><a class="el" href="structCce_1_1GaugeUpdateAngularFromCartesian.html" title="Update the angular coordinates stored in AngularTag via trigonometric operations applied to the Carte...">Cce::GaugeUpdateAngularFromCartesian</a></code>, <code><a class="el" href="structCce_1_1GaugeUpdateJacobianFromCoordinates.html" title="From the angular coordinates AngularCoordinateTag and the Cartesian coordinates CartesianCoordinateTa...">Cce::GaugeUpdateJacobianFromCoordinates</a></code>, <code><a class="el" href="structCce_1_1GaugeUpdateInterpolator.html" title="Update the interpolator stored in Spectral::Swsh::Tags::SwshInterpolator&lt;AngularCoordinates&gt;.">Cce::GaugeUpdateInterpolator</a></code>, <code><a class="el" href="structCce_1_1GaugeUpdateOmega.html" title="Update the quantity  and  for updated spin-weighted Jacobian quantities  and .">Cce::GaugeUpdateOmega</a></code>, and <code><a class="el" href="structCce_1_1InitializeGauge.html" title="Initialize to default values (identity transform) all of the angular gauge quantities for the boundar...">Cce::InitializeGauge</a></code>.</p>
<p>Next, the CCE system must evaluate the hypersurface differential equations. There are five, in sequence, deriving \(\beta, Q, U, W,\) and \(H\). For each of the five radial differential equations, first the products and derivatives on the right-hand side must be evaluated, then the full right-hand side of the equation must be computed, and finally the radial differential equation is integrated. The equations have a hierarchical structure, so the result for \(\beta\) feeds into the radial differential equation for \(Q\), and both feed into \(U\), and so on.</p>
<p>Relevant utilities for computing the inputs to the hypersurface equations are <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">Cce::PrecomputeCceDependencies</a></code> (see template specializations), <code><a class="el" href="namespaceCce.html#a91a84b3c3c233bceb58f2cac20716f66" title="Convenience routine for computing all of the CCE inputs to integrand computation that do not depend o...">Cce::mutate_all_precompute_cce_dependencies</a></code>, <code><a class="el" href="structCce_1_1PreSwshDerivatives.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that are to be ...">Cce::PreSwshDerivatives</a></code> (see template specializations), <code><a class="el" href="namespaceCce.html#a07b463a00a6b2ed71f0008f5aedeca0f" title="Evaluates the set of inputs to the CCE integrand for BondiValueTag that do not involve spin-weighted ...">Cce::mutate_all_pre_swsh_derivatives_for_tag</a></code>, and <code><a class="el" href="namespaceCce.html#a806d20a6c6a5298c89f6335eaa461105" title="This routine evaluates the set of inputs to the CCE integrand for BondiValueTag which are spin-weight...">Cce::mutate_all_swsh_derivatives_for_tag</a></code>. There are a number of typelists in <code><a class="el" href="IntegrandInputSteps_8hpp_source.html">IntegrandInputSteps.hpp</a></code> that determine the set of quantities to be evaluated in each of the five hypersurface steps. Once the hypersurface equation inputs are computed, then a hypersurface equation right-hand side can be evaluated via <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.">Cce::ComputeBondiIntegrand</a></code> (see template specializations). Then, the hypersurface equation may be integrated via <code><a class="el" href="structCce_1_1RadialIntegrateBondi.html" title="Computational structs for evaluating the hypersurface integrals during CCE evolution....">Cce::RadialIntegrateBondi</a></code> (see template specializations).</p>
<p>Relevant parts of the parallel infrastructure for performing the hypersurface steps are: <code><a class="el" href="structCce_1_1CharacteristicEvolution.html" title="The component for handling the CCE evolution and waveform output.">Cce::CharacteristicEvolution</a></code>, <code><a class="el" href="structCce_1_1Actions_1_1CalculateIntegrandInputsForTag.html" title="Prepare the input quantities in the DataBox for the evaluation of the hypersurface integral used to c...">Cce::Actions::CalculateIntegrandInputsForTag</a></code>, and <code><a class="el" href="structCce_1_1Actions_1_1PrecomputeGlobalCceDependencies.html" title="Perform all of the computations for dependencies of the hypersurface equations that do not themselves...">Cce::Actions::PrecomputeGlobalCceDependencies</a></code>. Note that most of the algorithmic steps are laid out in order in the phase-dependent action list of <code><a class="el" href="structCce_1_1CharacteristicEvolution.html" title="The component for handling the CCE evolution and waveform output.">Cce::CharacteristicEvolution</a></code>.</p>
<p>The time integration for the hyperbolic part of the CCE equations is performed via \(\partial_u J = H\), where \(\partial_u\) represents differentiation with respect to retarded time at fixed numerical radius \(y\).</p>
<p>At this point, all of the Bondi quantities on a given hypersurface have been evaluated, and we wish to output the relevant waveform quantities at \(\mathcal I^+\). This acts much like an additional step in the hypersurface sequence, with inputs that need to be calculated before the quantities of interest can be evaluated. The action <code><a class="el" href="structCce_1_1Actions_1_1CalculateScriInputs.html" title="Calculates the Bondi quantities that are required for any of the CalculateScriPlusValue mutators.">Cce::Actions::CalculateScriInputs</a></code> performs the sequence of steps to obtain those inputs, and the utilities <code><a class="el" href="structCce_1_1CalculateScriPlusValue.html">Cce::CalculateScriPlusValue</a></code> (see template specializations) can be used to evaluate the desired outputs at \(\mathcal I^+\).</p>
<p>Unfortunately, those quantities at \(\mathcal I^+\) are not yet an appropriate waveform output, because the time coordinate with which they are evaluated is the simulation time, not an asymptotically inertial time. So, instead of directly writing the waveform outputs, we must put them in a queue to be interpolated once enough data points have been accumulated to perform a reliable interpolation at a consistent cut of \(\mathcal I^+\) at constant inertial time. Utilities for calculating and evolving the asymptotic inertial time are <code><a class="el" href="structCce_1_1InitializeScriPlusValue.html" title="Initialize the  value Tag for the first hypersurface.">Cce::InitializeScriPlusValue</a></code> and <code><a class="el" href="structCce_1_1CalculateScriPlusValue.html">Cce::CalculateScriPlusValue</a></code> using arguments involving <code><a class="el" href="structCce_1_1Tags_1_1InertialRetardedTime.html" title="The asymptotically inertial retarded time in terms of the evolution time variable.">Cce::Tags::InertialRetardedTime</a></code>. A utility for managing the interpolation is <code><a class="el" href="structCce_1_1ScriPlusInterpolationManager.html" title="Stores necessary data and interpolates on to new time points at scri+.">Cce::ScriPlusInterpolationManager</a></code>, and relevant parts of the parallel infrastructure for manipulating the data into the interpolator and writing the results to disk are <code><a class="el" href="structCce_1_1Actions_1_1InsertInterpolationScriData.html" title="Places the data from the current hypersurface necessary to compute Tag in the ScriPlusInterpolationMa...">Cce::Actions::InsertInterpolationScriData</a></code> and <code><a class="el" href="structCce_1_1Actions_1_1ScriObserveInterpolated.html" title="Checks the interpolation managers and if they are ready, performs the interpolation and sends the dat...">Cce::Actions::ScriObserveInterpolated</a></code>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7dd34947472e61d70007727517310500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd34947472e61d70007727517310500">&#9670;&nbsp;</a></span>all_pre_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500">Cce::all_pre_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, detail::additional_pre_swsh_derivative_tags_for&lt;tmpl::_1&gt; &gt;&gt;, <a class="el" href="namespaceCce.html#adf0ceab2533f417cc55b2430cd136046">all_pre_swsh_derivative_tags_for_scri</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="ad8c937a1e34a4865805c5680f8f7872d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c937a1e34a4865805c5680f8f7872d">&#9670;&nbsp;</a></span>all_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d">Cce::all_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::list&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt;tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt; &gt;&gt;, <a class="el" href="namespaceCce.html#a4911f02776875e5d7fbb3d6f66ef5a55">all_swsh_derivative_tags_for_scri</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags (for a given integrated Bondi quantity) may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_swsh_derivatives_for_tag</code>. Individual tag computation is not provided in a convenient interface, as there is significant savings in aggregating spin-weighted differentiation steps. The full set of integrated Bondi quantities is available from the typelist <code>bondi_hypersurface_step_tags</code>. </p>

</div>
</div>
<a id="a9cbd52ad55ee87beb6abf5857c2db60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd52ad55ee87beb6abf5857c2db60a">&#9670;&nbsp;</a></span>all_transform_buffer_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">Cce::all_transform_buffer_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d">all_swsh_derivative_tags</a>, tmpl::bind&lt;<a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::size_of_libsharp_coefficient_vector(l_max)</code>. Providing buffers associated with these tags is necessary for the use of the aggregated computation <code>mutate_all_swsh_derivatives_for_tag</code>. </p>

</div>
</div>
<a id="a6aa380f6f1dc1109be44f9ddbac98652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa380f6f1dc1109be44f9ddbac98652">&#9670;&nbsp;</a></span>bondi_hypersurface_step_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">Cce::bondi_hypersurface_step_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="namespaceCce_1_1Tags.html#a1987e592fa6f5a8aafaa0273b4e94505">Tags::BondiH</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set of Bondi quantities computed by hypersurface step, in the required order of computation </p>

</div>
</div>
<a id="a393d5c196acb92779ba89acbc1fa686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5c196acb92779ba89acbc1fa686e">&#9670;&nbsp;</a></span>integrand_temporary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">Cce::integrand_temporary_tags</a> = typedef typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt;Tag&gt;::temporary_tags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Metafunction that is a <code>tmpl::list</code> of the temporary tags taken by the <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.">ComputeBondiIntegrand</a></code> computational struct. </p>

</div>
</div>
<a id="aa00307a414eb1f569706cb7d7449fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00307a414eb1f569706cb7d7449fa4d">&#9670;&nbsp;</a></span>pre_computation_boundary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">Cce::pre_computation_boundary_tags</a> = typedef tmpl::list&lt;BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;, BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities necessary for a CCE computation or portion thereof. A container of these tags should have size <code>Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="a7a4a1a7fe54a9f77fbf034fb95f46474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4a1a7fe54a9f77fbf034fb95f46474">&#9670;&nbsp;</a></span>pre_computation_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474">Cce::pre_computation_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_precompute_cce_dependencies</code> or individually using the template specializations <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>.</p>
<dl class="section note"><dt>Note</dt><dd>the tag <code><a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html" title="The value , where  is Bondi radius of the worldtube.">Tags::DuRDividedByR</a></code> is omitted from this list because in the case where a gauge transformation must be applied, the time derivative quantities must wait until later in the computation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb6fb09ea34d9ca7e9095e873d85dbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6fb09ea34d9ca7e9095e873d85dbe3">&#9670;&nbsp;</a></span>beta_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::beta_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(\beta\) (lapse) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{u r} = - e^{2 \beta}\), and the value of \(\beta\) is obtained from the intermediate null metric by (see equation (51) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>) using:</p>
<p class="formulaDsp">
\[ \beta = -\frac{1}{2} \ln \partial_{\lambda} r \]
</p>
 
</div>
</div>
<a id="a6def3d12e2e4937975dbe417640d4159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6def3d12e2e4937975dbe417640d4159">&#9670;&nbsp;</a></span>bondi_h_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_h_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \((\partial_u J)_{y} \equiv H\) (the retarded time derivative evaluated at fixed $y$ coordinate) on the worldtube boundary. </p>
<h3>Details</h3>
<p>The numerical time derivative (along the worldtube, rather than along the surface of constant Bondi \(r\)) is computed by (see equation (48) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>)</p>
<p class="formulaDsp">
\[ (\partial_u J)_y = \frac{1}{2 r^2} q^A q^B \partial_u g_{A B} - \frac{2 \partial_u r}{r} J \]
</p>
<dl class="section note"><dt>Note</dt><dd>There is the regrettable notation difference with the primary reference for these formulas <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> in that we denote with \(H\) the time derivative at constant numerical radius, where <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> uses \(H\) to denote the time derivative at constant Bondi radius. </dd></dl>

</div>
</div>
<a id="a31a8fc67e25101bfb7ac540af4ad1b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a8fc67e25101bfb7ac540af4ad1b51">&#9670;&nbsp;</a></span>bondi_j_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_j_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(J\) (intuitively similar to the transverse-traceless part of the angular metric) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(J = \frac{1}{2 r^2} q^A q^B g_{A B}\). This expression holds both for the right-hand side in the Bondi coordinates and for the right-hand side in the intermediate null coordinates (see equation (45) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>). </p>

</div>
</div>
<a id="a9ce844948054444e8eaf3f962da770a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce844948054444e8eaf3f962da770a4">&#9670;&nbsp;</a></span>bondi_q_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_q_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>dr_bondi_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d2lambda_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>angular_d_dlambda_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \(Q\) (radial derivative of shift). </p>
<h3>Details</h3>
<p>The definition of \(Q\) in terms of the Bondi metric components is</p>
<p class="formulaDsp">
\[ Q = q^A e^{-2 \beta} g_{A B} \partial_r U^B. \]
</p>
<p>$Q$ can be derived from the intermediate null metric quantities via (see equations (56) and (57) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>)</p>
<p class="formulaDsp">
\[ \partial_\lambda U = - \left(\partial_\lambda g^{\lambda A} + \frac{\partial_A \partial_\lambda r}{\partial_\lambda r} g^{A B} + \frac{\partial_B r}{\partial_\lambda r} \partial_\lambda g^{A B}\right) q_A + 2 \partial_\lambda \beta (U + g^{\lambda A} q_A) \]
</p>
<p>and</p>
<p class="formulaDsp">
\[ Q = r^2 (J \partial_\lambda \bar U + K \partial_\lambda U) \]
</p>
<p>also provided is \(\partial_r U\), which is separately useful to cache for other intermediate steps in the CCE computation. </p>

</div>
</div>
<a id="a3d58c5d828563b7be381f2ef4358c24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d58c5d828563b7be381f2ef4358c24e">&#9670;&nbsp;</a></span>bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Bondi radius of the worldtube. </p>
<h3>Details</h3>
<p>Note that unlike the Cauchy coordinate radius, the Bondi radius is not constant over the worldtube. Instead, it is obtained by the determinant of the angular part of the metric in the intermediate null coordinates (see <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>).</p>
<p class="formulaDsp">
\[ r = \left(\frac{\det g_{A B}}{ q_{A B}}\right)^{1/4}, \]
</p>
<p>where \(q_{A B}\) is the unit sphere metric. </p>

</div>
</div>
<a id="aadca2284f5bc7c2cbfbd6edb09198d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadca2284f5bc7c2cbfbd6edb09198d3f">&#9670;&nbsp;</a></span>bondi_u_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_u_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(U\) (shift) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{r A} = -e^{-2 \beta} U^A\), and the spin-weighted vector \(U = U^A q_A\). The value of \(U^A\) can be computed from the intermediate null metric quantities (see equation (54) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>) using:</p>
<p class="formulaDsp">
\[ U = -(\partial_\lambda r g^{\lambda A} + \partial_B r g^{A B}) q_A / \partial_\lambda r \]
</p>
 
</div>
</div>
<a id="a44787f40e187fcf6c875424df8e10624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44787f40e187fcf6c875424df8e10624">&#9670;&nbsp;</a></span>bondi_w_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::bondi_w_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the \(W\) (mass aspect) function for the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The Bondi-like metric has \(g^{rr} = e^{-2 \beta}(1 + r W)\). The value of \(W\) can be computed from the null metric quantities (see equation (55) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>) using:</p>
<p class="formulaDsp">
\[ W = \frac{1}{r} \left(-1 + \frac{g^{\lambda \lambda} (\partial_\lambda r)^2 + 2 \partial_\lambda r \left(\partial_A r g^{\lambda A} - \partial_u r\right) + \partial_A r \partial_B r g^{A B}} {\partial_\lambda r}\right) \]
</p>
 
</div>
</div>
<a id="a7d1da9eb6a9e2d127eaf95c1ab3f7b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1da9eb6a9e2d127eaf95c1ab3f7b03">&#9670;&nbsp;</a></span>cartesian_lapse_and_derivatives_from_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_lapse_and_derivatives_from_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function interpolates the modes of input \(\alpha\), \(\partial_r \alpha\), and \(\partial_r \alpha\) to the libsharp-compatible grid. This function then applies the necessary jacobian factors and angular derivatives to determine the full \(\partial_i \alpha\). </p>

</div>
</div>
<a id="a9764a69773e3fdee13741c95449e87b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9764a69773e3fdee13741c95449e87b1">&#9670;&nbsp;</a></span>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_lapse_and_derivatives_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_derivative_correction_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\alpha\), \(\partial_i \alpha\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function will apply a correction factor associated with a SpEC bug. </p>

</div>
</div>
<a id="a051bc858cc4a2d582968c38c7d2d7b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051bc858cc4a2d582968c38c7d2d7b44">&#9670;&nbsp;</a></span>cartesian_shift_and_derivatives_from_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_shift_and_derivatives_from_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function interpolates the modes of input \(\beta^i\), \(\partial_r \beta^i\), and \(\partial_r \beta^i\) to the libsharp-compatible grid. This function then applies the necessary jacobian factors and angular derivatives to determine the full \(\partial_i \beta^i\). </p>

</div>
</div>
<a id="aa6a46e7fb3b7ed596e8f8e89b4463e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a46e7fb3b7ed596e8f8e89b4463e5b">&#9670;&nbsp;</a></span>cartesian_shift_and_derivatives_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_shift_and_derivatives_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::iJ&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_cartesian_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_modal_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>interpolation_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 1 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>eth_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CartesianiSphericalJ &amp;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_derivative_correction_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute \(\beta^{i}\), \(\partial_i \beta^{j}\), and \(\partial_t \beta^i\) from input libsharp-compatible modal spatial metric quantities. </p>
<h3>Details</h3>
<p>This function will apply a correction factor associated with a SpEC bug. </p>

</div>
</div>
<a id="abf5ea199fec6321ecfaef02e23913def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5ea199fec6321ecfaef02e23913def">&#9670;&nbsp;</a></span>cartesian_to_spherical_coordinates_and_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_to_spherical_coordinates_and_jacobians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>unit_cartesian_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; SphericaliCartesianJ * &gt;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; CartesianiSphericalJ * &gt;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves. </p>
<h3>Details</h3>
<p>The <code>cartesian_to_spherical_jacobian</code> is \(dx^i/d\tilde{x}^{\tilde j}\), where the Cartesian components are in order \(x^i = \{x, y, z\}\) and the spherical coordinates are \(\tilde{x}^{\tilde j} = \{r, \theta, \phi\}\). The Cartesian coordinates given are the standard unit sphere coordinates:</p>
<p class="formulaDsp">
\begin{align*} x &amp;= \cos(\phi) \sin(\theta)\\ y &amp;= \sin(\phi) \sin(\theta)\\ z &amp;= \cos(\theta) \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>These Jacobians are adjusted to improve regularity near the pole, in particular the \(\partial \phi / \partial x^i\) components have been scaled by \(\sin \theta\) (omitting a \(1/\sin(\theta)\)) and the \(\partial x^i/\partial \phi\) components have been scaled by \(1/\sin(\theta)\) (omitting a \(\sin(\theta)\)). The reason is that in most careful calculations, these problematic sin factors can actually be omitted because they cancel. In cases where they are actually required, they must be put in by hand. </dd></dl>

</div>
</div>
<a id="a63fcb28e3a34d986808172243ae7737b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fcb28e3a34d986808172243ae7737b">&#9670;&nbsp;</a></span>create_bondi_boundary_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoundaryTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; BoundaryTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>pi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from generalized harmonic quantities to desired Bondi quantities, placing the result in the passed <code>Variables</code>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code>BoundaryData.hpp</code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a>.</p>
<p>This function takes as input the full set of Generalized harmonic metric data on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <code>Variables</code> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gac067e03fcb04c8c6c45d9708539a56b0" title="Compute shift from spacetime metric and inverse spatial metric.">gr::shift()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga2b741dbe71bd10a06f0d71f18782b612" title="Compute lapse from shift and spacetime metric.">gr::lapse()</a></code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gad898b94c1b7d4462defb6362bf36d1ee" title="Computes spacetime normal vector from lapse and shift.">gr::spacetime_normal_vector()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga2e08910da2c5968b217f1c6cc8170e30" title="Computes time derivative of lapse (N) from the generalized harmonic variables, lapse,...">GeneralizedHarmonic::time_deriv_of_lapse()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga04ff22b0304dafb6a879d9d1998f3a12" title="Computes time derivative of the shift vector from the generalized harmonic and geometric variables.">GeneralizedHarmonic::time_deriv_of_shift()</a></code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="a918a7d65e199495fd2542a9c0cb4536c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918a7d65e199495fd2542a9c0cb4536c">&#9670;&nbsp;</a></span>create_bondi_boundary_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoundaryTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; BoundaryTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from modal metric components and derivatives to desired Bondi quantities, placing the result in the passed <code>Variables</code>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code>BoundaryData.hpp</code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a>.</p>
<p>This function takes as input the full set of ADM metric data and its radial and time derivatives on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates. This data must be provided as spherical harmonic coefficients in the libsharp format. This data is provided in nine <code>Tensor</code>s.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <code>Variables</code> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>cartesian_spatial_metric_and_derivatives_from_modes()</code></li>
<li><code>cartesian_shift_and_derivatives_from_modes()</code></li>
<li><code>cartesian_lapse_and_derivatives_from_modes()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gaecccadb6658f3735cfb7344c780abd97" title="Computes the auxiliary variable  used by the generalized harmonic formulation of Einstein&#39;s equations...">GeneralizedHarmonic::phi()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga93422dbab4e77602a25ed63784af13b4" title="Computes the time derivative of the spacetime metric from spatial metric, lapse, shift,...">gr::time_derivative_of_spacetime_metric</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gaf691cdef10c2fdc735947e5e7190b529" title="Computes the spacetime metric from the spatial metric, lapse, and shift.">gr::spacetime_metric</a></code></li>
<li><code>generalized_harmonic_quantities()</code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="a452af512f570222ce58fdb7bd0d384b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452af512f570222ce58fdb7bd0d384b7">&#9670;&nbsp;</a></span>create_bondi_boundary_data_from_unnormalized_spec_modes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::create_bondi_boundary_data_from_unnormalized_spec_modes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; Variables&lt; TagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>bondi_boundary_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_spatial_metric_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_shift_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classComplexModalVector.html">ComplexModalVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_lapse_coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Process the worldtube data from modal metric components and derivatives with incorrectly normalized radial derivatives from an old version of SpEC to desired Bondi quantities, placing the result in the passed <a class="el" href="group__DataBoxGroup.html">DataBox</a>. </p>
<h3>Details</h3>
<p>The mathematics are a bit complicated for all of the coordinate transformations that are necessary to obtain the Bondi gauge quantities. For full mathematical details, see the documentation for functions in <code>BoundaryData.hpp</code> and <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a>.</p>
<p>This function takes as input the full set of ADM metric data and its radial and time derivatives on a two-dimensional surface of constant \(r\) and \(t\) in numerical coordinates. This data must be provided as spherical harmonic coefficients in the libsharp format. This data is provided in nine <code>Tensor</code>s.</p>
<p>Sufficient tags to provide full worldtube boundary data at a particular time are set in <code>bondi_boundary_data</code>. In particular, the set of tags in <code><a class="el" href="namespaceCce_1_1Tags.html#a7527c94f3bb08dd4124926b9ff41ebac" title="The collection of tags mutated by create_bondi_boundary_data">Tags::characteristic_worldtube_boundary_tags</a></code> in the provided <a class="el" href="group__DataBoxGroup.html">DataBox</a> are assigned to the worldtube boundary values associated with the input metric components.</p>
<p>The majority of the mathematical transformations are implemented as a set of individual cascaded functions below. The details of the manipulations that are performed to the input data may be found in the individual functions themselves, which are called in the following order:</p><ul>
<li><code>trigonometric_functions_on_swsh_collocation()</code></li>
<li><code>cartesian_to_spherical_coordinates_and_jacobians()</code></li>
<li><code>cartesian_spatial_metric_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code>cartesian_shift_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code>cartesian_lapse_and_derivatives_from_unnormalized_spec_modes()</code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gaecccadb6658f3735cfb7344c780abd97" title="Computes the auxiliary variable  used by the generalized harmonic formulation of Einstein&#39;s equations...">GeneralizedHarmonic::phi()</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#ga93422dbab4e77602a25ed63784af13b4" title="Computes the time derivative of the spacetime metric from spatial metric, lapse, shift,...">gr::time_derivative_of_spacetime_metric</a></code></li>
<li><code><a class="el" href="group__GeneralRelativityGroup.html#gaf691cdef10c2fdc735947e5e7190b529" title="Computes the spacetime metric from the spatial metric, lapse, and shift.">gr::spacetime_metric</a></code></li>
<li><code>generalized_harmonic_quantities()</code></li>
<li><code>worldtube_normal_and_derivatives()</code></li>
<li><code>null_vector_l_and_derivatives()</code></li>
<li><code>null_metric_and_derivative()</code></li>
<li><code>dlambda_null_metric_and_inverse()</code></li>
<li><code>bondi_r()</code></li>
<li><code>d_bondi_r()</code></li>
<li><code>dyads()</code></li>
<li><code>beta_worldtube_data()</code></li>
<li><code>bondi_u_worldtube_data()</code></li>
<li><code>bondi_w_worldtube_data()</code></li>
<li><code>bondi_j_worldtube_data()</code></li>
<li><code>dr_bondi_j()</code></li>
<li><code>d2lambda_bondi_r()</code></li>
<li><code>bondi_q_worldtube_data()</code></li>
<li><code>bondi_h_worldtube_data()</code></li>
<li><code>du_j_worldtube_data()</code> </li>
</ul>

</div>
</div>
<a id="ab2d7cd96510ef0162f8ed24c40962248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d7cd96510ef0162f8ed24c40962248">&#9670;&nbsp;</a></span>d2lambda_bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::d2lambda_bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d2lambda_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>dr_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the second derivative of the Bondi radius with respect to the intermediate null coordinate radius \(\partial_\lambda^2 r\). </p>
<h3>Details</h3>
<p>To determine this second derivative quantity without resorting to depending on second-derivative metric inputs, we need to take advantage of one of the Einstein field equations. Combining equations (53) and (52) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>, we have:</p>
<p class="formulaDsp">
\[ \partial_\lambda^2 r = \frac{-r}{4} \left( \partial_\lambda J \partial_\lambda \bar J - (\partial_\lambda K)^2\right) \]
</p>
<p>,</p>
<p>where the first derivative of \(K\) can be obtained from \(K = \sqrt{1 + J \bar J}\) and the first derivative of \(J\) can be obtained from (47) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> </p>

</div>
</div>
<a id="aded277b1cb65d5c34a0a55b4bd2f6b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded277b1cb65d5c34a0a55b4bd2f6b34">&#9670;&nbsp;</a></span>d_bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::d_bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates. </p>
<h3>Details</h3>
<p>The expression evaluated is obtained from differentiating the determinant equation for <code>bondi_r</code>, from (35) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> :</p>
<p class="formulaDsp">
\[ \partial_\alpha r = \frac{r}{4} \left(g^{A B} \partial_\alpha g_{A B} - \frac{\partial_\alpha \det q_{A B}}{\det q_{A B}}\right) \]
</p>
<p>Note that for the angular derivatives, we just numerically differentiate using the utilities in <code><a class="el" href="group__SpectralGroup.html#gaf2ce39b6bffcf7b2bbd66ac09f7e78b3" title="Evaluate the spin-weighted derivative DerivKind on the provided SpinWeighted&lt;ComplexDataVector,...">Spectral::Swsh::angular_derivative()</a></code>. For the time and radial derivatives, the second term in the above equation vanishes. </p>

</div>
</div>
<a id="a346aed34f7eac2b1cf1c7ec1cc77b2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a346aed34f7eac2b1cf1c7ec1cc77b2c8">&#9670;&nbsp;</a></span>dlambda_null_metric_and_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dlambda_null_metric_and_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dlambda_inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AngulariCartesianA &amp;&#160;</td>
          <td class="paramname"><em>angular_d_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphericaliCartesianJ &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\). </p>
<h3>Details</h3>
<p>For full expressions of the \(l^\mu \partial_\mu g_{a b}\) and \(l^\mu \partial_\mu g^{a b}\) computed in this function, see equation (31) and (32) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="a03ae659867e50f28936e38a46b2d576d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ae659867e50f28936e38a46b2d576d">&#9670;&nbsp;</a></span>dr_bondi_j()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dr_bondi_j </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>dr_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>denominator_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the radial derivative of the angular metric spin-weighted scalar \(\partial_r J\) in the CCE Bondi-like metric. </p>
<h3>Details</h3>
<p>The radial derivative of the angular spin-weighted scalar \(J\) can be computed from the null metric components by (c.f. equation (47) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>):</p>
<p class="formulaDsp">
\[ \partial_r J = \frac{\partial_\lambda J}{\partial_\lambda r} = \frac{q^A q^B \partial_\lambda g_{A B} / (2 r^2) - 2 \partial_\lambda r J / r}{\partial_\lambda r} \]
</p>
 
</div>
</div>
<a id="a7da095a13b8076ad9c705507a73bcbb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da095a13b8076ad9c705507a73bcbb5">&#9670;&nbsp;</a></span>du_j_worldtube_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::du_j_worldtube_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>du_bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the Bondi metric contribution \((\partial_u J)_r\) (the retarded time derivative at fixed coordinate $r$) on the worldtube boundary. </p>
<h3>Details</h3>
<p>The numerical time derivative (along the surface of constant r, not along the worldtube) is computed by (see equation (50) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>)</p>
<p class="formulaDsp">
\[ \partial_u J = \frac{1}{2 r^2} q^A q^B \left(\partial_u g_{A B} - \frac{ \partial_u r}{ \partial_\lambda r} \partial_\lambda g_{A B}\right) \]
</p>
<dl class="section note"><dt>Note</dt><dd>There is the regrettable notation difference with the primary reference for these formulas <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> in that we denote with \(H\) the time derivative at constant numerical radius, where <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> uses \(H\) to denote the time derivative at constant Bondi radius. </dd></dl>

</div>
</div>
<a id="a9857365c0887c3233aff0ced1b96e738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9857365c0887c3233aff0ced1b96e738">&#9670;&nbsp;</a></span>dyads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dyads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>down_dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>up_dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system. </p>
<h3>Details</h3>
<p>We use the typically chosen angular dyads in CCE <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> <a class="el" href="citelist.html#CITEREF_Bishop1997ik">[10]</a> :</p>
<p class="formulaDsp">
\begin{align*} q_A &amp;= \{-1, -i \sin(\theta)\}\\ q^A &amp;= \left\{-1, -i \frac{1}{\sin \theta}\right\} \end{align*}
</p>
<p>However, to maintain regularity and for compatibility with the more regular Jacobians from <code>Cce::cartesian_to_spherical_coordinates_and_jacobians()</code>, in the code we omit the factors of \(\sin \theta\) from the above equations. </p>

</div>
</div>
<a id="a9226695b7ca3a785963b8712b9c1b303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9226695b7ca3a785963b8712b9c1b303">&#9670;&nbsp;</a></span>logical_partial_directional_derivative_of_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::logical_partial_directional_derivative_of_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>d_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension_to_differentiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is placed in <a class="el" href="namespaceCce.html" title="The set of utilities for performing Cauchy characteristic evolution and Cauchy characteristic matchin...">Cce</a> Utilities for its currently narrow use-case. If more general uses desire a single partial derivative of complex values, this should be moved to <code>NumericalAlgorithms</code>. This utility currently assumes the spatial dimensionality is 3, which would also need to be generalized, likely by creating a wrapping struct with partial template specializations. </dd></dl>

</div>
</div>
<a id="a07b463a00a6b2ed71f0008f5aedeca0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b463a00a6b2ed71f0008f5aedeca0f">&#9670;&nbsp;</a></span>mutate_all_pre_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_pre_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation. </p>
<h3>Details</h3>
<p>This function is to be called on the <code>DataBox</code> holding the relevant CCE data on each hypersurface integration step, prior to evaluating the spin-weighted derivatives needed for the same CCE integrand. Provided a <code>DataBox</code> with the appropriate tags (including <code>all_pre_swsh_derivative_tags</code>, <code>all_swsh_derivative_tags</code> and <code><a class="el" href="structCce_1_1Tags_1_1LMax.html">Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code>all_pre_swsh_derivatives_for_tag&lt;BondiValueTag&gt;</code> to their correct values for the current values for the remaining (input) tags. </p>

</div>
</div>
<a id="a91a84b3c3c233bceb58f2cac20716f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a84b3c3c233bceb58f2cac20716f66">&#9670;&nbsp;</a></span>mutate_all_precompute_cce_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_precompute_cce_dependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands. </p>
<h3>Details</h3>
<p>Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d" title="A typelist for the set of BoundaryValue tags needed as an input to any of the template specialization...">Cce::pre_computation_boundary_tags</a></code>, <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, <code><a class="el" href="structCce_1_1Tags_1_1BondiJ.html" title="Bondi parameter .">Cce::Tags::BondiJ</a></code> and <code><a class="el" href="structCce_1_1Tags_1_1LMax.html">Tags::LMax</a></code>), this function will apply all of the necessary mutations to update the <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code> to their correct values for the current values for the remaining (input) tags.</p>
<p>The <code>BoundaryPrefix</code> template template parameter is to be passed a prefix tag associated with the boundary value prefix used in the computation (e.g. <code><a class="el" href="structCce_1_1Tags_1_1BoundaryValue.html" title="A prefix tag representing the boundary data for a quantity on the extraction surface.">Cce::Tags::BoundaryValue</a></code>), and allows easy switching between the regularity-preserving version and standard CCE. </p>

</div>
</div>
<a id="a806d20a6c6a5298c89f6335eaa461105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a806d20a6c6a5298c89f6335eaa461105">&#9670;&nbsp;</a></span>mutate_all_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; DataBoxTagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives. </p>
<h3>Details</h3>
<p>This function is called on the <a class="el" href="group__DataBoxGroup.html">DataBox</a> holding the relevant CCE data during each hypersurface integration step, after evaluating <code><a class="el" href="namespaceCce.html#a07b463a00a6b2ed71f0008f5aedeca0f" title="Evaluates the set of inputs to the CCE integrand for BondiValueTag that do not involve spin-weighted ...">mutate_all_pre_swsh_derivatives_for_tag()</a></code> with template argument <code>BondiValueTag</code> and before evaluating <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.">ComputeBondiIntegrand</a>&lt;BondiValueTag&gt;</code>. Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#a7dd34947472e61d70007727517310500" title="A typelist for the full set of tags needed as direct or indirect input to any ComputeBondiIntegrand t...">Cce::all_pre_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#ad8c937a1e34a4865805c5680f8f7872d" title="A typelist for the set of tags computed by spin-weighted differentiation using utilities from the Sws...">Cce::all_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a" title="A typelist for the full set of coefficient buffers needed to process all of the tags in all_swsh_deri...">Cce::all_transform_buffer_tags</a></code>, <code><a class="el" href="namespaceCce.html#a7a4a1a7fe54a9f77fbf034fb95f46474" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, and <code><a class="el" href="structCce_1_1Tags_1_1LMax.html">Cce::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by single spin-weighted differentiation using utilities from ...">Cce::single_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> and <code><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities fro...">Cce::second_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> to their correct values for the current values of the remaining (input) tags. </p>

</div>
</div>
<a id="a92c09ce690887bbc85cc2795f46d4ea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c09ce690887bbc85cc2795f46d4ea2">&#9670;&nbsp;</a></span>null_metric_and_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_metric_and_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SphericaliCartesianJ &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spacetime metric and its first derivative in the intermediate radial null coordinates. </p>
<h3>Details</h3>
<p>These components are obtained by the steps in Section II-A of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>, which is based on the computation from Section 4.3 of <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a>. The most direct comparison is to be made with equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>, which gives the null metric components explicitly. The time derivative is then (using notation from equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>):</p>
<p class="formulaDsp">
\begin{align} \partial_{\bar u} g_{\bar u \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar A} &amp;= 0 \\ \partial_{\bar u} g_{\bar u \bar u} &amp;= \partial_{\breve t} g_{\breve t \breve t} \\ \partial_{\bar u} g_{\bar u \bar A} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}}\\ g_{\breve i \breve t} \partial_{\bar u} g_{\bar A \bar B} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}} \frac{\partial \breve x^{\breve j}}{\partial \bar x^{\bar B}} g_{\breve i \breve j} \end{align}
</p>
 
</div>
</div>
<a id="aeb7b45583c0c7a0133374d9ec2fb8dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7b45583c0c7a0133374d9ec2fb8dde">&#9670;&nbsp;</a></span>null_vector_l_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_vector_l_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\). </p>
<h3>Details</h3>
<p>For mathematical description of our choice of the null generator, refer to equation (22) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>, and for the first time derivative see (25) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="af367dfeb1f3ee40aca23c628e9809ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af367dfeb1f3ee40aca23c628e9809ac1">&#9670;&nbsp;</a></span>precomputed_cce_q_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; Cce::precomputed_cce_q_integrator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_grid_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation. </p>
<h3>Details</h3>
<p>The provided matrix acts on the integrand collocation points and solves the equation,</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = g, \]
</p>
<p>for \(f\) given integrand \(g\). </p>

</div>
</div>
<a id="a4ceddf5716fd1d0f97c862f63c6bc156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ceddf5716fd1d0f97c862f63c6bc156">&#9670;&nbsp;</a></span>radial_integrate_cce_pole_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::radial_integrate_cce_pole_equations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> * &gt;&#160;</td>
          <td class="paramname"><em>integral_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pole_of_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>regular_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>one_minus_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution. </p>
<h3>Details</h3>
<p>Computes and returns by <code>not_null</code> pointer the solution to the equation</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = A + (1 - y) B, \]
</p>
<p>where \(A\) is provided as <code>pole_of_integrand</code> and \(B\) is provided as <code>regular_integrand</code>. The value <code>one_minus_y</code> is required for determining the integrand and <code>l_max</code> is required to determine the shape of the spin-weighted spherical harmonic mesh. </p>

</div>
</div>
<a id="aeeafc63c7c01088a03aef934f9bf2ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeafc63c7c01088a03aef934f9bf2ae4">&#9670;&nbsp;</a></span>trigonometric_functions_on_swsh_collocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::trigonometric_functions_on_swsh_collocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order. </p>
<h3>Details</h3>
<p>These are needed for coordinate transformations from the input Cartesian-like coordinates. </p>

</div>
</div>
<a id="ac41670f303c4b35dbde41cba79a8f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41670f303c4b35dbde41cba79a8f638">&#9670;&nbsp;</a></span>worldtube_normal_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::worldtube_normal_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; * &gt;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative. </p>
<h3>Details</h3>
<p>Refer to equation (20) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> for the expression of the spatial unit normal vector, and equation (23) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[5]</a> for the first time derivative. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[11]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
