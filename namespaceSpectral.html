<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Spectral Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Spectral Namespace Reference<div class="ingroups"><a class="el" href="group__SpectralGroup.html">Spectral</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Functionality associated with a particular choice of basis functions and quadrature for spectral operations.  
<a href="namespaceSpectral.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceSpectral_1_1filtering"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1filtering.html">filtering</a></td></tr>
<tr class="memdesc:namespaceSpectral_1_1filtering"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices for filtering spectral coefficients. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceSpectral_1_1Swsh"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral_1_1Swsh.html">Swsh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9c919afdb3d6d216e6b79edc29a018f7"><td class="memItemLeft" align="right" valign="top"><a id="a9c919afdb3d6d216e6b79edc29a018f7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a9c919afdb3d6d216e6b79edc29a018f7">MortarSize</a> { <b>Full</b>, 
<b>UpperHalf</b>, 
<b>LowerHalf</b>
 }</td></tr>
<tr class="memdesc:a9c919afdb3d6d216e6b79edc29a018f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The portion of an element covered by a mortar. <br /></td></tr>
<tr class="separator:a9c919afdb3d6d216e6b79edc29a018f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37c9c17d05dccca652060d117f72ee21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Basis</a> { <b>Chebyshev</b>, 
<b>Legendre</b>, 
<b>FiniteDifference</b>
 }</td></tr>
<tr class="memdesc:ga37c9c17d05dccca652060d117f72ee21"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of basis functions for computing collocation points and weights.  <a href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">More...</a><br /></td></tr>
<tr class="separator:ga37c9c17d05dccca652060d117f72ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7744e520f6d553caf358a6f09f5978c1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Quadrature</a> { <b>Gauss</b>, 
<b>GaussLobatto</b>, 
<b>CellCentered</b>, 
<b>FaceCentered</b>
 }</td></tr>
<tr class="memdesc:ga7744e520f6d553caf358a6f09f5978c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The choice of quadrature method to compute integration weights.  <a href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">More...</a><br /></td></tr>
<tr class="separator:ga7744e520f6d553caf358a6f09f5978c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac69f2bdb99c13b84e6120578f7bd2c2a"><td class="memItemLeft" align="right" valign="top"><a id="ac69f2bdb99c13b84e6120578f7bd2c2a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac69f2bdb99c13b84e6120578f7bd2c2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_collocation_points_and_weights&lt; Basis::FiniteDifference, Quadrature::CellCentered &gt;</b> (const size_t num_points) noexcept</td></tr>
<tr class="separator:ac69f2bdb99c13b84e6120578f7bd2c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9476d1cd6d4663fd96a940c2215771c0"><td class="memItemLeft" align="right" valign="top"><a id="a9476d1cd6d4663fd96a940c2215771c0"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9476d1cd6d4663fd96a940c2215771c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_collocation_points_and_weights&lt; Basis::FiniteDifference, Quadrature::FaceCentered &gt;</b> (const size_t num_points) noexcept</td></tr>
<tr class="separator:a9476d1cd6d4663fd96a940c2215771c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bc4e869534858db23c4fdfc738b1b0"><td class="memTemplParams" colspan="2"><a id="a65bc4e869534858db23c4fdfc738b1b0"></a>
template&lt;Basis BasisType&gt; </td></tr>
<tr class="memitem:a65bc4e869534858db23c4fdfc738b1b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spectral_indefinite_integral_matrix</b> (size_t num_points) noexcept</td></tr>
<tr class="separator:a65bc4e869534858db23c4fdfc738b1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b6010ff5b9793e1811782eda184ed4"><td class="memItemLeft" align="right" valign="top"><a id="a60b6010ff5b9793e1811782eda184ed4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a60b6010ff5b9793e1811782eda184ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spectral_indefinite_integral_matrix&lt; Basis::FiniteDifference &gt;</b> (const size_t) noexcept</td></tr>
<tr class="separator:a60b6010ff5b9793e1811782eda184ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d7f5303a75af430a94c2364055e67"><td class="memItemLeft" align="right" valign="top"><a id="a091d7f5303a75af430a94c2364055e67"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a091d7f5303a75af430a94c2364055e67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_basis_function_value&lt; Basis::FiniteDifference &gt;</b> (const size_t, const <a class="el" href="classDataVector.html">DataVector</a> &amp;) noexcept</td></tr>
<tr class="separator:a091d7f5303a75af430a94c2364055e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc8a84514e0346ec50efffc7d01f813"><td class="memItemLeft" align="right" valign="top"><a id="affc8a84514e0346ec50efffc7d01f813"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:affc8a84514e0346ec50efffc7d01f813"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_basis_function_value&lt; Basis::FiniteDifference &gt;</b> (const size_t, const double &amp;) noexcept</td></tr>
<tr class="separator:affc8a84514e0346ec50efffc7d01f813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26750a52cd9c04e0f07c79720e22bd8d"><td class="memItemLeft" align="right" valign="top"><a id="a26750a52cd9c04e0f07c79720e22bd8d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a26750a52cd9c04e0f07c79720e22bd8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>compute_inverse_weight_function_values&lt; Basis::FiniteDifference &gt;</b> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;) noexcept</td></tr>
<tr class="separator:a26750a52cd9c04e0f07c79720e22bd8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6352b9a916e88e9df3b5d4cf74ae350"><td class="memItemLeft" align="right" valign="top"><a id="ab6352b9a916e88e9df3b5d4cf74ae350"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, <a class="el" href="namespaceSpectral.html#a9c919afdb3d6d216e6b79edc29a018f7">MortarSize</a> mortar_size) noexcept</td></tr>
<tr class="separator:ab6352b9a916e88e9df3b5d4cf74ae350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4986eaac565b15d265556cbee1004be"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad4986eaac565b15d265556cbee1004be">projection_matrix_mortar_to_element</a> (<a class="el" href="namespaceSpectral.html#a9c919afdb3d6d216e6b79edc29a018f7">MortarSize</a> size, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;element_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mortar_mesh) noexcept</td></tr>
<tr class="memdesc:ad4986eaac565b15d265556cbee1004be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a 1D mortar to an element.  <a href="namespaceSpectral.html#ad4986eaac565b15d265556cbee1004be">More...</a><br /></td></tr>
<tr class="separator:ad4986eaac565b15d265556cbee1004be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e7ce003f77d16533c5008528d535f4"><td class="memItemLeft" align="right" valign="top"><a id="a86e7ce003f77d16533c5008528d535f4"></a>
const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a86e7ce003f77d16533c5008528d535f4">projection_matrix_element_to_mortar</a> (<a class="el" href="namespaceSpectral.html#a9c919afdb3d6d216e6b79edc29a018f7">MortarSize</a> size, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mortar_mesh, const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;element_mesh) noexcept</td></tr>
<tr class="memdesc:a86e7ce003f77d16533c5008528d535f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The projection matrix from a 1D element to a mortar. See <a class="el" href="namespaceSpectral.html#ad4986eaac565b15d265556cbee1004be" title="The projection matrix from a 1D mortar to an element.">projection_matrix_mortar_to_element()</a> for details. <br /></td></tr>
<tr class="separator:a86e7ce003f77d16533c5008528d535f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7afb1b00eacf64065d844fae2958a840"><td class="memItemLeft" align="right" valign="top"><a id="a7afb1b00eacf64065d844fae2958a840"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21">Basis</a> &amp;basis) noexcept</td></tr>
<tr class="separator:a7afb1b00eacf64065d844fae2958a840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d5c79bc2aa2b6ec3d9edb02a23dbd"><td class="memItemLeft" align="right" valign="top"><a id="a885d5c79bc2aa2b6ec3d9edb02a23dbd"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/io/basic_ostream.html">std::ostream</a> &amp;os, const <a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1">Quadrature</a> &amp;quadrature) noexcept</td></tr>
<tr class="separator:a885d5c79bc2aa2b6ec3d9edb02a23dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da39baebbabfffe012d3a9433ae8138"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a8da39baebbabfffe012d3a9433ae8138"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a8da39baebbabfffe012d3a9433ae8138">collocation_points</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:a8da39baebbabfffe012d3a9433ae8138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points.  <a href="namespaceSpectral.html#a8da39baebbabfffe012d3a9433ae8138">More...</a><br /></td></tr>
<tr class="separator:a8da39baebbabfffe012d3a9433ae8138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba36dd4c314b038129311dcb2c644daf"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:aba36dd4c314b038129311dcb2c644daf"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aba36dd4c314b038129311dcb2c644daf">quadrature_weights</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:aba36dd4c314b038129311dcb2c644daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights to compute definite integrals.  <a href="namespaceSpectral.html#aba36dd4c314b038129311dcb2c644daf">More...</a><br /></td></tr>
<tr class="separator:aba36dd4c314b038129311dcb2c644daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ec2be22ed7a694949db310c31bc5f6"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType, typename T &gt; </td></tr>
<tr class="memitem:a73ec2be22ed7a694949db310c31bc5f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a73ec2be22ed7a694949db310c31bc5f6">interpolation_matrix</a> (size_t num_points, const T &amp;target_points) noexcept</td></tr>
<tr class="memdesc:a73ec2be22ed7a694949db310c31bc5f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to interpolate to the <code>target_points</code>.  <a href="namespaceSpectral.html#a73ec2be22ed7a694949db310c31bc5f6">More...</a><br /></td></tr>
<tr class="separator:a73ec2be22ed7a694949db310c31bc5f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27039663ca5d66f343621290ed5c0308"><td class="memTemplParams" colspan="2"><a id="a27039663ca5d66f343621290ed5c0308"></a>
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a27039663ca5d66f343621290ed5c0308"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boundary_interpolation_matrices</b> (const size_t num_points) noexcept</td></tr>
<tr class="separator:a27039663ca5d66f343621290ed5c0308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31459b3cc48edef2bd474ce6ee3ae3e1"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a31459b3cc48edef2bd474ce6ee3ae3e1">boundary_interpolation_matrices</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:a31459b3cc48edef2bd474ce6ee3ae3e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrices that interpolate to the lower and upper boundaries of the element.  <a href="namespaceSpectral.html#a31459b3cc48edef2bd474ce6ee3ae3e1">More...</a><br /></td></tr>
<tr class="separator:a31459b3cc48edef2bd474ce6ee3ae3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af138a7c02f8efd0273e2d8aa7915284f"><td class="memTemplParams" colspan="2"><a id="af138a7c02f8efd0273e2d8aa7915284f"></a>
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:af138a7c02f8efd0273e2d8aa7915284f"><td class="memTemplItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>boundary_lifting_term</b> (const size_t num_points) noexcept</td></tr>
<tr class="separator:af138a7c02f8efd0273e2d8aa7915284f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accce9f7ffc9238fbc6558c62cbdbceea"><td class="memItemLeft" align="right" valign="top">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#accce9f7ffc9238fbc6558c62cbdbceea">boundary_lifting_term</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:accce9f7ffc9238fbc6558c62cbdbceea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points.  <a href="namespaceSpectral.html#accce9f7ffc9238fbc6558c62cbdbceea">More...</a><br /></td></tr>
<tr class="separator:accce9f7ffc9238fbc6558c62cbdbceea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa5a7b347ab6c7896fb397e193e0791"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3fa5a7b347ab6c7896fb397e193e0791"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMatrix.html">Matrix</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a3fa5a7b347ab6c7896fb397e193e0791">interpolation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh, const T &amp;target_points) noexcept</td></tr>
<tr class="memdesc:a3fa5a7b347ab6c7896fb397e193e0791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolation matrix to the <code>target_points</code> for a one-dimensional mesh.  <a href="namespaceSpectral.html#a3fa5a7b347ab6c7896fb397e193e0791">More...</a><br /></td></tr>
<tr class="separator:a3fa5a7b347ab6c7896fb397e193e0791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f762708ae8e2fbef0e8d4bb4d021d73"><td class="memTemplParams" colspan="2"><a id="a8f762708ae8e2fbef0e8d4bb4d021d73"></a>
template&lt;Basis BasisType, typename T &gt; </td></tr>
<tr class="memitem:a8f762708ae8e2fbef0e8d4bb4d021d73"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a8f762708ae8e2fbef0e8d4bb4d021d73">compute_basis_function_value</a> (size_t k, const T &amp;x) noexcept</td></tr>
<tr class="memdesc:a8f762708ae8e2fbef0e8d4bb4d021d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the function values of the basis function \(\Phi_k(x)\) (zero-indexed). <br /></td></tr>
<tr class="separator:a8f762708ae8e2fbef0e8d4bb4d021d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5a0a69f640063dc391c403c97d71e1"><td class="memTemplParams" colspan="2"><a id="aeb5a0a69f640063dc391c403c97d71e1"></a>
template&lt;Basis &gt; </td></tr>
<tr class="memitem:aeb5a0a69f640063dc391c403c97d71e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDataVector.html">DataVector</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aeb5a0a69f640063dc391c403c97d71e1">compute_inverse_weight_function_values</a> (const <a class="el" href="classDataVector.html">DataVector</a> &amp;) noexcept</td></tr>
<tr class="memdesc:aeb5a0a69f640063dc391c403c97d71e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of the weight function \(w(x)\) w.r.t. which the basis functions are orthogonal. See the description of <code><a class="el" href="namespaceSpectral.html#aba36dd4c314b038129311dcb2c644daf" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a></code> for details. <br /></td></tr>
<tr class="separator:aeb5a0a69f640063dc391c403c97d71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae112111db00191023c93bf465549ed5"><td class="memTemplParams" colspan="2"><a id="aae112111db00191023c93bf465549ed5"></a>
template&lt;Basis BasisType&gt; </td></tr>
<tr class="memitem:aae112111db00191023c93bf465549ed5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aae112111db00191023c93bf465549ed5">compute_basis_function_normalization_square</a> (size_t k) noexcept</td></tr>
<tr class="memdesc:aae112111db00191023c93bf465549ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normalization square of the basis function \(\Phi_k\) (zero-indexed), i.e. the weighted definite integral over its square. <br /></td></tr>
<tr class="separator:aae112111db00191023c93bf465549ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0029a8458d13dd113e3b17aedc305436"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a0029a8458d13dd113e3b17aedc305436"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a0029a8458d13dd113e3b17aedc305436">compute_collocation_points_and_weights</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:a0029a8458d13dd113e3b17aedc305436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the collocation points and weights associated to the basis and quadrature.  <a href="namespaceSpectral.html#a0029a8458d13dd113e3b17aedc305436">More...</a><br /></td></tr>
<tr class="separator:a0029a8458d13dd113e3b17aedc305436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdea51c8da9163a169b375fa91a4ffba"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#abdea51c8da9163a169b375fa91a4ffba">collocation_points</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:abdea51c8da9163a169b375fa91a4ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collocation points for a one-dimensional mesh.  <a href="namespaceSpectral.html#abdea51c8da9163a169b375fa91a4ffba">More...</a><br /></td></tr>
<tr class="separator:abdea51c8da9163a169b375fa91a4ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204507ffd55e6295b8bfc650726a53c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDataVector.html">DataVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a204507ffd55e6295b8bfc650726a53c6">quadrature_weights</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:a204507ffd55e6295b8bfc650726a53c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quadrature weights for a one-dimensional mesh.  <a href="namespaceSpectral.html#a204507ffd55e6295b8bfc650726a53c6">More...</a><br /></td></tr>
<tr class="separator:a204507ffd55e6295b8bfc650726a53c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1168f9e363d2ace1b13f8a3c025f2e2"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:ad1168f9e363d2ace1b13f8a3c025f2e2"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad1168f9e363d2ace1b13f8a3c025f2e2">differentiation_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:ad1168f9e363d2ace1b13f8a3c025f2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the derivative of a function.  <a href="namespaceSpectral.html#ad1168f9e363d2ace1b13f8a3c025f2e2">More...</a><br /></td></tr>
<tr class="separator:ad1168f9e363d2ace1b13f8a3c025f2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5651d2608737447150c0de460a691ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#af5651d2608737447150c0de460a691ef">differentiation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:af5651d2608737447150c0de460a691ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Differentiation matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#af5651d2608737447150c0de460a691ef">More...</a><br /></td></tr>
<tr class="separator:af5651d2608737447150c0de460a691ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60759a39c0fbaf7be7ee505bc98cbd53"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a60759a39c0fbaf7be7ee505bc98cbd53"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a60759a39c0fbaf7be7ee505bc98cbd53">weak_flux_differentiation_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:a60759a39c0fbaf7be7ee505bc98cbd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the divergence of the flux in weak form.  <a href="namespaceSpectral.html#a60759a39c0fbaf7be7ee505bc98cbd53">More...</a><br /></td></tr>
<tr class="separator:a60759a39c0fbaf7be7ee505bc98cbd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38a6f26cc66dadda350ce96d44177d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aa38a6f26cc66dadda350ce96d44177d4">weak_flux_differentiation_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:aa38a6f26cc66dadda350ce96d44177d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to compute the divergence of the flux in weak form.  <a href="namespaceSpectral.html#aa38a6f26cc66dadda350ce96d44177d4">More...</a><br /></td></tr>
<tr class="separator:aa38a6f26cc66dadda350ce96d44177d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdb585b6ec3f6ccdbd5778b6ca396b6"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:abcdb585b6ec3f6ccdbd5778b6ca396b6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#abcdb585b6ec3f6ccdbd5778b6ca396b6">integration_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:abcdb585b6ec3f6ccdbd5778b6ca396b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to perform an indefinite integral of a function over the logical grid. The left boundary condition is such that the integral is 0 at \(\xi=-1\)  <a href="namespaceSpectral.html#abcdb585b6ec3f6ccdbd5778b6ca396b6">More...</a><br /></td></tr>
<tr class="separator:abcdb585b6ec3f6ccdbd5778b6ca396b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae709e4ff33b9a414ff878529c91f58cc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ae709e4ff33b9a414ff878529c91f58cc">integration_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:ae709e4ff33b9a414ff878529c91f58cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indefinite integration matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#ae709e4ff33b9a414ff878529c91f58cc">More...</a><br /></td></tr>
<tr class="separator:ae709e4ff33b9a414ff878529c91f58cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4515583e06fd661630abf433049473"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:aec4515583e06fd661630abf433049473"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473">modal_to_nodal_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:aec4515583e06fd661630abf433049473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficients. Also referred to as the <em>Vandermonde matrix</em>.  <a href="namespaceSpectral.html#aec4515583e06fd661630abf433049473">More...</a><br /></td></tr>
<tr class="separator:aec4515583e06fd661630abf433049473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e816032f6ded356d96ad078d6793db"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a69e816032f6ded356d96ad078d6793db">modal_to_nodal_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:a69e816032f6ded356d96ad078d6793db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation matrix from modal to nodal coefficients for a one-dimensional mesh.  <a href="namespaceSpectral.html#a69e816032f6ded356d96ad078d6793db">More...</a><br /></td></tr>
<tr class="separator:a69e816032f6ded356d96ad078d6793db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690676a766e2de8b0a2cc1d29aa25888"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:a690676a766e2de8b0a2cc1d29aa25888"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a690676a766e2de8b0a2cc1d29aa25888">nodal_to_modal_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:a690676a766e2de8b0a2cc1d29aa25888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (modes). Also referred to as the inverse <em>Vandermonde matrix</em>.  <a href="namespaceSpectral.html#a690676a766e2de8b0a2cc1d29aa25888">More...</a><br /></td></tr>
<tr class="separator:a690676a766e2de8b0a2cc1d29aa25888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57cabbd140d7c7f76b917fe7a0a6e5dc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a57cabbd140d7c7f76b917fe7a0a6e5dc">nodal_to_modal_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:a57cabbd140d7c7f76b917fe7a0a6e5dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation matrix from nodal to modal coefficients for a one-dimensional mesh.  <a href="namespaceSpectral.html#a57cabbd140d7c7f76b917fe7a0a6e5dc">More...</a><br /></td></tr>
<tr class="separator:a57cabbd140d7c7f76b917fe7a0a6e5dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e64dd72191760a25a1272efadf12a1"><td class="memTemplParams" colspan="2">template&lt;Basis BasisType, Quadrature QuadratureType&gt; </td></tr>
<tr class="memitem:af3e64dd72191760a25a1272efadf12a1"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#af3e64dd72191760a25a1272efadf12a1">linear_filter_matrix</a> (size_t num_points) noexcept</td></tr>
<tr class="memdesc:af3e64dd72191760a25a1272efadf12a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix used to linearize a function.  <a href="namespaceSpectral.html#af3e64dd72191760a25a1272efadf12a1">More...</a><br /></td></tr>
<tr class="separator:af3e64dd72191760a25a1272efadf12a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166b38f2e7742f281fce9392b8f5a431"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a166b38f2e7742f281fce9392b8f5a431">linear_filter_matrix</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:a166b38f2e7742f281fce9392b8f5a431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear filter matrix for a one-dimensional mesh.  <a href="namespaceSpectral.html#a166b38f2e7742f281fce9392b8f5a431">More...</a><br /></td></tr>
<tr class="separator:a166b38f2e7742f281fce9392b8f5a431"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memTemplParams" colspan="2">template&lt;Basis basis, Quadrature quadrature&gt; </td></tr>
<tr class="memitem:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#a7ed70608b007d26c6e7bf23ea14e8357">minimum_number_of_points</a></td></tr>
<tr class="memdesc:a7ed70608b007d26c6e7bf23ea14e8357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum number of possible collocation points for a quadrature type.  <a href="namespaceSpectral.html#a7ed70608b007d26c6e7bf23ea14e8357">More...</a><br /></td></tr>
<tr class="separator:a7ed70608b007d26c6e7bf23ea14e8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memTemplParams" colspan="2">template&lt;Basis basis&gt; </td></tr>
<tr class="memitem:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSpectral.html#ad3f83fd18f48d47423e1d5cf9d718a7a">maximum_number_of_points</a></td></tr>
<tr class="memdesc:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of allowed collocation points.  <a href="namespaceSpectral.html#ad3f83fd18f48d47423e1d5cf9d718a7a">More...</a><br /></td></tr>
<tr class="separator:ad3f83fd18f48d47423e1d5cf9d718a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functionality associated with a particular choice of basis functions and quadrature for spectral operations. </p>
<h3>Details</h3>
<p>The functions in this namespace provide low-level access to collocation points, quadrature weights and associated matrices, such as for differentiation and interpolation. They are available in two versions: either templated directly on the enum cases of the <a class="el" href="group__SpectralGroup.html#ga37c9c17d05dccca652060d117f72ee21" title="The choice of basis functions for computing collocation points and weights.">Spectral::Basis</a> and <a class="el" href="group__SpectralGroup.html#ga7744e520f6d553caf358a6f09f5978c1" title="The choice of quadrature method to compute integration weights.">Spectral::Quadrature</a> types, or taking a one-dimensional <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a> as their argument.</p>
<dl class="section note"><dt>Note</dt><dd>Generally you should prefer working with a <a class="el" href="classMesh.html" title="Holds the number of grid points, basis, and quadrature in each direction of the computational grid.">Mesh</a>. Use its <a class="el" href="classMesh.html#a08a856ef3898e9def37c9568dfed2b52" title="Returns a Mesh with the dimensions d, ... present (zero-indexed).">Mesh::slice_through()</a> method to retrieve the mesh in a particular dimension: <div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;2&gt;</a> mesh2d{</div>
<div class="line">      {{3, 4}},</div>
<div class="line">      {{Spectral::Basis::Legendre, Spectral::Basis::Legendre}},</div>
<div class="line">      {{Spectral::Quadrature::Gauss, Spectral::Quadrature::GaussLobatto}}};</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> collocation_points_in_first_dim =</div>
<div class="line">      <a class="code" href="namespaceSpectral.html#a8da39baebbabfffe012d3a9433ae8138">Spectral::collocation_points</a>(mesh2d.slice_through(0));</div>
</div><!-- fragment --></dd></dl>
<p>Most algorithms in this namespace are adapted from <a class="el" href="citelist.html#CITEREF_Kopriva">[41]</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a31459b3cc48edef2bd474ce6ee3ae3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31459b3cc48edef2bd474ce6ee3ae3e1">&#9670;&nbsp;</a></span>boundary_interpolation_matrices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classMatrix.html">Matrix</a>, <a class="el" href="classMatrix.html">Matrix</a> &gt; &amp; Spectral::boundary_interpolation_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrices that interpolate to the lower and upper boundaries of the element. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair interpolates to \(\xi=-1\) and the second to \(\xi=1\). These are just the Lagrange interpolating polynomials evaluated at \(\xi=\pm1\). For Gauss-Lobatto points the only non-zero element is at the boundaries and is one and so is not implemented.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="accce9f7ffc9238fbc6558c62cbdbceea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accce9f7ffc9238fbc6558c62cbdbceea">&#9670;&nbsp;</a></span>boundary_lifting_term()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; <a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp; Spectral::boundary_lifting_term </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terms used during the lifting portion of a discontinuous Galerkin scheme when using Gauss points. </p>
<p>Assumes that the logical coordinates are \([-1, 1]\). The first element of the pair is the Lagrange polyonmials evaluated at \(\xi=-1\) divided by the weights and the second at \(\xi=1\). Specifically,</p>
<p class="formulaDsp">
\begin{align*} \frac{\ell_j(\xi=\pm1)}{w_j} \end{align*}
</p>
<dl class="section warning"><dt>Warning</dt><dd>This can only be called with Gauss points. </dd></dl>

</div>
</div>
<a id="abdea51c8da9163a169b375fa91a4ffba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdea51c8da9163a169b375fa91a4ffba">&#9670;&nbsp;</a></span>collocation_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::collocation_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collocation points for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a8da39baebbabfffe012d3a9433ae8138" title="Collocation points.">collocation_points(size_t)</a> </dd></dl>

</div>
</div>
<a id="a8da39baebbabfffe012d3a9433ae8138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da39baebbabfffe012d3a9433ae8138">&#9670;&nbsp;</a></span>collocation_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a> &amp; Spectral::collocation_points </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collocation points. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0029a8458d13dd113e3b17aedc305436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0029a8458d13dd113e3b17aedc305436">&#9670;&nbsp;</a></span>compute_collocation_points_and_weights()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt;<a class="el" href="classDataVector.html">DataVector</a>, <a class="el" href="classDataVector.html">DataVector</a>&gt; Spectral::compute_collocation_points_and_weights </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the collocation points and weights associated to the basis and quadrature. </p>
<h3>Details</h3>
<p>This function is expected to return the tuple \((\xi_k,w_k)\) where the \(\xi_k\) are the collocation points and the \(w_k\) are defined in the description of <code><a class="el" href="namespaceSpectral.html#aba36dd4c314b038129311dcb2c644daf" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a></code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures only the collocation points are set, the weights are <code>NaN</code>. </dd></dl>

</div>
</div>
<a id="af5651d2608737447150c0de460a691ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5651d2608737447150c0de460a691ef">&#9670;&nbsp;</a></span>differentiation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Differentiation matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#ad1168f9e363d2ace1b13f8a3c025f2e2" title="Matrix used to compute the derivative of a function.">differentiation_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="ad1168f9e363d2ace1b13f8a3c025f2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1168f9e363d2ace1b13f8a3c025f2e2">&#9670;&nbsp;</a></span>differentiation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to compute the derivative of a function. </p>
<h3>Details</h3>
<p>For a function represented by the nodal coefficients \(u_j\) a matrix multiplication with the differentiation matrix \(D_{ij}\) gives the coefficients of the function's derivative. Since \(u(x)\) is expanded in Lagrange polynomials \(u(x)=\sum_j u_j l_j(x)\) the differentiation matrix is computed as \(D_{ij}=l_j^\prime(\xi_i)\) where the \(\xi_i\) are the collocation points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae709e4ff33b9a414ff878529c91f58cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae709e4ff33b9a414ff878529c91f58cc">&#9670;&nbsp;</a></span>integration_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::integration_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indefinite integration matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#abcdb585b6ec3f6ccdbd5778b6ca396b6" title="Matrix used to perform an indefinite integral of a function over the logical grid....">integration_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="abcdb585b6ec3f6ccdbd5778b6ca396b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcdb585b6ec3f6ccdbd5778b6ca396b6">&#9670;&nbsp;</a></span>integration_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::integration_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to perform an indefinite integral of a function over the logical grid. The left boundary condition is such that the integral is 0 at \(\xi=-1\) </p>
<p>Currently only Legendre and Chebyshev polynomials are implemented, but we provide a derivation for how to compute the indefinite integration matrix for general Jacobi polynomials.</p>
<h4><a class="anchor" id="autotoc_md37"></a>
Legendre Polynomials</h4>
<p>The Legendre polynomials have the identity:</p>
<p class="formulaDsp">
\begin{align*} P_n(x) = \frac{1}{2n+1}\frac{d}{dx}\left(P_{n+1}(x) - P_{n-1}(x)\right) \end{align*}
</p>
<p>The goal is to evaluate the integral of a function \(u\) expanded in terms of Legendre polynomials as</p>
<p class="formulaDsp">
\begin{align*} u(x) = \sum_{i=0}^{N} c_i P_i(x) \end{align*}
</p>
<p>We similarly expand the indefinite integral of \(u\) as</p>
<p class="formulaDsp">
\begin{align*} \left.\int u(y) dy\right\rvert_{x}=&amp;\sum_{i=0}^N \tilde{c}_i P_i(x) \\ =&amp;\left.\int\sum_{i=1}^{N}\frac{c_i}{2i+1} \left(P_{i+1}(y)-P_{i-1}(y)\right)dy\right\rvert_{x} + \tilde{c}_0 P_0(x) \\ =&amp;\sum_{i=1}^{N}\left(\frac{c_{i-1}}{2i-1} - \frac{c_{i+1}}{2i+3}\right) P_i(x) + \tilde{c}_0 P_0(x) \end{align*}
</p>
<p>Thus we get that for \(i&gt;0\)</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=\frac{c_{i-1}}{2i-1}-\frac{c_{i+1}}{2i+3} \end{align*}
</p>
<p>and \(\tilde{c}_0\) is a constant of integration, which we choose such that the integral is 0 at the left boundary of the domain ( \(x=-1\)). The condition for this is:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^{N}(-1)^{i+1}\tilde{c}_i \end{align*}
</p>
<p>The matrix returned by this function is the product of the tridiagonal matrix for the \(\tilde{c}_i\) and the matrix for the boundary condition.</p>
<h4><a class="anchor" id="autotoc_md38"></a>
Chebyshev Polynomials</h4>
<p>A similar derivation leads to the relations:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=&amp;\frac{c_{i-1}-c_{i+1}}{2i},&amp;\mathrm{if}\;i&gt;1 \\ \tilde{c}_1=&amp;c_0 - \frac{c_2}{2},&amp;\mathrm{if}\;i=1 \\ \end{align*}
</p>
<p>We again have:</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^N(-1)^{i+1}\tilde{c}_i \end{align*}
</p>
<p>These are then used to define the indefinite integration matrix.</p>
<h4><a class="anchor" id="autotoc_md39"></a>
Jacobi Polynomials</h4>
<p>For general Jacobi polynomials \(P^{(\alpha,\beta)}_n(x)\) given by</p>
<p class="formulaDsp">
\begin{align*} (1-x)^\alpha(1+x)^\beta P^{(\alpha,\beta)}_n(x)=\frac{(-1)^n}{2^n n!} \frac{d^n}{dx^n}\left[(1-x)^{\alpha+n}(1+x)^{\beta+n}\right] \end{align*}
</p>
<p>we have that</p>
<p class="formulaDsp">
\begin{align*} P^{(\alpha,\beta)}_n(x)=\frac{d}{dx}\left( b^{(\alpha,\beta)}_{n-1,n}P^{(\alpha,\beta)}_{n-1}(x) + b^{(\alpha,\beta)}_{n,n}P^{(\alpha,\beta)}_n(x) + b^{(\alpha,\beta)}_{n+1,n}P^{(\alpha,\beta)}_{n+1}(x) \right) \end{align*}
</p>
<p>where</p>
<p class="formulaDsp">
\begin{align*} b^{(\alpha,\beta)}_{n-1,n}=&amp;-\frac{1}{n+\alpha+\beta} a^{(\alpha,\beta)}_{n-1,n} \\ b^{(\alpha,\beta)}_{n,n}=&amp;-\frac{2}{\alpha+\beta} a^{(\alpha,\beta)}_{n,n} \\ b^{(\alpha,\beta)}_{n+1,n}=&amp;\frac{1}{n+1} a^{(\alpha,\beta)}_{n+1,n} \\ a^{(\alpha,\beta)}_{n-1,n}=&amp;\frac{2(n+\alpha)(n+\beta)} {(2n+\alpha+\beta+1)(2n+\alpha+\beta)} \\ a^{(\alpha,\beta)}_{n,n}=&amp;-\frac{\alpha^2-\beta^2} {(2n+\alpha+\beta+2)(2n+\alpha+\beta)} \\ a^{(\alpha,\beta)}_{n-1,n}=&amp;\frac{2(n+1)(n+\alpha+\beta+1)} {(2n+\alpha+\beta+2)(2n+\alpha+\beta+1)} \end{align*}
</p>
<p>Following the same derivation we get that</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_i=c_{i+1}b^{(\alpha,\beta)}_{i,i+1} +c_i b^{(\alpha,\beta)}_{i,i} +c_{i-1}b^{(\alpha,\beta)}_{i,i-1} \end{align*}
</p>
<p>and the boundary condition is</p>
<p class="formulaDsp">
\begin{align*} \tilde{c}_0=\sum_{i=1}^N(-1)^{i+1} \frac{\Gamma(i+\alpha+1)}{i!\Gamma(\alpha+1)} \tilde{c}_i \end{align*}
</p>
<p>where \(\Gamma(x)\) is the Gamma function. </p>

</div>
</div>
<a id="a3fa5a7b347ab6c7896fb397e193e0791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa5a7b347ab6c7896fb397e193e0791">&#9670;&nbsp;</a></span>interpolation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> Spectral::interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Interpolation matrix to the <code>target_points</code> for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a73ec2be22ed7a694949db310c31bc5f6" title="Matrix used to interpolate to the target_points.">interpolation_matrix(size_t, const T&amp;)</a> </dd></dl>

</div>
</div>
<a id="a73ec2be22ed7a694949db310c31bc5f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ec2be22ed7a694949db310c31bc5f6">&#9670;&nbsp;</a></span>interpolation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMatrix.html">Matrix</a> Spectral::interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to interpolate to the <code>target_points</code>. </p>
<dl class="section warning"><dt>Warning</dt><dd>For each target point located outside of the logical coordinate interval covered by <code>BasisType</code> (often \([-1,1]\)), the resulting matrix performs polynomial extrapolation instead of interpolation. The extrapolation will be correct but may suffer from reduced accuracy, especially for higher-order polynomials (i.e., larger values of <code>num_points</code>).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
    <tr><td class="paramname">target_points</td><td>The points to interpolate to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a166b38f2e7742f281fce9392b8f5a431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166b38f2e7742f281fce9392b8f5a431">&#9670;&nbsp;</a></span>linear_filter_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::linear_filter_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear filter matrix for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#af3e64dd72191760a25a1272efadf12a1" title="Matrix used to linearize a function.">linear_filter_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="af3e64dd72191760a25a1272efadf12a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e64dd72191760a25a1272efadf12a1">&#9670;&nbsp;</a></span>linear_filter_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::linear_filter_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to linearize a function. </p>
<h3>Details</h3>
<p>Filters out all except the lowest two modes by applying \(\mathcal{V}^{-1}\cdot\mathrm{diag}(1,1,0,0,...)\cdot\mathcal{V}\) to the nodal coefficients, where \(\mathcal{V}\) is the Vandermonde matrix computed in <code><a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd>
<dd>
<a class="el" href="namespaceSpectral.html#a690676a766e2de8b0a2cc1d29aa25888" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a69e816032f6ded356d96ad078d6793db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e816032f6ded356d96ad078d6793db">&#9670;&nbsp;</a></span>modal_to_nodal_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::modal_to_nodal_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation matrix from modal to nodal coefficients for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="aec4515583e06fd661630abf433049473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4515583e06fd661630abf433049473">&#9670;&nbsp;</a></span>modal_to_nodal_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::modal_to_nodal_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficients. Also referred to as the <em>Vandermonde matrix</em>. </p>
<h3>Details</h3>
<p>The Vandermonde matrix is computed as \(\mathcal{V}_{ij}=\Phi_j(\xi_i)\) where the \(\Phi_j(x)\) are the spectral basis functions used in the modal expansion \(u(x)=\sum_j \widetilde{u}_j\Phi_j(x)\), e.g. normalized Legendre polynomials, and the \(\xi_i\) are the collocation points used to construct the interpolating Lagrange polynomials in the nodal expansion \(u(x)=\sum_j u_j l_j(x)\). Then the Vandermonde matrix arises as \(u(\xi_i)=u_i=\sum_j \widetilde{u}_j\Phi_j(\xi_i)=\sum_j \mathcal{V}_{ij}\widetilde{u}_j\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a690676a766e2de8b0a2cc1d29aa25888" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a57cabbd140d7c7f76b917fe7a0a6e5dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57cabbd140d7c7f76b917fe7a0a6e5dc">&#9670;&nbsp;</a></span>nodal_to_modal_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::nodal_to_modal_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transformation matrix from nodal to modal coefficients for a one-dimensional mesh. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a690676a766e2de8b0a2cc1d29aa25888" title="Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (mode...">nodal_to_modal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a690676a766e2de8b0a2cc1d29aa25888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a690676a766e2de8b0a2cc1d29aa25888">&#9670;&nbsp;</a></span>nodal_to_modal_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::nodal_to_modal_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to transform from the nodal coefficients of a function to its spectral coefficients (modes). Also referred to as the inverse <em>Vandermonde matrix</em>. </p>
<h3>Details</h3>
<p>This is the inverse to the Vandermonde matrix \(\mathcal{V}\) computed in <a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a>. It can be computed analytically for Gauss quadrature by evaluating \(\sum_j\mathcal{V}^{-1}_{ij}u_j=\widetilde{u}_i= \frac{(u,\Phi_i)}{\gamma_i}\) for a Lagrange basis function \(u(x)=l_k(x)\) to find \(\mathcal{V}^{-1}_{ij}=\mathcal{V}_{ji}\frac{w_j}{\gamma_i}\) where the \(w_j\) are the Gauss quadrature weights and \(\gamma_i\) is the norm square of the spectral basis function \(\Phi_i\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#aec4515583e06fd661630abf433049473" title="Matrix used to transform from the spectral coefficients (modes) of a function to its nodal coefficien...">modal_to_nodal_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="ad4986eaac565b15d265556cbee1004be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4986eaac565b15d265556cbee1004be">&#9670;&nbsp;</a></span>projection_matrix_mortar_to_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; Spectral::projection_matrix_mortar_to_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceSpectral.html#a9c919afdb3d6d216e6b79edc29a018f7">MortarSize</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mortar_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The projection matrix from a 1D mortar to an element. </p>
<h3>Details</h3>
<p>The projection matrices returned by this function (and by <a class="el" href="namespaceSpectral.html#a86e7ce003f77d16533c5008528d535f4" title="The projection matrix from a 1D element to a mortar. See projection_matrix_mortar_to_element() for de...">projection_matrix_element_to_mortar()</a>) define orthogonal projection operators between the spaces of functions on the boundary of the element and the mortar. These projections are usually the correct way to transfer data onto and off of the mortars.</p>
<p>The half-interval projections are based on an equation derived by Saul. This shows that the projection from the spectral basis for the entire interval to the spectral basis for the upper half interval is </p><p class="formulaDsp">
\begin{equation*} T_{jk} = \frac{2 j + 1}{2} 2^j \sum_{n=0}^{j-k} \binom{j}{k+n} \binom{(j + k + n - 1)/2}{j} \frac{(k + n)!^2}{(2 k + n + 1)! n!} \end{equation*}
</p>
 
</div>
</div>
<a id="a204507ffd55e6295b8bfc650726a53c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204507ffd55e6295b8bfc650726a53c6">&#9670;&nbsp;</a></span>quadrature_weights() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a>&amp; Spectral::quadrature_weights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Quadrature weights for a one-dimensional mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures the weights are <code>NaN</code>.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#aba36dd4c314b038129311dcb2c644daf" title="Weights to compute definite integrals.">quadrature_weights(size_t)</a> </dd></dl>

</div>
</div>
<a id="aba36dd4c314b038129311dcb2c644daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba36dd4c314b038129311dcb2c644daf">&#9670;&nbsp;</a></span>quadrature_weights() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDataVector.html">DataVector</a> &amp; Spectral::quadrature_weights </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights to compute definite integrals. </p>
<h3>Details</h3>
<p>These are the coefficients to contract with the nodal function values \(f_k\) to approximate the definite integral \(I[f]=\int f(x)\mathrm{d}x\).</p>
<p>Note that the term <em>quadrature</em> also often refers to the quantity \(Q[f]=\int f(x)w(x)\mathrm{d}x\approx \sum_k f_k w_k\). Here, \(w(x)\) denotes the basis-specific weight function w.r.t. to which the basis functions \(\Phi_k\) are orthogonal, i.e \(\int\Phi_i(x)\Phi_j(x)w(x)=0\) for \(i\neq j\). The weights \(w_k\) approximate this inner product. To approximate the definite integral \(I[f]\) we must employ the coefficients \(\frac{w_k}{w(\xi_k)}\) instead, where the \(\xi_k\) are the collocation points. These are the coefficients this function returns. Only for a unit weight function \(w(x)=1\), i.e. a Legendre basis, is \(I[f]=Q[f]\) so this function returns the \(w_k\) identically.</p>
<dl class="section warning"><dt>Warning</dt><dd>for a <code>FiniteDifference</code> basis or <code>CellCentered</code> and <code>FaceCentered</code> quadratures the weights are <code>NaN</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38a6f26cc66dadda350ce96d44177d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38a6f26cc66dadda350ce96d44177d4">&#9670;&nbsp;</a></span>weak_flux_differentiation_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::weak_flux_differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to compute the divergence of the flux in weak form. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceSpectral.html#a60759a39c0fbaf7be7ee505bc98cbd53" title="Matrix used to compute the divergence of the flux in weak form.">weak_flux_differentiation_matrix(size_t)</a> </dd></dl>

</div>
</div>
<a id="a60759a39c0fbaf7be7ee505bc98cbd53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60759a39c0fbaf7be7ee505bc98cbd53">&#9670;&nbsp;</a></span>weak_flux_differentiation_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis BasisType, Quadrature QuadratureType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a>&amp; Spectral::weak_flux_differentiation_matrix </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matrix used to compute the divergence of the flux in weak form. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num_points</td><td>The number of collocation points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad3f83fd18f48d47423e1d5cf9d718a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f83fd18f48d47423e1d5cf9d718a7a">&#9670;&nbsp;</a></span>maximum_number_of_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis basis&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Spectral::maximum_number_of_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    basis == Basis::FiniteDifference ? 23 : 12</div>
</div><!-- fragment -->
<p>Maximum number of allowed collocation points. </p>
<h3>Details</h3>
<p>We choose a limit of 23 FD grid points because for DG-subcell the number of points in an element is <code>2 * (number_dg_points - 1)</code>. Because there is no way of generically retrieving the maximum number of grid points for a non-FD basis, we need to hard-code both values here. If the number of grid points is increased for the non-FD bases, it should also be increased for the FD basis. Note that for good task-based parallelization 23 grid points is already a fairly large number. </p>

</div>
</div>
<a id="a7ed70608b007d26c6e7bf23ea14e8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed70608b007d26c6e7bf23ea14e8357">&#9670;&nbsp;</a></span>minimum_number_of_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;Basis basis, Quadrature quadrature&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Spectral::minimum_number_of_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">    detail::minimum_number_of_points(basis, quadrature)</div>
</div><!-- fragment -->
<p>Minimum number of possible collocation points for a quadrature type. </p>
<h3>Details</h3>
<p>Since Gauss-Lobatto quadrature has points on the domain boundaries it must have at least two collocation points. Gauss quadrature can have only one collocation point.</p>
<h3>Details</h3>
<p>For <code>CellCentered</code> the minimum number of points is 1, while for <code>FaceCentered</code> it is 2. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceSpectral_html_a8da39baebbabfffe012d3a9433ae8138"><div class="ttname"><a href="namespaceSpectral.html#a8da39baebbabfffe012d3a9433ae8138">Spectral::collocation_points</a></div><div class="ttdeci">const DataVector &amp; collocation_points(const size_t num_points) noexcept</div><div class="ttdoc">Collocation points.</div><div class="ttdef"><b>Definition:</b> Spectral.cpp:283</div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">Holds the number of grid points, basis, and quadrature in each direction of the computational grid.</div><div class="ttdef"><b>Definition:</b> Mesh.hpp:48</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
