<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Testing Framework</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Testing Framework</div>  </div>
</div><!--header-->
<div class="contents">

<p>Classes, functions, macros, and instructions for developing tests.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceActionTesting"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceActionTesting.html">ActionTesting</a></td></tr>
<tr class="memdesc:namespaceActionTesting"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structures used for mocking the parallel components framework in order to test actions. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepypp"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepypp.html">pypp</a></td></tr>
<tr class="memdesc:namespacepypp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains all functions for calling python from C++. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1AnalyticData"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1AnalyticData.html">TestHelpers::AnalyticData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1VerifyGrSolution"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1VerifyGrSolution.html">TestHelpers::VerifyGrSolution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1AnalyticSolutions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1AnalyticSolutions.html">TestHelpers::AnalyticSolutions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1gr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1gr.html">TestHelpers::gr</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1gr"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random GR variables which correct physical behavior, e.g. spatial metric will be positive definite. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceTestHelpers_1_1hydro"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTestHelpers_1_1hydro.html">TestHelpers::hydro</a></td></tr>
<tr class="memdesc:namespaceTestHelpers_1_1hydro"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make random hydro variables which correct physical behavior, e.g. Lorentz factor will be greater or equal than one. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classActionTesting_1_1MockRuntimeSystem.html">ActionTesting::MockRuntimeSystem&lt; Metavariables &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTestHelpers_1_1TestCreationOpt.html">TestHelpers::TestCreationOpt&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUniformCustomDistribution.html">UniformCustomDistribution&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A uniform distribution function object which redirects appropriately to either the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/uniform_int_distribution.html">std::uniform_int_distribution</a></code> or the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution.html">std::uniform_real_distribution</a></code>. This also provides a convenience constructor which takes a 2-element array for the bounds for either floating point or int distributions.  <a href="classUniformCustomDistribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOrientationMapIterator.html">OrientationMapIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for looping through all possible orientations of the n-dim cube.  <a href="classOrientationMapIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a>(FUNCTION_NAME,  TUPLE_ARGS, ...)</td></tr>
<tr class="memdesc:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to invoke a test function of multiple template arguments.  <a href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">More...</a><br /></td></tr>
<tr class="separator:ga8cd2549e4a5627f34f8201af2bcbfd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a>(FUNCTION_NAME, ...)</td></tr>
<tr class="memdesc:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro used to test functions whose parameter can be a <code>double</code> or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.  <a href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">More...</a><br /></td></tr>
<tr class="separator:ga21fcbc0b07905e0d2f8b012b388acd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaec8dcdc783140fb14fe617cc0cc1dcae">CHECK_OP</a>(a,  op,  b,  c)</td></tr>
<tr class="memdesc:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a op b == c and also the op= version.  <a href="group__TestingFrameworkGroup.html#gaec8dcdc783140fb14fe617cc0cc1dcae">More...</a><br /></td></tr>
<tr class="separator:gaec8dcdc783140fb14fe617cc0cc1dcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7f766439113f958bf4f8ba0f53c4881"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881">MAKE_GENERATOR</a>(...)</td></tr>
<tr class="memdesc:gad7f766439113f958bf4f8ba0f53c4881"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881" title="MAKE_GENERATOR(NAME [, SEED]) declares a variable of name NAME containing a generator of type std::mt...">MAKE_GENERATOR(NAME [, SEED])</a></code> declares a variable of name <code>NAME</code> containing a generator of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></code>.  <a href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881">More...</a><br /></td></tr>
<tr class="separator:gad7f766439113f958bf4f8ba0f53c4881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447b43fced460461e76beca1a28fc273"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga447b43fced460461e76beca1a28fc273">CHECK_VARIABLES_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga447b43fced460461e76beca1a28fc273"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of each entry in each tag within a variables.  <a href="group__TestingFrameworkGroup.html#ga447b43fced460461e76beca1a28fc273">More...</a><br /></td></tr>
<tr class="separator:ga447b43fced460461e76beca1a28fc273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6553c686d7f6b55372814227d1542272"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6553c686d7f6b55372814227d1542272">CHECK_VARIABLES_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga6553c686d7f6b55372814227d1542272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_VARIABLES_APPROX</code>, but with a user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga6553c686d7f6b55372814227d1542272">More...</a><br /></td></tr>
<tr class="separator:ga6553c686d7f6b55372814227d1542272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b08319337a0dd8a83326a33768bbba0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5b08319337a0dd8a83326a33768bbba0">CHECK_ELEMENT_WISE_FUNCTION_APPROX</a>(function,  arguments)</td></tr>
<tr class="memdesc:ga5b08319337a0dd8a83326a33768bbba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A test utility for verifying that an element-wise function, <code>function</code> acts identically to the same operation applied to each element of a container separately. This macro invokes <code><a class="el" href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09" title="Utility function for verifying the action of an element-wise function on containers,...">test_element_wise_function()</a></code> (which gives a more complete documentation of the element-wise checking operations and arguments).  <a href="group__TestingFrameworkGroup.html#ga5b08319337a0dd8a83326a33768bbba0">More...</a><br /></td></tr>
<tr class="separator:ga5b08319337a0dd8a83326a33768bbba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76e2c6db4f9527f5fea4528d2f2532ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga76e2c6db4f9527f5fea4528d2f2532ba">CHECK_CUSTOM_ELEMENT_WISE_FUNCTION_APPROX</a>( function,  arguments,  at_operator,  size_of_operator)</td></tr>
<tr class="memdesc:ga76e2c6db4f9527f5fea4528d2f2532ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_ELEMENT_WISE_FUNCTION_APPROX</code>, but with a user-defined function <code>at_operator</code> and <code>size_of_operator</code>, each of which correspond to arguments of <code><a class="el" href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09" title="Utility function for verifying the action of an element-wise function on containers,...">test_element_wise_function()</a></code> (which gives a more complete documentation of the element-wise checking operations and arguments).  <a href="group__TestingFrameworkGroup.html#ga76e2c6db4f9527f5fea4528d2f2532ba">More...</a><br /></td></tr>
<tr class="separator:ga76e2c6db4f9527f5fea4528d2f2532ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fce1ae5980139598815eda5a5de8ab"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">SPECTRE_PARALLEL_REQUIRE</a>(expr)</td></tr>
<tr class="memdesc:ga37fce1ae5980139598815eda5a5de8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">A similar to Catch's REQUIRE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares.  <a href="group__TestingFrameworkGroup.html#ga37fce1ae5980139598815eda5a5de8ab">More...</a><br /></td></tr>
<tr class="separator:ga37fce1ae5980139598815eda5a5de8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2adb81ed48c421e8f77541f34eb3f821"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2adb81ed48c421e8f77541f34eb3f821">SPECTRE_PARALLEL_REQUIRE_FALSE</a>(expr)</td></tr>
<tr class="memdesc:ga2adb81ed48c421e8f77541f34eb3f821"><td class="mdescLeft">&#160;</td><td class="mdescRight">A similar to Catch's REQUIRE_FALSE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares.  <a href="group__TestingFrameworkGroup.html#ga2adb81ed48c421e8f77541f34eb3f821">More...</a><br /></td></tr>
<tr class="separator:ga2adb81ed48c421e8f77541f34eb3f821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5509fb28c65f22498410618609f8c085"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5509fb28c65f22498410618609f8c085">CHECK_COMPLEX_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga5509fb28c65f22498410618609f8c085"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of the two entries in a <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>. For efficiency, no function forwarding is performed, just a pair of <code>CHECK</code>s inline.  <a href="group__TestingFrameworkGroup.html#ga5509fb28c65f22498410618609f8c085">More...</a><br /></td></tr>
<tr class="separator:ga5509fb28c65f22498410618609f8c085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5527bb2a3aa50f572faae13dfb8783e5">CHECK_COMPLEX_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_COMPLEX_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga5527bb2a3aa50f572faae13dfb8783e5">More...</a><br /></td></tr>
<tr class="separator:ga5527bb2a3aa50f572faae13dfb8783e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce5d669c94418f197e4c55c53e64a64"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6ce5d669c94418f197e4c55c53e64a64">CHECK_ITERABLE_APPROX</a>(a,  b)</td></tr>
<tr class="memdesc:ga6ce5d669c94418f197e4c55c53e64a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around Catch's CHECK macro that checks approximate equality of entries in iterable containers. For maplike containers, keys are checked for strict equality and values are checked for approximate equality.  <a href="group__TestingFrameworkGroup.html#ga6ce5d669c94418f197e4c55c53e64a64">More...</a><br /></td></tr>
<tr class="separator:ga6ce5d669c94418f197e4c55c53e64a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4f36d1ee34e6eb0721e35918eb488f0c">CHECK_ITERABLE_CUSTOM_APPROX</a>(a,  b,  appx)</td></tr>
<tr class="memdesc:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>CHECK_ITERABLE_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>.  <a href="group__TestingFrameworkGroup.html#ga4f36d1ee34e6eb0721e35918eb488f0c">More...</a><br /></td></tr>
<tr class="separator:ga4f36d1ee34e6eb0721e35918eb488f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a>()</td></tr>
<tr class="memdesc:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test as checking a call to ERROR.  <a href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">More...</a><br /></td></tr>
<tr class="separator:gaf962c28abc1a1f014f2a6b32c6f01680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4439208ed8accb2887ff47388e91e58b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">ASSERTION_TEST</a>()</td></tr>
<tr class="memdesc:ga4439208ed8accb2887ff47388e91e58b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test to be checking an ASSERT.  <a href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">More...</a><br /></td></tr>
<tr class="separator:ga4439208ed8accb2887ff47388e91e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd515a98a97cf7fc82e722274b17e7ce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a>()</td></tr>
<tr class="memdesc:gacd515a98a97cf7fc82e722274b17e7ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a test as checking the output with a regular expression.  <a href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">More...</a><br /></td></tr>
<tr class="separator:gacd515a98a97cf7fc82e722274b17e7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9983e020a1f6541d517aab417fb8ed41"><td class="memItemLeft" align="right" valign="top"><a id="ga9983e020a1f6541d517aab417fb8ed41"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga9983e020a1f6541d517aab417fb8ed41">TestHelpers::VectorImpl::Bound</a> = <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 2 &gt;</td></tr>
<tr class="memdesc:ga9983e020a1f6541d517aab417fb8ed41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias to be more expressive with distribution bounds in vector tests which call the generic math test below. <br /></td></tr>
<tr class="separator:ga9983e020a1f6541d517aab417fb8ed41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestHelpers::VectorImpl::TestKind</a> { <b>Normal</b>, 
<b>Strict</b>, 
<b>Inplace</b>, 
<b>GivenOrderOfArgumentsOnly</b>
 }</td></tr>
<tr class="memdesc:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">the set of test types that may be used for the math operations  <a href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">More...</a><br /></td></tr>
<tr class="separator:ga921a5dbf5f1704e2051d1daf593d0d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad70e9824d819da51327073cce20f25f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename OptionTag  = TestCreationOpt&lt;T&gt;, typename Metavariables  = NoSuchType&gt; </td></tr>
<tr class="memitem:gad70e9824d819da51327073cce20f25f1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad70e9824d819da51327073cce20f25f1">TestHelpers::test_creation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string) noexcept</td></tr>
<tr class="separator:gad70e9824d819da51327073cce20f25f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4eda41a6ccec84a0ae929dc40664bad1"><td class="memTemplParams" colspan="2">template&lt;typename BaseClass , typename OptionTag  = TestCreationOpt&lt;std::unique_ptr&lt;BaseClass&gt;&gt;, typename Metavariables  = NoSuchType&gt; </td></tr>
<tr class="memitem:ga4eda41a6ccec84a0ae929dc40664bad1"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; BaseClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4eda41a6ccec84a0ae929dc40664bad1">TestHelpers::test_factory_creation</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;construction_string) noexcept</td></tr>
<tr class="separator:ga4eda41a6ccec84a0ae929dc40664bad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memTemplParams" colspan="2"><a id="ga2895e57f4cacd63d2549655bb29bba7b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2895e57f4cacd63d2549655bb29bba7b">serialize_and_deserialize</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga2895e57f4cacd63d2549655bb29bba7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes and deserializes an object <code>t</code> of type <code>T</code> <br /></td></tr>
<tr class="separator:ga2895e57f4cacd63d2549655bb29bba7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac14a5413ee918a2be9197d16339ed0a1"><td class="memTemplParams" colspan="2"><a id="gac14a5413ee918a2be9197d16339ed0a1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac14a5413ee918a2be9197d16339ed0a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gac14a5413ee918a2be9197d16339ed0a1">serialize_and_deserialize</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; result, const T &amp;t) noexcept</td></tr>
<tr class="memdesc:gac14a5413ee918a2be9197d16339ed0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serializes and deserializes an object <code>t</code> of type <code>T</code> <br /></td></tr>
<tr class="separator:gac14a5413ee918a2be9197d16339ed0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga4294de51e79ce048d0a76bd72f80d19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the serialization of comparable types.  <a href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">More...</a><br /></td></tr>
<tr class="separator:ga4294de51e79ce048d0a76bd72f80d19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memTemplParams" colspan="2">template&lt;typename B , typename D , typename... Args&gt; </td></tr>
<tr class="memitem:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test the serialization of a derived class via a base class pointer.  <a href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">More...</a><br /></td></tr>
<tr class="separator:ga9032f7d7bb3698bab71a49d1df9c2d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeca05cc83258027c4547dfd39f399965"><td class="memTemplParams" colspan="2"><a id="gaeca05cc83258027c4547dfd39f399965"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:gaeca05cc83258027c4547dfd39f399965"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaeca05cc83258027c4547dfd39f399965">check_cmp</a> (const T &amp;less, const U &amp;greater)</td></tr>
<tr class="memdesc:gaeca05cc83258027c4547dfd39f399965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to test comparison operators. Pass values with less &lt; greater. <br /></td></tr>
<tr class="separator:gaeca05cc83258027c4547dfd39f399965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a70d3bd416e878e8b9d9a783bfb60da"><td class="memTemplParams" colspan="2">template&lt;typename Invocable , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga6a70d3bd416e878e8b9d9a783bfb60da"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/result_of.html">std::result_of_t</a>&lt; const Invocable &amp;(const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6a70d3bd416e878e8b9d9a783bfb60da">numerical_derivative</a> (const Invocable &amp;function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;x, const size_t direction, const double delta) noexcept</td></tr>
<tr class="memdesc:ga6a70d3bd416e878e8b9d9a783bfb60da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the derivative of an Invocable at a point x - represented by an array of doubles - in the domain of <code>map</code> with a sixth-order finite difference method.  <a href="group__TestingFrameworkGroup.html#ga6a70d3bd416e878e8b9d9a783bfb60da">More...</a><br /></td></tr>
<tr class="separator:ga6a70d3bd416e878e8b9d9a783bfb60da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809dd7c089188c1c15f847f73cf6d924"><td class="memTemplParams" colspan="2">template&lt;typename Exception , typename ThrowingFunctor &gt; </td></tr>
<tr class="memitem:ga809dd7c089188c1c15f847f73cf6d924"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga809dd7c089188c1c15f847f73cf6d924">test_throw_exception</a> (const ThrowingFunctor &amp;func, const Exception &amp;expected)</td></tr>
<tr class="memdesc:ga809dd7c089188c1c15f847f73cf6d924"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute <code>func</code> and check that it throws an exception <code>expected</code>.  <a href="group__TestingFrameworkGroup.html#ga809dd7c089188c1c15f847f73cf6d924">More...</a><br /></td></tr>
<tr class="separator:ga809dd7c089188c1c15f847f73cf6d924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeae43aecf3e4fb517f2e227f67aa5c09"><td class="memTemplParams" colspan="2">template&lt;typename ElementWiseFunction , typename AtFunction  = GetContainerElement, typename SizeFunction  = GetContainerSize, typename... Arguments&gt; </td></tr>
<tr class="memitem:gaeae43aecf3e4fb517f2e227f67aa5c09"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09">test_element_wise_function</a> (ElementWiseFunction element_wise_function, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Arguments... &gt; * &gt; arguments, AtFunction at=<a class="el" href="structGetContainerElement.html">GetContainerElement</a>{}, SizeFunction size=<a class="el" href="structGetContainerSize.html">GetContainerSize</a>{}, Approx custom_approx=approx) noexcept</td></tr>
<tr class="memdesc:gaeae43aecf3e4fb517f2e227f67aa5c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for verifying the action of an element-wise function on containers, or on some combination of containers and compatible non-containers (e.g. <code>DataVectors</code> with <code>doubles</code>).  <a href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09">More...</a><br /></td></tr>
<tr class="separator:gaeae43aecf3e4fb517f2e227f67aa5c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb0dc19cfba9f7aa3f3637b9a99c23fc"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:gabb0dc19cfba9f7aa3f3637b9a99c23fc"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gabb0dc19cfba9f7aa3f3637b9a99c23fc">TestHelpers::Schwarzschild::spatial_ricci</a> (const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;x, double mass) noexcept</td></tr>
<tr class="memdesc:gabb0dc19cfba9f7aa3f3637b9a99c23fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schwarzschild (Kerr-Schild) spatial ricci tensor.  <a href="group__TestingFrameworkGroup.html#gabb0dc19cfba9f7aa3f3637b9a99c23fc">More...</a><br /></td></tr>
<tr class="separator:gabb0dc19cfba9f7aa3f3637b9a99c23fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ca38c64038e6122e91175f573686382"><td class="memTemplParams" colspan="2">template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </td></tr>
<tr class="memitem:ga7ca38c64038e6122e91175f573686382"><td class="memTemplItemLeft" align="right" valign="top">tnsr::ii&lt; DataType, SpatialDim, Frame &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7ca38c64038e6122e91175f573686382">TestHelpers::Minkowski::extrinsic_curvature_sphere</a> (const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:ga7ca38c64038e6122e91175f573686382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrinsic curvature of 2D sphere in 3D flat space.  <a href="group__TestingFrameworkGroup.html#ga7ca38c64038e6122e91175f573686382">More...</a><br /></td></tr>
<tr class="separator:ga7ca38c64038e6122e91175f573686382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6212a4bc03b660f649d3645742908ec"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:gab6212a4bc03b660f649d3645742908ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gab6212a4bc03b660f649d3645742908ec">TestHelpers::Kerr::horizon_ricci_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;horizon_radius, double mass, double dimensionless_spin_z) noexcept</td></tr>
<tr class="memdesc:gab6212a4bc03b660f649d3645742908ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kerr (Kerr-Schild) horizon ricci scalar (spin on z axis)  <a href="group__TestingFrameworkGroup.html#gab6212a4bc03b660f649d3645742908ec">More...</a><br /></td></tr>
<tr class="separator:gab6212a4bc03b660f649d3645742908ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ce3f988fc45ef28c91b0b742f3c805"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga52ce3f988fc45ef28c91b0b742f3c805"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga52ce3f988fc45ef28c91b0b742f3c805">TestHelpers::Kerr::horizon_ricci_scalar</a> (const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;horizon_radius_with_spin_on_z_axis, const <a class="el" href="classYlmSpherepack.html">YlmSpherepack</a> &amp;ylm_with_spin_on_z_axis, const <a class="el" href="classYlmSpherepack.html">YlmSpherepack</a> &amp;ylm, double mass, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;dimensionless_spin) noexcept</td></tr>
<tr class="memdesc:ga52ce3f988fc45ef28c91b0b742f3c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kerr (Kerr-Schild) horizon ricci scalar (generic spin)  <a href="group__TestingFrameworkGroup.html#ga52ce3f988fc45ef28c91b0b742f3c805">More...</a><br /></td></tr>
<tr class="separator:ga52ce3f988fc45ef28c91b0b742f3c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67a7537d548219483eb98017cf8cd1bd"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, UpLo Ul, typename Fr  = Frame::Inertial, Requires&lt;(Ul==UpLo::Up)&gt;  = nullptr&gt; </td></tr>
<tr class="memitem:ga67a7537d548219483eb98017cf8cd1bd"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, Dim, Fr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga67a7537d548219483eb98017cf8cd1bd">make_random_vector_in_magnitude_range</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; nn_generator, const tnsr::ii&lt; DataType, Dim, Fr &gt; &amp;metric, const double min_magnitude, const double max_magnitude) noexcept</td></tr>
<tr class="memdesc:ga67a7537d548219483eb98017cf8cd1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a spatial vector in a given magnitude range.  <a href="group__TestingFrameworkGroup.html#ga67a7537d548219483eb98017cf8cd1bd">More...</a><br /></td></tr>
<tr class="separator:ga67a7537d548219483eb98017cf8cd1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20a4744720b4c6627e920591154e58e8"><td class="memTemplParams" colspan="2">template&lt;typename DataType , size_t Dim, UpLo Ul, typename Fr  = Frame::Inertial, typename T &gt; </td></tr>
<tr class="memitem:ga20a4744720b4c6627e920591154e58e8"><td class="memTemplItemLeft" align="right" valign="top">Tensor&lt; DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt; 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; Dim, Ul, Fr &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga20a4744720b4c6627e920591154e58e8">make_random_vector_in_magnitude_range_flat</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; nn_generator, const T &amp;used_for_size, const double min_magnitude, const double max_magnitude) noexcept</td></tr>
<tr class="memdesc:ga20a4744720b4c6627e920591154e58e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a spatial vector in a given magnitude range.  <a href="group__TestingFrameworkGroup.html#ga20a4744720b4c6627e920591154e58e8">More...</a><br /></td></tr>
<tr class="separator:ga20a4744720b4c6627e920591154e58e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga689b0334217eafa70595ece948ebbbf7"><td class="memTemplParams" colspan="2"><a id="ga689b0334217eafa70595ece948ebbbf7"></a>
template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga689b0334217eafa70595ece948ebbbf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga689b0334217eafa70595ece948ebbbf7">fill_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; T * &gt; data, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution) noexcept</td></tr>
<tr class="memdesc:ga689b0334217eafa70595ece948ebbbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill an existing data structure with random values. <br /></td></tr>
<tr class="separator:ga689b0334217eafa70595ece948ebbbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f98af1ba7b65811cf35536db6259f88"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga7f98af1ba7b65811cf35536db6259f88"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7f98af1ba7b65811cf35536db6259f88">make_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution, const T &amp;used_for_size) noexcept</td></tr>
<tr class="memdesc:ga7f98af1ba7b65811cf35536db6259f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a data structure and fill it with random values.  <a href="group__TestingFrameworkGroup.html#ga7f98af1ba7b65811cf35536db6259f88">More...</a><br /></td></tr>
<tr class="separator:ga7f98af1ba7b65811cf35536db6259f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dba8563c3916477bc9dd6ca7cadc5e2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </td></tr>
<tr class="memitem:ga1dba8563c3916477bc9dd6ca7cadc5e2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1dba8563c3916477bc9dd6ca7cadc5e2">make_with_random_values</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt; generator, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt; distribution) noexcept</td></tr>
<tr class="memdesc:ga1dba8563c3916477bc9dd6ca7cadc5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a fixed-size data structure and fill with random values.  <a href="group__TestingFrameworkGroup.html#ga1dba8563c3916477bc9dd6ca7cadc5e2">More...</a><br /></td></tr>
<tr class="separator:ga1dba8563c3916477bc9dd6ca7cadc5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08ddec1937980b51fb3410b955577fd2"><td class="memTemplParams" colspan="2"><a id="ga08ddec1937980b51fb3410b955577fd2"></a>
template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga08ddec1937980b51fb3410b955577fd2"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; DataType, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga08ddec1937980b51fb3410b955577fd2">random_unit_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt; generator, const tnsr::ii&lt; DataType, 1 &gt; &amp;spatial_metric) noexcept</td></tr>
<tr class="memdesc:ga08ddec1937980b51fb3410b955577fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a random unit normal vector at each element of <code>DataType</code>. <br /></td></tr>
<tr class="separator:ga08ddec1937980b51fb3410b955577fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45d562728baabd57a5b2b316799c81d2"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga45d562728baabd57a5b2b316799c81d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga45d562728baabd57a5b2b316799c81d2">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_0</a> () noexcept</td></tr>
<tr class="memdesc:ga45d562728baabd57a5b2b316799c81d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the computed tensor multi-index of a rank 0 RHS Tensor is equivalent to the given LHS tensor multi-index.  <a href="group__TestingFrameworkGroup.html#ga45d562728baabd57a5b2b316799c81d2">More...</a><br /></td></tr>
<tr class="separator:ga45d562728baabd57a5b2b316799c81d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c751f2fde92620756ee845bc1e48eca"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename TensorIndexTypeList , typename TensorIndex &gt; </td></tr>
<tr class="memitem:ga4c751f2fde92620756ee845bc1e48eca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4c751f2fde92620756ee845bc1e48eca">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_1_impl</a> (const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;tensorindex) noexcept</td></tr>
<tr class="memdesc:ga4c751f2fde92620756ee845bc1e48eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the computed tensor multi-index of a rank 1 RHS Tensor is equivalent to the given LHS tensor multi-index.  <a href="group__TestingFrameworkGroup.html#ga4c751f2fde92620756ee845bc1e48eca">More...</a><br /></td></tr>
<tr class="separator:ga4c751f2fde92620756ee845bc1e48eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73b62147bba9348939dbb9c375094f55"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndex &gt; </td></tr>
<tr class="memitem:ga73b62147bba9348939dbb9c375094f55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga73b62147bba9348939dbb9c375094f55">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_1</a> (const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;tensorindex) noexcept</td></tr>
<tr class="memdesc:ga73b62147bba9348939dbb9c375094f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimensions.  <a href="group__TestingFrameworkGroup.html#ga73b62147bba9348939dbb9c375094f55">More...</a><br /></td></tr>
<tr class="separator:ga73b62147bba9348939dbb9c375094f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1670f549d38a3d2af0f43894de3ae270"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB &gt; </td></tr>
<tr class="memitem:ga1670f549d38a3d2af0f43894de3ae270"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1670f549d38a3d2af0f43894de3ae270">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_impl</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b) noexcept</td></tr>
<tr class="memdesc:ga1670f549d38a3d2af0f43894de3ae270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the computed tensor multi-index of a rank 2 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices.  <a href="group__TestingFrameworkGroup.html#ga1670f549d38a3d2af0f43894de3ae270">More...</a><br /></td></tr>
<tr class="separator:ga1670f549d38a3d2af0f43894de3ae270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gababb2ef1c0dd7992dba36d41474e8284"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceA, UpLo ValenceB, typename TensorIndexA , typename TensorIndexB &gt; </td></tr>
<tr class="memitem:gababb2ef1c0dd7992dba36d41474e8284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gababb2ef1c0dd7992dba36d41474e8284">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_no_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b) noexcept</td></tr>
<tr class="memdesc:gababb2ef1c0dd7992dba36d41474e8284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#gababb2ef1c0dd7992dba36d41474e8284">More...</a><br /></td></tr>
<tr class="separator:gababb2ef1c0dd7992dba36d41474e8284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2855d4c7ca4088ac85003e52d7ea0a81"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndexA , typename TensorIndexB &gt; </td></tr>
<tr class="memitem:ga2855d4c7ca4088ac85003e52d7ea0a81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2855d4c7ca4088ac85003e52d7ea0a81">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_symmetric</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b) noexcept</td></tr>
<tr class="memdesc:ga2855d4c7ca4088ac85003e52d7ea0a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga2855d4c7ca4088ac85003e52d7ea0a81">More...</a><br /></td></tr>
<tr class="separator:ga2855d4c7ca4088ac85003e52d7ea0a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f22d7b7c6ea08d936220835ab3a4cfd"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga1f22d7b7c6ea08d936220835ab3a4cfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1f22d7b7c6ea08d936220835ab3a4cfd">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_impl</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:ga1f22d7b7c6ea08d936220835ab3a4cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the computed tensor multi-index of a rank 3 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices.  <a href="group__TestingFrameworkGroup.html#ga1f22d7b7c6ea08d936220835ab3a4cfd">More...</a><br /></td></tr>
<tr class="separator:ga1f22d7b7c6ea08d936220835ab3a4cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb98e7f1ae3f5a7a34d82c5bf8e42de"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceA, UpLo ValenceB, UpLo ValenceC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga0cb98e7f1ae3f5a7a34d82c5bf8e42de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga0cb98e7f1ae3f5a7a34d82c5bf8e42de">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_no_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:ga0cb98e7f1ae3f5a7a34d82c5bf8e42de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices.  <a href="group__TestingFrameworkGroup.html#ga0cb98e7f1ae3f5a7a34d82c5bf8e42de">More...</a><br /></td></tr>
<tr class="separator:ga0cb98e7f1ae3f5a7a34d82c5bf8e42de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d49183ca01d4aa77ebb8c0a468ec8b"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceAB, UpLo ValenceC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga73d49183ca01d4aa77ebb8c0a468ec8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga73d49183ca01d4aa77ebb8c0a468ec8b">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_ab_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:ga73d49183ca01d4aa77ebb8c0a468ec8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices.  <a href="group__TestingFrameworkGroup.html#ga73d49183ca01d4aa77ebb8c0a468ec8b">More...</a><br /></td></tr>
<tr class="separator:ga73d49183ca01d4aa77ebb8c0a468ec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95331287c4f51ca32a12d7ccfa581dd2"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAC, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceAC, UpLo ValenceB, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga95331287c4f51ca32a12d7ccfa581dd2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga95331287c4f51ca32a12d7ccfa581dd2">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_ac_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:ga95331287c4f51ca32a12d7ccfa581dd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices.  <a href="group__TestingFrameworkGroup.html#ga95331287c4f51ca32a12d7ccfa581dd2">More...</a><br /></td></tr>
<tr class="separator:ga95331287c4f51ca32a12d7ccfa581dd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga556258cbddbda45f2080c9a3edac5c51"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeBC, UpLo ValenceA, UpLo ValenceBC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:ga556258cbddbda45f2080c9a3edac5c51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga556258cbddbda45f2080c9a3edac5c51">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_bc_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:ga556258cbddbda45f2080c9a3edac5c51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices.  <a href="group__TestingFrameworkGroup.html#ga556258cbddbda45f2080c9a3edac5c51">More...</a><br /></td></tr>
<tr class="separator:ga556258cbddbda45f2080c9a3edac5c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf020b0f3583daaa1db79ead423062c36"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </td></tr>
<tr class="memitem:gaf020b0f3583daaa1db79ead423062c36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf020b0f3583daaa1db79ead423062c36">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_abc_symmetry</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c) noexcept</td></tr>
<tr class="memdesc:gaf020b0f3583daaa1db79ead423062c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices.  <a href="group__TestingFrameworkGroup.html#gaf020b0f3583daaa1db79ead423062c36">More...</a><br /></td></tr>
<tr class="separator:gaf020b0f3583daaa1db79ead423062c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56d6f3035dbb8f8329915530c354f528"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB , typename TensorIndexC , typename TensorIndexD &gt; </td></tr>
<tr class="memitem:ga56d6f3035dbb8f8329915530c354f528"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga56d6f3035dbb8f8329915530c354f528">TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_4</a> (const TensorIndexA &amp;tensorindex_a, const TensorIndexB &amp;tensorindex_b, const TensorIndexC &amp;tensorindex_c, const TensorIndexD &amp;tensorindex_d) noexcept</td></tr>
<tr class="memdesc:ga56d6f3035dbb8f8329915530c354f528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that the computed tensor multi-index of a rank 4 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices.  <a href="group__TestingFrameworkGroup.html#ga56d6f3035dbb8f8329915530c354f528">More...</a><br /></td></tr>
<tr class="separator:ga56d6f3035dbb8f8329915530c354f528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7eeed237d2b270c574f0d118a4e173bb"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:ga7eeed237d2b270c574f0d118a4e173bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7eeed237d2b270c574f0d118a4e173bb">TestHelpers::TensorExpressions::test_evaluate_rank_0</a> (const DataType &amp;data) noexcept</td></tr>
<tr class="memdesc:ga7eeed237d2b270c574f0d118a4e173bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 0 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#ga7eeed237d2b270c574f0d118a4e173bb">More...</a><br /></td></tr>
<tr class="separator:ga7eeed237d2b270c574f0d118a4e173bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6967be72b060806aa5d9bcecf9ee4d67"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename TensorIndexTypeList , auto &amp; TensorIndex&gt; </td></tr>
<tr class="memitem:ga6967be72b060806aa5d9bcecf9ee4d67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6967be72b060806aa5d9bcecf9ee4d67">TestHelpers::TensorExpressions::test_evaluate_rank_1_impl</a> () noexcept</td></tr>
<tr class="memdesc:ga6967be72b060806aa5d9bcecf9ee4d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 1 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#ga6967be72b060806aa5d9bcecf9ee4d67">More...</a><br /></td></tr>
<tr class="separator:ga6967be72b060806aa5d9bcecf9ee4d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ff246b302b57a05cac170908188ec79"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndex&gt; </td></tr>
<tr class="memitem:ga2ff246b302b57a05cac170908188ec79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2ff246b302b57a05cac170908188ec79">TestHelpers::TensorExpressions::test_evaluate_rank_1</a> () noexcept</td></tr>
<tr class="memdesc:ga2ff246b302b57a05cac170908188ec79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimensions.  <a href="group__TestingFrameworkGroup.html#ga2ff246b302b57a05cac170908188ec79">More...</a><br /></td></tr>
<tr class="separator:ga2ff246b302b57a05cac170908188ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaf3bd6076c329febb925afac926fe3a"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:gaeaf3bd6076c329febb925afac926fe3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaeaf3bd6076c329febb925afac926fe3a">TestHelpers::TensorExpressions::test_evaluate_rank_2_impl</a> () noexcept</td></tr>
<tr class="memdesc:gaeaf3bd6076c329febb925afac926fe3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 2 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gaeaf3bd6076c329febb925afac926fe3a">More...</a><br /></td></tr>
<tr class="separator:gaeaf3bd6076c329febb925afac926fe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c305cf2543cbee8dbd02923d568f0e5"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceA, UpLo ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:ga4c305cf2543cbee8dbd02923d568f0e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4c305cf2543cbee8dbd02923d568f0e5">TestHelpers::TensorExpressions::test_evaluate_rank_2_no_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:ga4c305cf2543cbee8dbd02923d568f0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga4c305cf2543cbee8dbd02923d568f0e5">More...</a><br /></td></tr>
<tr class="separator:ga4c305cf2543cbee8dbd02923d568f0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed380eec1acd4a5df119fce26d177509"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </td></tr>
<tr class="memitem:gaed380eec1acd4a5df119fce26d177509"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaed380eec1acd4a5df119fce26d177509">TestHelpers::TensorExpressions::test_evaluate_rank_2_symmetric</a> () noexcept</td></tr>
<tr class="memdesc:gaed380eec1acd4a5df119fce26d177509"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#gaed380eec1acd4a5df119fce26d177509">More...</a><br /></td></tr>
<tr class="separator:gaed380eec1acd4a5df119fce26d177509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabeae30ae8bee27e759201e6c3029568"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:gaabeae30ae8bee27e759201e6c3029568"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaabeae30ae8bee27e759201e6c3029568">TestHelpers::TensorExpressions::test_evaluate_rank_3_impl</a> () noexcept</td></tr>
<tr class="memdesc:gaabeae30ae8bee27e759201e6c3029568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 3 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gaabeae30ae8bee27e759201e6c3029568">More...</a><br /></td></tr>
<tr class="separator:gaabeae30ae8bee27e759201e6c3029568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafede29f65b963f062dd534078c3395d"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceA, UpLo ValenceB, UpLo ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:gaafede29f65b963f062dd534078c3395d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaafede29f65b963f062dd534078c3395d">TestHelpers::TensorExpressions::test_evaluate_rank_3_no_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:gaafede29f65b963f062dd534078c3395d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#gaafede29f65b963f062dd534078c3395d">More...</a><br /></td></tr>
<tr class="separator:gaafede29f65b963f062dd534078c3395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4376c85cfd93f01f2f774b833b09d5d7"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceAB, UpLo ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga4376c85cfd93f01f2f774b833b09d5d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4376c85cfd93f01f2f774b833b09d5d7">TestHelpers::TensorExpressions::test_evaluate_rank_3_ab_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:ga4376c85cfd93f01f2f774b833b09d5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga4376c85cfd93f01f2f774b833b09d5d7">More...</a><br /></td></tr>
<tr class="separator:ga4376c85cfd93f01f2f774b833b09d5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga827f107d76351e39457d3589c9fef82c"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAC, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceAC, UpLo ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga827f107d76351e39457d3589c9fef82c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga827f107d76351e39457d3589c9fef82c">TestHelpers::TensorExpressions::test_evaluate_rank_3_ac_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:ga827f107d76351e39457d3589c9fef82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga827f107d76351e39457d3589c9fef82c">More...</a><br /></td></tr>
<tr class="separator:ga827f107d76351e39457d3589c9fef82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f8f30068d400394fdff1b2b8d94eb3d"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeBC, UpLo ValenceA, UpLo ValenceBC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga0f8f30068d400394fdff1b2b8d94eb3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga0f8f30068d400394fdff1b2b8d94eb3d">TestHelpers::TensorExpressions::test_evaluate_rank_3_bc_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:ga0f8f30068d400394fdff1b2b8d94eb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga0f8f30068d400394fdff1b2b8d94eb3d">More...</a><br /></td></tr>
<tr class="separator:ga0f8f30068d400394fdff1b2b8d94eb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1ddf86635aff89f36b64e46694ffd5"><td class="memTemplParams" colspan="2">template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </td></tr>
<tr class="memitem:ga8e1ddf86635aff89f36b64e46694ffd5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8e1ddf86635aff89f36b64e46694ffd5">TestHelpers::TensorExpressions::test_evaluate_rank_3_abc_symmetry</a> () noexcept</td></tr>
<tr class="memdesc:ga8e1ddf86635aff89f36b64e46694ffd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations.  <a href="group__TestingFrameworkGroup.html#ga8e1ddf86635aff89f36b64e46694ffd5">More...</a><br /></td></tr>
<tr class="separator:ga8e1ddf86635aff89f36b64e46694ffd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5cb356a3ed5c9b33fb849a9ffee7002"><td class="memTemplParams" colspan="2">template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC, auto &amp; TensorIndexD&gt; </td></tr>
<tr class="memitem:gad5cb356a3ed5c9b33fb849a9ffee7002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad5cb356a3ed5c9b33fb849a9ffee7002">TestHelpers::TensorExpressions::test_evaluate_rank_4</a> () noexcept</td></tr>
<tr class="memdesc:gad5cb356a3ed5c9b33fb849a9ffee7002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that evaluating a right hand side tensor expression containing a single rank 4 tensor correctly assigns the data to the evaluated left hand side tensor.  <a href="group__TestingFrameworkGroup.html#gad5cb356a3ed5c9b33fb849a9ffee7002">More...</a><br /></td></tr>
<tr class="separator:gad5cb356a3ed5c9b33fb849a9ffee7002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a1befa0bb8af437c081a992f7dc11e8"><td class="memTemplParams" colspan="2"><a id="ga8a1befa0bb8af437c081a992f7dc11e8"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga8a1befa0bb8af437c081a992f7dc11e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga8a1befa0bb8af437c081a992f7dc11e8">TestHelpers::VectorImpl::vector_test_construct_and_assign</a> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0}) noexcept</td></tr>
<tr class="memdesc:ga8a1befa0bb8af437c081a992f7dc11e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">test construction and assignment of a <code>VectorType</code> with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga8a1befa0bb8af437c081a992f7dc11e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1107a6a611543b70cc5f895b835a367e"><td class="memTemplParams" colspan="2"><a id="ga1107a6a611543b70cc5f895b835a367e"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga1107a6a611543b70cc5f895b835a367e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1107a6a611543b70cc5f895b835a367e">TestHelpers::VectorImpl::vector_test_serialize</a> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{ 100.0}) noexcept</td></tr>
<tr class="memdesc:ga1107a6a611543b70cc5f895b835a367e"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the serialization of a <code>VectorType</code> constructed with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga1107a6a611543b70cc5f895b835a367e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b21aa8a8ec3ed4756193ec01a04d105"><td class="memTemplParams" colspan="2"><a id="ga2b21aa8a8ec3ed4756193ec01a04d105"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga2b21aa8a8ec3ed4756193ec01a04d105"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga2b21aa8a8ec3ed4756193ec01a04d105">TestHelpers::VectorImpl::vector_test_ref</a> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{ 100.0}) noexcept</td></tr>
<tr class="memdesc:ga2b21aa8a8ec3ed4756193ec01a04d105"><td class="mdescLeft">&#160;</td><td class="mdescRight">test the construction and move of a reference <code>VectorType</code> constructed with a <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga2b21aa8a8ec3ed4756193ec01a04d105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc8106fbcf642235c3a21b28835e8041"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename ValueType  = typename VectorType::ElementType&gt; </td></tr>
<tr class="memitem:gabc8106fbcf642235c3a21b28835e8041"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gabc8106fbcf642235c3a21b28835e8041">TestHelpers::VectorImpl::vector_ref_test_size_error</a> (RefSizeErrorTestKind test_kind, tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0}) noexcept</td></tr>
<tr class="memdesc:gabc8106fbcf642235c3a21b28835e8041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test that assigning to a non-owning <code>VectorType</code> of the wrong size appropriately generates an error.  <a href="group__TestingFrameworkGroup.html#gabc8106fbcf642235c3a21b28835e8041">More...</a><br /></td></tr>
<tr class="separator:gabc8106fbcf642235c3a21b28835e8041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c92dd364b5c10deb51c67a29b1f0749"><td class="memTemplParams" colspan="2"><a id="ga1c92dd364b5c10deb51c67a29b1f0749"></a>
template&lt;typename VectorType , typename ValueType &gt; </td></tr>
<tr class="memitem:ga1c92dd364b5c10deb51c67a29b1f0749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1c92dd364b5c10deb51c67a29b1f0749">TestHelpers::VectorImpl::vector_test_math_after_move</a> (tt::get_fundamental_type_t&lt; ValueType &gt; low=tt::get_fundamental_type_t&lt; ValueType &gt;{-100.0}, tt::get_fundamental_type_t&lt; ValueType &gt; high=tt::get_fundamental_type_t&lt; ValueType &gt;{100.0}) noexcept</td></tr>
<tr class="memdesc:ga1c92dd364b5c10deb51c67a29b1f0749"><td class="mdescLeft">&#160;</td><td class="mdescRight">tests a small sample of math functions after a move of a <code>VectorType</code> initialized with <code>ValueType</code> <br /></td></tr>
<tr class="separator:ga1c92dd364b5c10deb51c67a29b1f0749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga990527392f1401e09d2d9799b1a663a7"><td class="memTemplParams" colspan="2">template&lt;TestKind Test, typename VectorType0 , typename... VectorTypes, typename... FunctionsAndArgumentBounds&gt; </td></tr>
<tr class="memitem:ga990527392f1401e09d2d9799b1a663a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga990527392f1401e09d2d9799b1a663a7">TestHelpers::VectorImpl::test_functions_with_vector_arguments</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FunctionsAndArgumentBounds... &gt; &amp;tuple_of_functions_and_argument_bounds) noexcept</td></tr>
<tr class="memdesc:ga990527392f1401e09d2d9799b1a663a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">General entry function for testing arbitrary math functions on vector types.  <a href="group__TestingFrameworkGroup.html#ga990527392f1401e09d2d9799b1a663a7">More...</a><br /></td></tr>
<tr class="separator:ga990527392f1401e09d2d9799b1a663a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacadb87efe0412015568637a68c678b29"><td class="memTemplParams" colspan="2"><a id="gacadb87efe0412015568637a68c678b29"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gacadb87efe0412015568637a68c678b29"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gacadb87efe0412015568637a68c678b29">are_maps_equal</a> (const Map &amp;map, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Map::dim &gt; &amp;map_base) noexcept</td></tr>
<tr class="memdesc:gacadb87efe0412015568637a68c678b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map and a CoordinateMapBase, checks that the maps are equal by downcasting <code>map_base</code> and then comparing to <code>map</code>. Returns false if the downcast fails. <br /></td></tr>
<tr class="separator:gacadb87efe0412015568637a68c678b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96b4ff568846f3c2fffc4541052b96ec"><td class="memTemplParams" colspan="2"><a id="ga96b4ff568846f3c2fffc4541052b96ec"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga96b4ff568846f3c2fffc4541052b96ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga96b4ff568846f3c2fffc4541052b96ec">check_if_maps_are_equal</a> (const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, VolumeDim &gt; &amp;map_one, const <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, VolumeDim &gt; &amp;map_two, const double time=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::quiet_NaN(), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt;&gt; &amp;functions_of_time={}) noexcept</td></tr>
<tr class="memdesc:ga96b4ff568846f3c2fffc4541052b96ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two coordinate maps (but not their types), check that the maps are equal by evaluating them at a random set of points. <br /></td></tr>
<tr class="separator:ga96b4ff568846f3c2fffc4541052b96ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635824a415e8933aa4f7e7a2ad1ff66a"><td class="memTemplParams" colspan="2"><a id="ga635824a415e8933aa4f7e7a2ad1ff66a"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga635824a415e8933aa4f7e7a2ad1ff66a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga635824a415e8933aa4f7e7a2ad1ff66a">check_if_map_is_identity</a> (const Map &amp;map) noexcept</td></tr>
<tr class="memdesc:ga635824a415e8933aa4f7e7a2ad1ff66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a coordinate map, check that this map is equal to the identity by evaluating the map at a random set of points. <br /></td></tr>
<tr class="separator:ga635824a415e8933aa4f7e7a2ad1ff66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0937cf96cba9ee5da456973fdcf2ac5"><td class="memTemplParams" colspan="2"><a id="gab0937cf96cba9ee5da456973fdcf2ac5"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gab0937cf96cba9ee5da456973fdcf2ac5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gab0937cf96cba9ee5da456973fdcf2ac5">test_jacobian</a> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point) noexcept</td></tr>
<tr class="memdesc:gab0937cf96cba9ee5da456973fdcf2ac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the jacobian gives expected results when compared to the numerical derivative in each direction. <br /></td></tr>
<tr class="separator:gab0937cf96cba9ee5da456973fdcf2ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b3f174791f6db04f4ff6279ccf13454"><td class="memTemplParams" colspan="2"><a id="ga5b3f174791f6db04f4ff6279ccf13454"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga5b3f174791f6db04f4ff6279ccf13454"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga5b3f174791f6db04f4ff6279ccf13454">test_inv_jacobian</a> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point) noexcept</td></tr>
<tr class="memdesc:ga5b3f174791f6db04f4ff6279ccf13454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse jacobian and jacobian multiply together to produce the identity matrix. <br /></td></tr>
<tr class="separator:ga5b3f174791f6db04f4ff6279ccf13454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ada2dd817f0846b4a2177419228a791"><td class="memTemplParams" colspan="2"><a id="ga7ada2dd817f0846b4a2177419228a791"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:ga7ada2dd817f0846b4a2177419228a791"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7ada2dd817f0846b4a2177419228a791">test_frame_velocity</a> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const double time, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt;&gt; &amp;functions_of_time)</td></tr>
<tr class="memdesc:ga7ada2dd817f0846b4a2177419228a791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the frame velocity matches a sixth-order finite difference approximation. <br /></td></tr>
<tr class="separator:ga7ada2dd817f0846b4a2177419228a791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae082371a40e886deb604c05ff87cb435"><td class="memTemplParams" colspan="2"><a id="gae082371a40e886deb604c05ff87cb435"></a>
template&lt;typename Map , typename... Args&gt; </td></tr>
<tr class="memitem:gae082371a40e886deb604c05ff87cb435"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gae082371a40e886deb604c05ff87cb435">test_coordinate_map_implementation</a> (const Map &amp;map) noexcept</td></tr>
<tr class="memdesc:gae082371a40e886deb604c05ff87cb435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the CoordinateMap <code>map</code> functions as expected when used as the template parameter to the <code>CoordinateMap</code> type. <br /></td></tr>
<tr class="separator:gae082371a40e886deb604c05ff87cb435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memTemplParams" colspan="2"><a id="gad2b86f2fe7f836fef3a95233ae9bde7c"></a>
template&lt;typename Map , typename... Args&gt; </td></tr>
<tr class="memitem:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gad2b86f2fe7f836fef3a95233ae9bde7c">test_coordinate_map_argument_types</a> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, Map::dim &gt; &amp;test_point, const Args &amp;... args)</td></tr>
<tr class="memdesc:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the CoordinateMap <code>map</code> functions as expected when used with different argument types. <br /></td></tr>
<tr class="separator:gad2b86f2fe7f836fef3a95233ae9bde7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e156c7ae26ac3d9fedf6b992a5c82e5"><td class="memTemplParams" colspan="2"><a id="ga1e156c7ae26ac3d9fedf6b992a5c82e5"></a>
template&lt;typename Map , typename T &gt; </td></tr>
<tr class="memitem:ga1e156c7ae26ac3d9fedf6b992a5c82e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga1e156c7ae26ac3d9fedf6b992a5c82e5">test_inverse_map</a> (const Map &amp;map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, Map::dim &gt; &amp;test_point) noexcept</td></tr>
<tr class="memdesc:ga1e156c7ae26ac3d9fedf6b992a5c82e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, checks that the inverse map gives expected results. <br /></td></tr>
<tr class="separator:ga1e156c7ae26ac3d9fedf6b992a5c82e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa54f012f3d9b6e12d67d4eb16d2a8fe2"><td class="memTemplParams" colspan="2"><a id="gaa54f012f3d9b6e12d67d4eb16d2a8fe2"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gaa54f012f3d9b6e12d67d4eb16d2a8fe2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaa54f012f3d9b6e12d67d4eb16d2a8fe2">test_suite_for_map_on_unit_cube</a> (const Map &amp;map) noexcept</td></tr>
<tr class="memdesc:gaa54f012f3d9b6e12d67d4eb16d2a8fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, tests the map functions, including map inverse, jacobian, and inverse jacobian, for a series of points. These points are chosen in a dim-dimensonal cube of side 2 centered at the origin. The map is expected to be valid on the boundaries of the cube. <br /></td></tr>
<tr class="separator:gaa54f012f3d9b6e12d67d4eb16d2a8fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf66d8a093671dc1518a3807c4f4e43e1"><td class="memTemplParams" colspan="2"><a id="gaf66d8a093671dc1518a3807c4f4e43e1"></a>
template&lt;typename Map &gt; </td></tr>
<tr class="memitem:gaf66d8a093671dc1518a3807c4f4e43e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaf66d8a093671dc1518a3807c4f4e43e1">test_suite_for_map_on_sphere</a> (const Map &amp;map, const bool include_origin=true, const double radius_of_sphere=1.0) noexcept</td></tr>
<tr class="memdesc:gaf66d8a093671dc1518a3807c4f4e43e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a Map <code>map</code>, tests the map functions, including map inverse, jacobian, and inverse jacobian, for a series of points. These points are chosen in a sphere of radius <code>radius_of_sphere</code>, and the map is expected to be valid on the boundary of that sphere as well as in its interior. The flag <code>include_origin</code> indicates whether to test the map at the origin. This test works only in 3 dimensions. <br /></td></tr>
<tr class="separator:gaf66d8a093671dc1518a3807c4f4e43e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa226fb4e34109bf71af60e2e725ccc7c"><td class="memItemLeft" align="right" valign="top"><a id="gaa226fb4e34109bf71af60e2e725ccc7c"></a>
<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; OrientationMap&lt; 3 &gt;, 6 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gaa226fb4e34109bf71af60e2e725ccc7c">all_wedge_directions</a> () noexcept</td></tr>
<tr class="memdesc:gaa226fb4e34109bf71af60e2e725ccc7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wedge OrientationMap in each of the six directions used in the Shell and Sphere domain creators. <br /></td></tr>
<tr class="separator:gaa226fb4e34109bf71af60e2e725ccc7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4161f44a96cf070dd60267252b2ca1b2"><td class="memTemplParams" colspan="2"><a id="ga4161f44a96cf070dd60267252b2ca1b2"></a>
template&lt;typename System , typename BoundaryCorrection , size_t FaceDim, typename... VolumeTags&gt; </td></tr>
<tr class="memitem:ga4161f44a96cf070dd60267252b2ca1b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga4161f44a96cf070dd60267252b2ca1b2">TestHelpers::evolution::dg::test_boundary_correction_conservation</a> (const BoundaryCorrection &amp;correction, const <a class="el" href="classMesh.html">Mesh</a>&lt; FaceDim &gt; &amp;face_mesh, const <a class="el" href="classtuples_1_1TaggedTuple.html">tuples::TaggedTuple</a>&lt; VolumeTags... &gt; &amp;volume_data, const ZeroOnSmoothSolution zero_on_smooth_solution=ZeroOnSmoothSolution::Yes)</td></tr>
<tr class="memdesc:ga4161f44a96cf070dd60267252b2ca1b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the boundary correction is conservative and that for smooth solutions the strong-form correction is zero. <br /></td></tr>
<tr class="separator:ga4161f44a96cf070dd60267252b2ca1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c7f90b127816337a25b43fb961c004c"><td class="memTemplParams" colspan="2">template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga9c7f90b127816337a25b43fb961c004c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga9c7f90b127816337a25b43fb961c004c">TestHelpers::GeneralizedHarmonic::ConstraintDamping::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; DampingFunctionType &gt; in_gh_damping_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;random_value_bounds, const MemberArgs &amp;... member_args) noexcept</td></tr>
<tr class="memdesc:ga9c7f90b127816337a25b43fb961c004c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a DampingFunction by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga9c7f90b127816337a25b43fb961c004c">More...</a><br /></td></tr>
<tr class="separator:ga9c7f90b127816337a25b43fb961c004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5d2e18354300a7e3fc41b46dd7a14ab"><td class="memTemplParams" colspan="2">template&lt;typename System , typename SolutionType , typename... Maps, typename... FluxesArgs, typename... SourcesArgs&gt; </td></tr>
<tr class="memitem:gae5d2e18354300a7e3fc41b46dd7a14ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#gae5d2e18354300a7e3fc41b46dd7a14ab">FirstOrderEllipticSolutionsTestHelpers::verify_solution</a> (const SolutionType &amp;solution, const typename System::fluxes &amp;fluxes_computer, const <a class="el" href="classMesh.html">Mesh</a>&lt; System::volume_dim &gt; &amp;mesh, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; coord_map, const double tolerance, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FluxesArgs... &gt; &amp;fluxes_args=<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;&gt;{}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; SourcesArgs... &gt; &amp;sources_args=<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;&gt;{})</td></tr>
<tr class="separator:gae5d2e18354300a7e3fc41b46dd7a14ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ae659566b880c7f4fdee6ca53eedd28"><td class="memTemplParams" colspan="2">template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps, typename PackageFluxesArgs &gt; </td></tr>
<tr class="memitem:ga0ae659566b880c7f4fdee6ca53eedd28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga0ae659566b880c7f4fdee6ca53eedd28">FirstOrderEllipticSolutionsTestHelpers::verify_smooth_solution</a> (const SolutionType &amp;solution, const typename System::fluxes &amp;fluxes_computer, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;coord_map, const double tolerance_offset, const double tolerance_scaling, PackageFluxesArgs &amp;&amp;package_fluxes_args)</td></tr>
<tr class="separator:ga0ae659566b880c7f4fdee6ca53eedd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56270746ff55c0378be522f9ba651bf7"><td class="memTemplParams" colspan="2">template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps&gt; </td></tr>
<tr class="memitem:ga56270746ff55c0378be522f9ba651bf7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga56270746ff55c0378be522f9ba651bf7">FirstOrderEllipticSolutionsTestHelpers::verify_solution_with_power_law_convergence</a> (const SolutionType &amp;solution, const typename System::fluxes &amp;fluxes_computer, const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;coord_map, const double tolerance_offset, const double tolerance_pow)</td></tr>
<tr class="separator:ga56270746ff55c0378be522f9ba651bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6992c8619ad085c9e128723f2b79aea5"><td class="memTemplParams" colspan="2">template&lt;typename Solution &gt; </td></tr>
<tr class="memitem:ga6992c8619ad085c9e128723f2b79aea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga6992c8619ad085c9e128723f2b79aea5">verify_grmhd_solution</a> (const Solution &amp;solution, const <a class="el" href="classBlock.html">Block</a>&lt; 3 &gt; &amp;block, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, const double error_tolerance, const double time, const double delta_time) noexcept</td></tr>
<tr class="memdesc:ga6992c8619ad085c9e128723f2b79aea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <code>solution</code> is a solution of the GRMHD equations.  <a href="group__TestingFrameworkGroup.html#ga6992c8619ad085c9e128723f2b79aea5">More...</a><br /></td></tr>
<tr class="separator:ga6992c8619ad085c9e128723f2b79aea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36a219be74fba903e24ef17d3132a2b0"><td class="memTemplParams" colspan="2">template&lt;class EosType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga36a219be74fba903e24ef17d3132a2b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga36a219be74fba903e24ef17d3132a2b0">TestHelpers::EquationsOfState::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; EosType &gt; in_eos, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const MemberArgs &amp;... member_args) noexcept</td></tr>
<tr class="memdesc:ga36a219be74fba903e24ef17d3132a2b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test an equation of state by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga36a219be74fba903e24ef17d3132a2b0">More...</a><br /></td></tr>
<tr class="separator:ga36a219be74fba903e24ef17d3132a2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f2323b41488ff8433e9042f1355820f"><td class="memTemplParams" colspan="2">template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </td></tr>
<tr class="memitem:ga7f2323b41488ff8433e9042f1355820f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TestingFrameworkGroup.html#ga7f2323b41488ff8433e9042f1355820f">TestHelpers::MathFunctions::check</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; MathFunctionType &gt; in_math_function, const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;python_function_prefix, const T &amp;used_for_size, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; random_value_bounds, const MemberArgs &amp;... member_args) noexcept</td></tr>
<tr class="memdesc:ga7f2323b41488ff8433e9042f1355820f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions.  <a href="group__TestingFrameworkGroup.html#ga7f2323b41488ff8433e9042f1355820f">More...</a><br /></td></tr>
<tr class="separator:ga7f2323b41488ff8433e9042f1355820f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Classes, functions, macros, and instructions for developing tests. </p>
<h3>Details</h3>
<p>SpECTRE uses the testing framework <a href="https://github.com/philsquared/Catch">Catch</a>. Catch supports a variety of different styles of tests including BDD and fixture tests. The file <code>cmake/SpectreAddCatchTests.cmake</code> parses the source files and adds the found tests to ctest with the correct properties specified by tags and attributes.</p>
<h3><a class="anchor" id="autotoc_md7"></a>
Usage</h3>
<p>To run the tests, type <code>ctest</code> in the build directory. You can specify a regex to match the test name using <code>ctest -R Unit.Blah</code>, or run all tests with a certain tag using <code>ctest -L tag</code>.</p>
<h3><a class="anchor" id="autotoc_md8"></a>
Comparing double-precision results</h3>
<p>To compare two floating-point numbers that may differ by round-off, use the helper object <code>approx</code>. This is an instance of Catch's comparison class <code>Approx</code> in which the relative tolerance for comparisons is set to roughly \(10^{-14}\) (i.e. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()*100</code>). When possible, we recommend using <code>approx</code> for fuzzy comparisons as follows: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  CHECK(<a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">sin</a>(M_PI / 4.0) == approx(<a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">cos</a>(M_PI / 4.0)));</div>
</div><!-- fragment --><p> For checks that need more control over the precision (e.g. an algorithm in which round-off errors accumulate to a higher level), we recommend using the <code>approx</code> helper with a one-time tolerance adjustment. A comment should explain the reason for the adjustment: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// This check needs tolerance 1e-12 for X reason.</span></div>
<div class="line">  CHECK(1.0 == approx(1.0 + 5e-13).epsilon(1e-12));</div>
</div><!-- fragment --><p> For tests in which the same precision adjustment is re-used many times, a new helper object can be created from Catch's <code>Approx</code> with a custom precision: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// The checks in this test need tolerance 1e-12 for X reason.</span></div>
<div class="line">  Approx my_approx = Approx::custom().epsilon(1e-12);</div>
<div class="line">  CHECK(1.0 == my_approx(1.0 + 5e-13));</div>
<div class="line">  CHECK(1.0 != my_approx(1.0 + 5e-12));</div>
</div><!-- fragment --><p> Note: We provide the <code>approx</code> object because Catch's <code>Approx</code> defaults to a very loose tolerance (<code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;float&gt;::epsilon()*100</code>, or roughly \(10^{-5}\) relative error), and so is poorly-suited to checking many numerical algorithms that rely on double-precision accuracy. By providing a tighter tolerance with <code>approx</code>, we avoid having to redefine the tolerance in every test.</p>
<h3><a class="anchor" id="autotoc_md9"></a>
Attributes</h3>
<p>Attributes allow you to modify properties of the test. Attributes are specified as follows: </p><div class="fragment"><div class="line"><span class="comment">// [[TimeOut, 10]]</span></div>
<div class="line"><span class="comment">// [[OutputRegex, The error message expected from the test]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Blah&quot;</span>, <span class="stringliteral">&quot;[Unit]&quot;</span>) {</div>
</div><!-- fragment --><p>Available attributes are:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description   </th></tr>
<tr>
<td>TimeOut  </td><td>override the default timeout and set the timeout to N seconds. This should be set very sparingly since unit tests are designed to be short. If your test is too long you should consider testing smaller portions of the code if possible, or writing an integration test instead.   </td></tr>
<tr>
<td>OutputRegex  </td><td>When testing failure modes the exact error message must be tested, not just that the test failed. Since the string passed is a regular expression you must escape any regex tokens. For example, to match <code>some (word) and</code> you must specify the string <code>some \(word\) and</code>. If your error message contains a newline, you can match it using the dot operator <code>.</code>, which matches any character.   </td></tr>
</table>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, File &#39;./Unit.IO.H5.FileErrorExists.h5&#39; already exists and we</span></div>
<div class="line"><span class="comment">// are not allowed to append. To reduce the risk of accidental deletion you must</span></div>
<div class="line"><span class="comment">// explicitly delete the file first using the file_system library in</span></div>
<div class="line"><span class="comment">// SpECTRE or through your shell.]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.IO.H5.FileErrorExists&quot;</span>, <span class="stringliteral">&quot;[Unit][IO][H5]&quot;</span>) {</div>
<div class="line">  <a class="code" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a>();</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md10"></a>
Debugging Tests in GDB or LLDB</h3>
<p>Several tests fail intentionally at the executable level to test error handling like ASSERT statements in the code. CTest is aware of which should fail and passes them. If you want to debug an individual test in a debugger you need to run a single test using the RunTests executable (in dg-charm-build/bin/RunTests) you must specify the name of the test as the first argument. For example, if you want to run just the "Unit.Gradient" test you can run <code>./bin/RunTests Unit.Gradient</code>. If you are using a debugger launch the debugger, for example if you're using LLDB then run <code>lldb ./bin/RunTests</code> and then to run the executable inside the debugger use <code>run Unit.Gradient</code> inside the debugger.</p>
<h3>Details</h3>
<p>SpECTRE uses the testing framework <a href="https://github.com/philsquared/Catch">Catch</a>. Catch supports a variety of different styles of tests including BDD and fixture tests. The file <code>cmake/SpectreAddCatchTests.cmake</code> parses the source files and adds the found tests to ctest with the correct properties specified by tags and attributes.</p>
<h3><a class="anchor" id="autotoc_md155"></a>
Usage</h3>
<p>To run the tests, type <code>ctest</code> in the build directory. You can specify a regex to match the test name using <code>ctest -R Unit.Blah</code>, or run all tests with a certain tag using <code>ctest -L tag</code>.</p>
<h3><a class="anchor" id="autotoc_md156"></a>
Comparing double-precision results</h3>
<p>To compare two floating-point numbers that may differ by round-off, use the helper object <code>approx</code>. This is an instance of Catch's comparison class <code>Approx</code> in which the relative tolerance for comparisons is set to roughly \(10^{-14}\) (i.e. <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;double&gt;::epsilon()*100</code>). When possible, we recommend using <code>approx</code> for fuzzy comparisons as follows: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  CHECK(<a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">sin</a>(M_PI / 4.0) == approx(<a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">cos</a>(M_PI / 4.0)));</div>
</div><!-- fragment --><p> For checks that need more control over the precision (e.g. an algorithm in which round-off errors accumulate to a higher level), we recommend using the <code>approx</code> helper with a one-time tolerance adjustment. A comment should explain the reason for the adjustment: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// This check needs tolerance 1e-12 for X reason.</span></div>
<div class="line">  CHECK(1.0 == approx(1.0 + 5e-13).epsilon(1e-12));</div>
</div><!-- fragment --><p> For tests in which the same precision adjustment is re-used many times, a new helper object can be created from Catch's <code>Approx</code> with a custom precision: </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="comment">// The checks in this test need tolerance 1e-12 for X reason.</span></div>
<div class="line">  Approx my_approx = Approx::custom().epsilon(1e-12);</div>
<div class="line">  CHECK(1.0 == my_approx(1.0 + 5e-13));</div>
<div class="line">  CHECK(1.0 != my_approx(1.0 + 5e-12));</div>
</div><!-- fragment --><p> Note: We provide the <code>approx</code> object because Catch's <code>Approx</code> defaults to a very loose tolerance (<code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;float&gt;::epsilon()*100</code>, or roughly \(10^{-5}\) relative error), and so is poorly-suited to checking many numerical algorithms that rely on double-precision accuracy. By providing a tighter tolerance with <code>approx</code>, we avoid having to redefine the tolerance in every test.</p>
<h3><a class="anchor" id="autotoc_md157"></a>
Attributes</h3>
<p>Attributes allow you to modify properties of the test. Attributes are specified as follows: </p><div class="fragment"><div class="line"><span class="comment">// [[TimeOut, 10]]</span></div>
<div class="line"><span class="comment">// [[OutputRegex, The error message expected from the test]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Blah&quot;</span>, <span class="stringliteral">&quot;[Unit]&quot;</span>) {</div>
</div><!-- fragment --><p>Available attributes are:</p>
<table class="doxtable">
<tr>
<th>Attribute </th><th>Description   </th></tr>
<tr>
<td>TimeOut  </td><td>override the default timeout and set the timeout to N seconds. This should be set very sparingly since unit tests are designed to be short. If your test is too long you should consider testing smaller portions of the code if possible, or writing an integration test instead.   </td></tr>
<tr>
<td>OutputRegex  </td><td>When testing failure modes the exact error message must be tested, not just that the test failed. Since the string passed is a regular expression you must escape any regex tokens. For example, to match <code>some (word) and</code> you must specify the string <code>some \(word\) and</code>. If your error message contains a newline, you can match it using the dot operator <code>.</code>, which matches any character.   </td></tr>
</table>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, File &#39;./Unit.IO.H5.FileErrorExists.h5&#39; already exists and we</span></div>
<div class="line"><span class="comment">// are not allowed to append. To reduce the risk of accidental deletion you must</span></div>
<div class="line"><span class="comment">// explicitly delete the file first using the file_system library in</span></div>
<div class="line"><span class="comment">// SpECTRE or through your shell.]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.IO.H5.FileErrorExists&quot;</span>, <span class="stringliteral">&quot;[Unit][IO][H5]&quot;</span>) {</div>
<div class="line">  <a class="code" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a>();</div>
</div><!-- fragment --> <h3><a class="anchor" id="autotoc_md158"></a>
Debugging Tests in GDB or LLDB</h3>
<p>Several tests fail intentionally at the executable level to test error handling like ASSERT statements in the code. CTest is aware of which should fail and passes them. If you want to debug an individual test in a debugger you need to run a single test using the RunTests executable (in dg-charm-build/bin/RunTests) you must specify the name of the test as the first argument. For example, if you want to run just the "Unit.Gradient" test you can run <code>./bin/RunTests Unit.Gradient</code>. If you are using a debugger launch the debugger, for example if you're using LLDB then run <code>lldb ./bin/RunTests</code> and then to run the executable inside the debugger use <code>run Unit.Gradient</code> inside the debugger. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga4439208ed8accb2887ff47388e91e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4439208ed8accb2887ff47388e91e58b">&#9670;&nbsp;</a></span>ASSERTION_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ASSERTION_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                          \</div>
<div class="line">    ERROR_TEST();                                               <a class="code" href="group__ParallelGroup.html#gaccc68e564135958d18110d2847dcc1b3">\</a></div>
<div class="line"><a class="code" href="group__ParallelGroup.html#gaccc68e564135958d18110d2847dcc1b3">    Parallel::abort</a>(<span class="stringliteral">&quot;### No ASSERT tests in release mode ###&quot;</span>); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Mark a test to be checking an ASSERT. </p>
<h3>Details</h3>
<p>Testing error handling is just as important as testing functionality. Tests that are supposed to exit with an error must be annotated with the attribute </p><div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, The regex that should be found in the output]]</span></div>
</div><!-- fragment --><p> Note that the regex only needs to be a sub-expression of the error message, that is, there are implicit wildcards before and after the string.</p>
<p>In order to test ASSERT's properly the test must also fail for release builds. This is done by adding this macro at the beginning for the test.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, Out of range slab fraction]]</span></div>
<div class="line">[[noreturn]] SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Time.Time.Init.0&quot;</span>, <span class="stringliteral">&quot;[Unit][Time]&quot;</span>) {</div>
<div class="line">  <a class="code" href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">ASSERTION_TEST</a>();</div>
<div class="line"><span class="preprocessor">#ifdef SPECTRE_DEBUG</span></div>
<div class="line">  <a class="code" href="classTime.html">Time</a>(<a class="code" href="classSlab.html">Slab</a>(0., 1.), -1);</div>
<div class="line">  <a class="code" href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a>(<span class="stringliteral">&quot;Failed to trigger ASSERT in an assertion test&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga5509fb28c65f22498410618609f8c085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5509fb28c65f22498410618609f8c085">&#9670;&nbsp;</a></span>CHECK_COMPLEX_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_COMPLEX_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                 \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b); \</div>
<div class="line">    CHECK(approx(real(a)) == real(b));                                 \</div>
<div class="line">    CHECK(approx(imag(a)) == imag(b));                                 \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of the two entries in a <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/complex.html">std::complex</a>. For efficiency, no function forwarding is performed, just a pair of <code>CHECK</code>s inline. </p>

</div>
</div>
<a id="ga5527bb2a3aa50f572faae13dfb8783e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5527bb2a3aa50f572faae13dfb8783e5">&#9670;&nbsp;</a></span>CHECK_COMPLEX_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_COMPLEX_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                 \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b); \</div>
<div class="line">    CHECK(appx(real(a)) == real(b));                                   \</div>
<div class="line">    CHECK(appx(imag(a)) == imag(b));                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_COMPLEX_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="ga76e2c6db4f9527f5fea4528d2f2532ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76e2c6db4f9527f5fea4528d2f2532ba">&#9670;&nbsp;</a></span>CHECK_CUSTOM_ELEMENT_WISE_FUNCTION_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_CUSTOM_ELEMENT_WISE_FUNCTION_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arguments, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">at_operator, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size_of_operator&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                           \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) +               \</div>
<div class="line">         <span class="stringliteral">&quot;: &quot;</span> #<span class="keyword">function</span> <span class="stringliteral">&quot;, &quot;</span> #arguments);                        \</div>
<div class="line">    test_element_wise_function(<span class="keyword">function</span>, arguments, at_operator, \</div>
<div class="line">                               size_of_operator);                \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_ELEMENT_WISE_FUNCTION_APPROX</code>, but with a user-defined function <code>at_operator</code> and <code>size_of_operator</code>, each of which correspond to arguments of <code><a class="el" href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09" title="Utility function for verifying the action of an element-wise function on containers,...">test_element_wise_function()</a></code> (which gives a more complete documentation of the element-wise checking operations and arguments). </p>

</div>
</div>
<a id="ga5b08319337a0dd8a83326a33768bbba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b08319337a0dd8a83326a33768bbba0">&#9670;&nbsp;</a></span>CHECK_ELEMENT_WISE_FUNCTION_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ELEMENT_WISE_FUNCTION_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">function, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">arguments&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                          \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) +              \</div>
<div class="line">         <span class="stringliteral">&quot;: &quot;</span> #<span class="keyword">function</span> <span class="stringliteral">&quot;, &quot;</span> #arguments);                       \</div>
<div class="line">    test_element_wise_function(<span class="keyword">function</span>, arguments);            \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A test utility for verifying that an element-wise function, <code>function</code> acts identically to the same operation applied to each element of a container separately. This macro invokes <code><a class="el" href="group__TestingFrameworkGroup.html#gaeae43aecf3e4fb517f2e227f67aa5c09" title="Utility function for verifying the action of an element-wise function on containers,...">test_element_wise_function()</a></code> (which gives a more complete documentation of the element-wise checking operations and arguments). </p>

</div>
</div>
<a id="ga21fcbc0b07905e0d2f8b012b388acd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21fcbc0b07905e0d2f8b012b388acd73">&#9670;&nbsp;</a></span>CHECK_FOR_DOUBLES_AND_DATAVECTORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_FOR_DOUBLES_AND_DATAVECTORS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  CHECK_FOR_DOUBLES(FUNCTION_NAME, __VA_ARGS__)               \</div>
<div class="line">  CHECK_FOR_DATAVECTORS(FUNCTION_NAME, __VA_ARGS__)</div>
</div><!-- fragment -->
<p>Macro used to test functions whose parameter can be a <code>double</code> or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>. </p>
<p>In testing multiple instances of a function template using random values, it often proves useful to write a wrapper around <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code>. This way, one can easily loop over several values of one or multiple template parameters (e.g. when testing a function templated in the number of spacetime dimensions.) The template parameters of the wrapper will then correspond to the template parameters of the function, which will be used by <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code> to invoke and test each instance. Each of these wrappers will generally need only one parameter, namely a variable <code>used_for_size</code> passed to <code><a class="el" href="namespacepypp.html#a796819ebc4f228d875772c6d40cc021a" title="Tests a C++ function returning by value by comparing the result to a python function.">pypp::check_with_random_values</a></code> that can be a <code>double</code>, a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>, or both (provided that the function being tested is templated in the type of <code>used_for_size</code>.) Since this is applied in multiple test files, all of these files will share the same way to generate the required calls to the wrapper.</p>
<p>This macro, along with</p>
<div class="fragment"><div class="line">CHECK_FOR_DOUBLES(FUNCTION_NAME, ...)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">CHECK_FOR_DATAVECTORS(FUNCTION_NAME, ...)</div>
</div><!-- fragment --><p>allow to generate calls to multiple instances of a test function template in the same way as done by <code>INVOKE_TEST_FUNCTION(FUNCTION_NAME, ARGS_TUPLE, ...)</code> (to which these macros call), except that the tuple of arguments is not passed, as these macros will assume that a <code>double</code> <code>d</code> and/or a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> <code>dv</code> will be previously defined. Although any <code>d</code>s and <code>dv</code>s will work, one can (and it is recommended to) generate signaling <code>NaN</code> values for <code>d</code> and <code>dv</code>. This can be done by invoking one of the three provided macros: <code>GENERATE_UNINIATILIZED_DOUBLE</code>, <code>GENERATE_UNINITIALIZED_DATAVECTOR</code>, or <code>GENERATE_UNINITIALIZED_DOUBLE_AND_DATAVECTOR</code>. For example,</p>
<div class="fragment"><div class="line">GENERATE_UNINITIALIZED_DATAVECTOR;</div>
<div class="line">CHECK_FOR_DATAVECTORS(test_fluxes, (1, 2, 3))</div>
</div><!-- fragment --><p>will generate a test case for 1, 2 and 3 dimensions:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDataVector.html">DataVector</a> dv(5);</div>
<div class="line">test_fluxes&lt;1&gt;(dv);</div>
<div class="line">test_fluxes&lt;2&gt;(dv);</div>
<div class="line">test_fluxes&lt;3&gt;(dv);</div>
</div><!-- fragment --><p>Analogously, the wrapper</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> Dim, IndexType TypeOfIndex, <span class="keyword">typename</span> DataType&gt;</div>
<div class="line">test_ricci(<span class="keyword">const</span> DataType&amp; used_for_size) noexcept { ... }</div>
</div><!-- fragment --><p>can be invoked by writing</p>
<div class="fragment"><div class="line">GENERATE_UNINITIALIZED_DOUBLE_AND_DATAVECTOR;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a>(test_ricci, (1, 2, 3),</div>
<div class="line">                                  (<a class="code" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a>, <a class="code" href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a>))</div>
</div><!-- fragment --><p>which will generate</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> d(<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits&lt;double&gt;::signaling_NaN</a>());</div>
<div class="line"><span class="keyword">const</span> <a class="code" href="classDataVector.html">DataVector</a> dv(5);</div>
<div class="line"> </div>
<div class="line">test_ricci&lt;1, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;1, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;2, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;2, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;3, IndexType::Spatial&gt;(d);</div>
<div class="line">test_ricci&lt;3, IndexType::Spacetime&gt;(d);</div>
<div class="line">test_ricci&lt;1, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;1, IndexType::Spacetime&gt;(dv);</div>
<div class="line">test_ricci&lt;2, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;2, IndexType::Spacetime&gt;(dv);</div>
<div class="line">test_ricci&lt;3, IndexType::Spatial&gt;(dv);</div>
<div class="line">test_ricci&lt;3, IndexType::Spacetime&gt;(dv);</div>
</div><!-- fragment --><p>Note that it is not necessary to pass values for <code>DataType</code>, as they are deduced from <code>used_for_size</code>.</p>
<dl class="section note"><dt>Note</dt><dd>The order of the macro-tuples of values must match the order of the template parameters of the function.</dd>
<dd>
The function to be called must at least have one template argument, so passing an empty set of template parameters will not work. </dd></dl>

</div>
</div>
<a id="ga6ce5d669c94418f197e4c55c53e64a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce5d669c94418f197e4c55c53e64a64">&#9670;&nbsp;</a></span>CHECK_ITERABLE_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ITERABLE_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_iterable_approx&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                                \</div>
<div class="line">        std::decay_t&lt;decltype(a)&gt;, <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;decltype(b)&gt;&gt;&gt;::apply(a, b); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of entries in iterable containers. For maplike containers, keys are checked for strict equality and values are checked for approximate equality. </p>

</div>
</div>
<a id="ga4f36d1ee34e6eb0721e35918eb488f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f36d1ee34e6eb0721e35918eb488f0c">&#9670;&nbsp;</a></span>CHECK_ITERABLE_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_ITERABLE_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_iterable_approx&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                                \</div>
<div class="line">        std::decay_t&lt;decltype(a)&gt;, <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;decltype(b)&gt;&gt;&gt;::apply(a, b,  \</div>
<div class="line">                                                                      appx); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_ITERABLE_APPROX</code> with user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="gaec8dcdc783140fb14fe617cc0cc1dcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8dcdc783140fb14fe617cc0cc1dcae">&#9670;&nbsp;</a></span>CHECK_OP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_OP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                          \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; a_ = a;         \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; b_ = b;         \</div>
<div class="line">    const <span class="keyword">auto</span>&amp; c_ = c;         \</div>
<div class="line">    CHECK(a_ op b_ == c_);      \</div>
<div class="line">    auto f = a_;                \</div>
<div class="line">    CHECK((f op## = b_) == c_); \</div>
<div class="line">    CHECK(f == c_);             \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Check a op b == c and also the op= version. </p>

</div>
</div>
<a id="ga447b43fced460461e76beca1a28fc273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447b43fced460461e76beca1a28fc273">&#9670;&nbsp;</a></span>CHECK_VARIABLES_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_VARIABLES_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_variables_approx&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                               \</div>
<div class="line">        std::decay_t&lt;decltype(a)&gt;, <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;decltype(b)&gt;&gt;&gt;::apply(a, b); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A wrapper around Catch's CHECK macro that checks approximate equality of each entry in each tag within a variables. </p>

</div>
</div>
<a id="ga6553c686d7f6b55372814227d1542272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6553c686d7f6b55372814227d1542272">&#9670;&nbsp;</a></span>CHECK_VARIABLES_CUSTOM_APPROX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_VARIABLES_CUSTOM_APPROX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">appx&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                       \</div>
<div class="line">    INFO(__FILE__ <span class="stringliteral">&quot;:&quot;</span> + std::to_string(__LINE__) + <span class="stringliteral">&quot;: &quot;</span> #a <span class="stringliteral">&quot; == &quot;</span> #b);       \</div>
<div class="line">    check_variables_approx&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a>&lt;                               \</div>
<div class="line">        std::decay_t&lt;decltype(a)&gt;, <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt;decltype(b)&gt;&gt;&gt;::apply(a, b,  \</div>
<div class="line">                                                                      appx); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Same as <code>CHECK_VARIABLES_APPROX</code>, but with a user-defined Approx. The third argument should be of type <code>Approx</code>. </p>

</div>
</div>
<a id="gaf962c28abc1a1f014f2a6b32c6f01680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf962c28abc1a1f014f2a6b32c6f01680">&#9670;&nbsp;</a></span>ERROR_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ERROR_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                    \</div>
<div class="line">    std::signal(SIGABRT, spectre_testing_signal_handler); \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Mark a test as checking a call to ERROR. </p>
<h3>Details</h3>
<p>In order to properly handle aborting with Catch versions newer than 1.6.1 we must install a signal handler after Catch does, which means inside the SPECTRE_TEST_CASE itself. The <a class="el" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680" title="Mark a test as checking a call to ERROR.">ERROR_TEST()</a> macro should be the first line in the SPECTRE_TEST_CASE.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, Testing error]]</span></div>
<div class="line">[[noreturn]] SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.ErrorHandling.Error&quot;</span>,</div>
<div class="line">                               <span class="stringliteral">&quot;[Unit][ErrorHandling]&quot;</span>) {</div>
<div class="line">  <a class="code" href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a>();</div>
<div class="line">  <a class="code" href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a>(<span class="stringliteral">&quot;Testing error&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga8cd2549e4a5627f34f8201af2bcbfd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cd2549e4a5627f34f8201af2bcbfd34">&#9670;&nbsp;</a></span>INVOKE_TEST_FUNCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVOKE_TEST_FUNCTION</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">FUNCTION_NAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TUPLE_ARGS, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  BOOST_PP_ASSERT_MSG(BOOST_PP_NOT(BOOST_VMD_IS_EMPTY(__VA_ARGS__)),           \</div>
<div class="line">                      <span class="stringliteral">&quot;You cannot pass an empty set of template parameters &quot;</span>   \</div>
<div class="line">                      <span class="stringliteral">&quot;to INVOKE_TEST_FUNCTION&quot;</span>)                               \</div>
<div class="line">  BOOST_PP_TUPLE_ENUM(                                                         \</div>
<div class="line">      0,                                                                       \</div>
<div class="line">      BOOST_PP_IF(                                                             \</div>
<div class="line">          BOOST_PP_EQUAL(                                                      \</div>
<div class="line">              BOOST_PP_TUPLE_SIZE(BOOST_PP_VARIADIC_TO_TUPLE(__VA_ARGS__)),    \</div>
<div class="line">              1),                                                              \</div>
<div class="line">          (BOOST_PP_LIST_FOR_EACH(                                             \</div>
<div class="line">              INVOKE_FUNCTION_WITH_SINGLE_TEMPLATE_PARAM,                      \</div>
<div class="line">              (FUNCTION_NAME, TUPLE_ARGS),                                     \</div>
<div class="line">              BOOST_PP_TUPLE_TO_LIST(                                          \</div>
<div class="line">                  BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__)))),                   \</div>
<div class="line">          (INVOKE_FUNCTION_WITH_MANY_TEMPLATE_PARAMS(                          \</div>
<div class="line">              BOOST_PP_TUPLE_PUSH_FRONT(                                       \</div>
<div class="line">                  BOOST_PP_LIST_TO_TUPLE(BOOST_PP_LIST_TRANSFORM(              \</div>
<div class="line">                      INVOKE_FUNCTION_WITH_MANY_TEMPLATE_PARAMS_TUPLE_TO_LIST, \</div>
<div class="line">                      _,                                                       \</div>
<div class="line">                      BOOST_PP_LIST_REST(                                      \</div>
<div class="line">                          BOOST_PP_VARIADIC_TO_LIST(__VA_ARGS__)))),           \</div>
<div class="line">                  BOOST_PP_LIST_TRANSFORM(                                     \</div>
<div class="line">                      INVOKE_FUNCTION_TUPLE_PUSH_BACK,                         \</div>
<div class="line">                      (FUNCTION_NAME, TUPLE_ARGS),                             \</div>
<div class="line">                      BOOST_PP_TUPLE_TO_LIST(                                  \</div>
<div class="line">                          BOOST_PP_VARIADIC_ELEM(0, __VA_ARGS__))))))))</div>
</div><!-- fragment -->
<p>Macro used to invoke a test function of multiple template arguments. </p>
<p>This macro allows to generate calls to multiple instances of a test function template, all of which will receive the same parameters. The first argument to this macro is the name of the function. The second argument is a macro-tuple containing the parameters passed to each instance, e.g. <code>(x, y)</code>. The remaining arguments are macro-tuples of the values for each template parameter one wants to loop over, e.g. <code>(1, 2, 3), (<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, <a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a>)</code>. For example, a function template</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Arg1, <span class="keywordtype">size_t</span> Arg2, <span class="keyword">class</span> Arg3&gt;</div>
<div class="line">my_function(<span class="keyword">const</span> <span class="keywordtype">double</span> var_1, <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; var_2) noexcept { ... }</div>
</div><!-- fragment --><p>can be invoked by writing</p>
<div class="fragment"><div class="line"><a class="code" href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a>(my_function, (d, i), (a, b, c), (1, 2, 3), (A, B, C))</div>
</div><!-- fragment --><p>which will generate</p>
<div class="fragment"><div class="line">my_function&lt;a, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;a, 3, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;b, 3, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 1, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 2, C&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, A&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, B&gt;(d, i);</div>
<div class="line">my_function&lt;c, 3, C&gt;(d, i);</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The order of the macro-tuples of values must match the order of the template parameters of the function.</dd>
<dd>
The function to be called must at least have one template argument, so passing an empty set of template parameters will not work. </dd></dl>

</div>
</div>
<a id="gad7f766439113f958bf4f8ba0f53c4881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f766439113f958bf4f8ba0f53c4881">&#9670;&nbsp;</a></span>MAKE_GENERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAKE_GENERATOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> MAKE_GENERATOR_IMPL_FIRST_ARG(__VA_ARGS__, DUMMY_TOKEN); \</div>
<div class="line">  <span class="comment">/* Capture everything because we don&#39;t know what passed seed uses */</span>  \</div>
<div class="line">  INFO(<span class="stringliteral">&quot;Seed is: &quot;</span> &lt;&lt; [&amp;]() noexcept {                                  \</div>
<div class="line">    const <span class="keyword">auto</span> MAKE_GENERATOR_seed = (MAKE_GENERATOR_IMPL_SECOND_ARG(   \</div>
<div class="line">        __VA_ARGS__, <a class="codeRef" href="http://en.cppreference.com/w/cpp/numeric/random/random_device.html">std::random_device</a>{}(), DUMMY_TOKEN));             \</div>
<div class="line">    MAKE_GENERATOR_IMPL_FIRST_ARG(__VA_ARGS__, DUMMY_TOKEN)             \</div>
<div class="line">        .seed(MAKE_GENERATOR_seed);                                     \</div>
<div class="line">    return <a class="code" href="classMakeString.html">MakeString</a>{} &lt;&lt; MAKE_GENERATOR_seed &lt;&lt; <span class="stringliteral">&quot; from &quot;</span> __FILE__ <span class="stringliteral">&quot;:&quot;</span> \</div>
<div class="line">                        &lt;&lt; __LINE__;                                    \</div>
<div class="line">  }())</div>
</div><!-- fragment -->
<p><code><a class="el" href="group__TestingFrameworkGroup.html#gad7f766439113f958bf4f8ba0f53c4881" title="MAKE_GENERATOR(NAME [, SEED]) declares a variable of name NAME containing a generator of type std::mt...">MAKE_GENERATOR(NAME [, SEED])</a></code> declares a variable of name <code>NAME</code> containing a generator of type <code><a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></code>. </p>
<h3>Details</h3>
<p>As the generator is made, <code>INFO</code> is called to make sure failed tests provide seed information. <code>SEED</code> is chosen randomly if not supplied, otherwise it must be a constant expression. </p>

</div>
</div>
<a id="gacd515a98a97cf7fc82e722274b17e7ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd515a98a97cf7fc82e722274b17e7ce">&#9670;&nbsp;</a></span>OUTPUT_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OUTPUT_TEST</td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                \</div>
<div class="line">    CHECK(<span class="keyword">true</span>);      \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>Mark a test as checking the output with a regular expression. </p>
<h3>Details</h3>
<p>The <a class="el" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce" title="Mark a test as checking the output with a regular expression.">OUTPUT_TEST()</a> macro should be the first line in the SPECTRE_TEST_CASE. Catch requires at least one CHECK in each test to pass, so we add one in case nothing but the output is checked.</p>
<h3>Example</h3>
<div class="fragment"><div class="line"><span class="comment">// [[OutputRegex, -100 3000000000 1.0000000000000000000e\+00 \(0,4,8,-7\) test 1</span></div>
<div class="line"><span class="comment">// 2 3 abf a o e u Value 2]]</span></div>
<div class="line">SPECTRE_TEST_CASE(<span class="stringliteral">&quot;Unit.Parallel.printf&quot;</span>, <span class="stringliteral">&quot;[Unit][Parallel]&quot;</span>) {</div>
<div class="line">  <a class="code" href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a>();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span> c_string0[40] = {<span class="stringliteral">&quot;test 1 2 3&quot;</span>};</div>
<div class="line">  <span class="keyword">auto</span>* c_string1 = <span class="keyword">new</span> <span class="keywordtype">char</span>[80];</div>
<div class="line">  <span class="comment">// clang-tidy: do not use pointer arithmetic</span></div>
<div class="line">  c_string1[0] = <span class="charliteral">&#39;a&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[1] = <span class="charliteral">&#39;b&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[2] = <span class="charliteral">&#39;f&#39;</span>;   <span class="comment">// NOLINT</span></div>
<div class="line">  c_string1[3] = <span class="charliteral">&#39;\0&#39;</span>;  <span class="comment">// NOLINT</span></div>
<div class="line">  constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> c_string2 = {<span class="stringliteral">&quot;a o e u&quot;</span>};</div>
<div class="line">  <a class="code" href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a>(<span class="stringliteral">&quot;%d %lld %s %s %s %s %s\n&quot;</span>, -100, 3000000000, TestStream{},</div>
<div class="line">                   c_string0, c_string1, c_string2, TestEnum::Value2);</div>
<div class="line">  <span class="keyword">delete</span>[] c_string1;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga37fce1ae5980139598815eda5a5de8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fce1ae5980139598815eda5a5de8ab">&#9670;&nbsp;</a></span>SPECTRE_PARALLEL_REQUIRE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_PARALLEL_REQUIRE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">    if (not(expr)) {                                                    \</div>
<div class="line">      ERROR(<span class="stringliteral">&quot;\nFailed comparison: &quot;</span> &lt;&lt; #expr &lt;&lt; <span class="stringliteral">&quot;\nLine: &quot;</span> &lt;&lt; __LINE__  \</div>
<div class="line">                                    &lt;&lt; <span class="stringliteral">&quot;\nFile: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>); \</div>
<div class="line">    }                                                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A similar to Catch's REQUIRE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares. </p>

</div>
</div>
<a id="ga2adb81ed48c421e8f77541f34eb3f821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2adb81ed48c421e8f77541f34eb3f821">&#9670;&nbsp;</a></span>SPECTRE_PARALLEL_REQUIRE_FALSE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPECTRE_PARALLEL_REQUIRE_FALSE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <span class="keywordflow">do</span> {                                                                  \</div>
<div class="line">    if ((expr)) {                                                       \</div>
<div class="line">      ERROR(<span class="stringliteral">&quot;\nFailed comparison: &quot;</span> &lt;&lt; #expr &lt;&lt; <span class="stringliteral">&quot;\nLine: &quot;</span> &lt;&lt; __LINE__  \</div>
<div class="line">                                    &lt;&lt; <span class="stringliteral">&quot;\nFile: &quot;</span> &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>); \</div>
<div class="line">    }                                                                   \</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">false</span>)</div>
</div><!-- fragment -->
<p>A similar to Catch's REQUIRE_FALSE statement, but can be used in tests that spawn several chares with possibly complex interaction between the chares. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga921a5dbf5f1704e2051d1daf593d0d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga921a5dbf5f1704e2051d1daf593d0d90">&#9670;&nbsp;</a></span>TestKind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__TestingFrameworkGroup.html#ga921a5dbf5f1704e2051d1daf593d0d90">TestHelpers::VectorImpl::TestKind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the set of test types that may be used for the math operations </p>
<h3>Details</h3>
<p>Three types of test are provided:</p><ul>
<li><code>Normal</code> is used to indicate those tests which should be performed over all combinations of the supplied vector type(s) and their value types. This is useful for e.g. <code>+</code>.</li>
<li><code>Strict</code> is used to indicate those tests which should be performed over only sets of the vector type and compared to the same operation of the set of its value type. This is useful for e.g. <code>atan2</code>, which cannot take a <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code> and a double as arguments.</li>
<li><code>Inplace</code> is used to indicate those tests which should be performed maintaining the type of the left-hand side of the operator and not including it in the combinations. Inplace operators such as <code>+=</code> have a more restrictive condition on the type of the left hand side than do simply <code>+</code>. (e.g. <code>double + complex&lt;double&gt;</code> compiles, but <code>double += complex&lt;double&gt;</code> does not)</li>
<li><code>GivenOrderOfArgumentsOnly</code> is used to indicate that the arguments given should not be taken in any combination apart from the given combination. This should be used for highly restrictive operations which are only supported for certain type combinations. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9c7f90b127816337a25b43fb961c004c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c7f90b127816337a25b43fb961c004c">&#9670;&nbsp;</a></span>check() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DampingFunctionType , class T , class... MemberArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::GeneralizedHarmonic::ConstraintDamping::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; DampingFunctionType &gt;&#160;</td>
          <td class="paramname"><em>in_gh_damping_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test a DampingFunction by comparing to python functions. </p>
<p>The python functions must be added to TestFunctions.py in tests/Unit/Evolution/Systems/GeneralizedHarmonic/ConstraintDamping/Python. Each python function for a corresponding DampingFunction should begin with a prefix <code>python_function_prefix</code>. The prefix for each class of DampingFunction is arbitrary, but should generally be descriptive (e.g. 'gaussian_plus_constant') of the DampingFunction.</p>
<p>If a DampingFunction class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga36a219be74fba903e24ef17d3132a2b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36a219be74fba903e24ef17d3132a2b0">&#9670;&nbsp;</a></span>check() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class EosType , class T , class... MemberArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::EquationsOfState::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; EosType &gt;&#160;</td>
          <td class="paramname"><em>in_eos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test an equation of state by comparing to python functions. </p>
<p>The python functions must be added to tests/Unit/PointwiseFunctions/Hydro/EquationsOfState/TestFunctions.py. The prefix for each class of equation of state is arbitrary, but should generally be something like "polytropic" for polytropic fluids.</p>
<p>The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If an EoS class has member variables (these must be <code>double</code>s currently) that are used to compute the quantities, such as the polytropic constant and polytropic exponent for a fluid, then they must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga7f2323b41488ff8433e9042f1355820f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f2323b41488ff8433e9042f1355820f">&#9670;&nbsp;</a></span>check() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MathFunctionType , class T , class... MemberArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::MathFunctions::check </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; MathFunctionType &gt;&#160;</td>
          <td class="paramname"><em>in_math_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>python_function_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/pair.html">std::pair</a>&lt; double, double &gt;, 1 &gt;&#160;</td>
          <td class="paramname"><em>random_value_bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MemberArgs &amp;...&#160;</td>
          <td class="paramname"><em>member_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test a <a class="el" href="classMathFunction.html">MathFunction</a> by comparing to python functions. </p>
<p>The python functions must be added to tests/Unit/PointwiseFunctions/MathFunctions/Python/TestFunctions.py. The prefix for each class of <a class="el" href="classMathFunction.html">MathFunction</a> is arbitrary, but should generally be descriptive (e.g. 'gaussian', 'sinusoid', 'pow_x') of the <a class="el" href="classMathFunction.html">MathFunction</a>.</p>
<p>The <code>python_function_prefix</code> argument passed to <code>check</code> must be <code>PREFIX</code>. If a <a class="el" href="classMathFunction.html">MathFunction</a> class has member variables set by its constructor, then these member variables must be passed in as the last arguments to the <code>check</code> function`. Each python function must take these same arguments as the trailing arguments. </p>

</div>
</div>
<a id="ga7ca38c64038e6122e91175f573686382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ca38c64038e6122e91175f573686382">&#9670;&nbsp;</a></span>extrinsic_curvature_sphere()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; TestHelpers::Minkowski::extrinsic_curvature_sphere </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extrinsic curvature of 2D sphere in 3D flat space. </p>
<h3>Details</h3>
<p>Computes \(K_{ij} = \frac{1}{r}\left(\delta_{ij} - \frac{x_i x_j}{r}\right),\) where \(r = x_i x_j \delta^{ij}\) and \(x_i\) is the position vector in Cartesian coordinates. </p>

</div>
</div>
<a id="gab6212a4bc03b660f649d3645742908ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6212a4bc03b660f649d3645742908ec">&#9670;&nbsp;</a></span>horizon_ricci_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; TestHelpers::Kerr::horizon_ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>horizon_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>dimensionless_spin_z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kerr (Kerr-Schild) horizon ricci scalar (spin on z axis) </p>
<h3>Details</h3>
<p>Computes the 2-dimensional Ricci scalar \(R\) on the horizon of a Kerr-Schild black hole with spin in the z direction in terms of mass <code>mass</code> and dimensionless spin <code>dimensionless_spin_z</code>. </p>

</div>
</div>
<a id="ga52ce3f988fc45ef28c91b0b742f3c805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52ce3f988fc45ef28c91b0b742f3c805">&#9670;&nbsp;</a></span>horizon_ricci_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt;DataType&gt; TestHelpers::Kerr::horizon_ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>horizon_radius_with_spin_on_z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classYlmSpherepack.html">YlmSpherepack</a> &amp;&#160;</td>
          <td class="paramname"><em>ylm_with_spin_on_z_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classYlmSpherepack.html">YlmSpherepack</a> &amp;&#160;</td>
          <td class="paramname"><em>ylm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimensionless_spin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Kerr (Kerr-Schild) horizon ricci scalar (generic spin) </p>
<h3>Details</h3>
<p>Computes the 2-dimensional Ricci scalar \(R\) on the horizon of a Kerr-Schild black hole with generic spin in terms of mass <code>mass</code> and dimensionless spin <code>dimensionless_spin</code>. </p>

</div>
</div>
<a id="ga67a7537d548219483eb98017cf8cd1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67a7537d548219483eb98017cf8cd1bd">&#9670;&nbsp;</a></span>make_random_vector_in_magnitude_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, UpLo Ul, typename Fr  = Frame::Inertial, Requires&lt;(Ul==UpLo::Up)&gt;  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;DataType, Dim, Fr&gt; make_random_vector_in_magnitude_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>nn_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::ii&lt; DataType, Dim, Fr &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a spatial vector in a given magnitude range. </p>
<p>The magnitude is computed with respect to the given metric, where the metric is assumed to have positive signature. </p>

</div>
</div>
<a id="ga20a4744720b4c6627e920591154e58e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga20a4744720b4c6627e920591154e58e8">&#9670;&nbsp;</a></span>make_random_vector_in_magnitude_range_flat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , size_t Dim, UpLo Ul, typename Fr  = Frame::Inertial, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tensor&lt;DataType, <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9">Symmetry</a>&lt;1&gt;, index_list&lt;<a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt;Dim, Ul, Fr&gt; &gt; &gt; make_random_vector_in_magnitude_range_flat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a> * &gt;&#160;</td>
          <td class="paramname"><em>nn_generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>min_magnitude</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>max_magnitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a spatial vector in a given magnitude range. </p>
<p>The magnitude is computed with respect to the flat space Euclidian metric. </p>

</div>
</div>
<a id="ga1dba8563c3916477bc9dd6ca7cadc5e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1dba8563c3916477bc9dd6ca7cadc5e2">&#9670;&nbsp;</a></span>make_with_random_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T make_with_random_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt;&#160;</td>
          <td class="paramname"><em>distribution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a fixed-size data structure and fill with random values. </p>
<h3>Details</h3>
<p>Given a template argument type <code>T</code>, create an object of the same type, fills it with random values, and returns the result. Acts as a convenience function to avoid users needing to put in constructors with <code>signaling_NaN()</code>s or <code>max()</code>s themselves when making with random values. Used as <code>make_with_random_values&lt;Type&gt;(make_not_null(&amp;gen),make_not_null(&amp;dist))</code> </p>

</div>
</div>
<a id="ga7f98af1ba7b65811cf35536db6259f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f98af1ba7b65811cf35536db6259f88">&#9670;&nbsp;</a></span>make_with_random_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType , typename T , typename UniformRandomBitGenerator , typename RandomNumberDistribution &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ReturnType make_with_random_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; UniformRandomBitGenerator * &gt;&#160;</td>
          <td class="paramname"><em>generator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; RandomNumberDistribution * &gt;&#160;</td>
          <td class="paramname"><em>distribution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>used_for_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a data structure and fill it with random values. </p>
<h3>Details</h3>
<p>Given an object of type <code>T</code>, create an object of type <code>ReturnType</code> whose elements are initialized to random values using the given random number generator and random number distribution.</p>
<p><em>Requires:</em> the type <code>ReturnType</code> to be creatable using <code>make_with_value&lt;ReturnType&gt;(T)</code> </p>

</div>
</div>
<a id="ga6a70d3bd416e878e8b9d9a783bfb60da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a70d3bd416e878e8b9d9a783bfb60da">&#9670;&nbsp;</a></span>numerical_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Invocable , size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/result_of.html">std::result_of_t</a>&lt;const Invocable&amp;(const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, VolumeDim&gt;&amp;)&gt; numerical_derivative </td>
          <td>(</td>
          <td class="paramtype">const Invocable &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the derivative of an Invocable at a point x - represented by an array of doubles - in the domain of <code>map</code> with a sixth-order finite difference method. </p>
<h3>Details</h3>
<p>Intended for use with CoordinateMaps taking the domain {xi,eta,zeta} to the range {x,y,z}. This function calculates the derivative along the direction given by <code>direction</code> with a step size of <code>h</code>.</p>
<p><em>Requires:</em> direction be between 0 and VolumeDim </p>

</div>
</div>
<a id="gabb0dc19cfba9f7aa3f3637b9a99c23fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb0dc19cfba9f7aa3f3637b9a99c23fc">&#9670;&nbsp;</a></span>spatial_ricci()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t SpatialDim, typename Frame , typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::ii&lt;DataType, SpatialDim, Frame&gt; TestHelpers::Schwarzschild::spatial_ricci </td>
          <td>(</td>
          <td class="paramtype">const tnsr::I&lt; DataType, SpatialDim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mass</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Schwarzschild (Kerr-Schild) spatial ricci tensor. </p>
<h3>Details</h3>
<p>Computes \(R_{ij} = M \frac{r^2(4M+r)\delta_{ij}-(8M+3r)x_i x_j} {r^4(2M+r^2)},\) where \(r = x_i x_j \delta^{ij}\), \(x_i\) is the position vector in Cartesian coordinates, and M is the mass. </p>

</div>
</div>
<a id="ga45d562728baabd57a5b2b316799c81d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45d562728baabd57a5b2b316799c81d2">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the computed tensor multi-index of a rank 0 RHS Tensor is equivalent to the given LHS tensor multi-index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73b62147bba9348939dbb9c375094f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73b62147bba9348939dbb9c375094f55">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>tensorindex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexType</td><td>the Tensors' <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Valence</td><td>the valence of the Tensors' index </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex</td><td>the <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti_a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c751f2fde92620756ee845bc1e48eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c751f2fde92620756ee845bc1e48eca">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_1_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename TensorIndexTypeList , typename TensorIndex &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_1_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTensorIndex.html">TensorIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>tensorindex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the computed tensor multi-index of a rank 1 RHS Tensor is equivalent to the given LHS tensor multi-index. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeList</td><td>the Tensors' typelist containing their <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex</td><td>the <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti_a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1670f549d38a3d2af0f43894de3ae270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1670f549d38a3d2af0f43894de3ae270">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_2_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_impl </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the computed tensor multi-index of a rank 2 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b), the possible orderings of the LHS tensor's generic indices are: (a, b) and (b, a). For each of these cases, this test checks that for each LHS component's tensor multi-index, the equivalent RHS tensor multi-index is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gababb2ef1c0dd7992dba36d41474e8284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gababb2ef1c0dd7992dba36d41474e8284">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_2_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceA, UpLo ValenceB, typename TensorIndexA , typename TensorIndexB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_no_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>Note: <code>test_compute_rhs_tensor_index_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2855d4c7ca4088ac85003e52d7ea0a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2855d4c7ca4088ac85003e52d7ea0a81">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_2_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndexA , typename TensorIndexB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_2_symmetric </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>Note: <code>test_compute_rhs_tensor_index_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73d49183ca01d4aa77ebb8c0a468ec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73d49183ca01d4aa77ebb8c0a468ec8b">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_ab_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceAB, UpLo ValenceC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_ab_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_compute_rhs_tensor_index_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf020b0f3583daaa1db79ead423062c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf020b0f3583daaa1db79ead423062c36">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_abc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_abc_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_compute_rhs_tensor_index_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga95331287c4f51ca32a12d7ccfa581dd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95331287c4f51ca32a12d7ccfa581dd2">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_ac_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAC, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceAC, UpLo ValenceB, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_ac_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_compute_rhs_tensor_index_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga556258cbddbda45f2080c9a3edac5c51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga556258cbddbda45f2080c9a3edac5c51">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_bc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeBC, UpLo ValenceA, UpLo ValenceBC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_bc_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_compute_rhs_tensor_index_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f22d7b7c6ea08d936220835ab3a4cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f22d7b7c6ea08d936220835ab3a4cfd">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_impl </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the computed tensor multi-index of a rank 3 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b, c), the possible orderings of the LHS tensor's generic indices are: (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), and (c, b, a). For each of these cases, this test checks that for each LHS component's tensor multi-index, the equivalent RHS tensor multi-index is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0cb98e7f1ae3f5a7a34d82c5bf8e42de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cb98e7f1ae3f5a7a34d82c5bf8e42de">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_3_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceA, UpLo ValenceB, UpLo ValenceC, typename TensorIndexA , typename TensorIndexB , typename TensorIndexC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_3_no_symmetry </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of computing the RHS tensor multi-index equivalent of the LHS tensor multi-index with rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations for nonsymmetric indices. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_compute_rhs_tensor_index_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_compute_rhs_tensor_index_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56d6f3035dbb8f8329915530c354f528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56d6f3035dbb8f8329915530c354f528">&#9670;&nbsp;</a></span>test_compute_rhs_tensor_index_rank_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , typename TensorIndexA , typename TensorIndexB , typename TensorIndexC , typename TensorIndexD &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_compute_rhs_tensor_index_rank_4 </td>
          <td>(</td>
          <td class="paramtype">const TensorIndexA &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexB &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexC &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorIndexD &amp;&#160;</td>
          <td class="paramname"><em>tensorindex_d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that the computed tensor multi-index of a rank 4 RHS Tensor is equivalent to the given LHS tensor multi-index, according to the order of their generic indices. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, <code>TensorIndexC</code>, and <code>TensorIndexD</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, <code>ti_c</code>, and <code>ti_d</code>. The "A", "B", "C", and "D" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, <code>TensorIndexC</code> is the third index used, and <code>TensorIndexD</code> is the fourth index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b, c, d), there are 24 permutations that are possible orderings of the LHS tensor's generic indices, such as: (a, b, c, d), e.g. (a, b, d, c), (a, c, b, d), etc. For each of these cases, this test checks that for each LHS component's tensor multi-index, the equivalent RHS tensor multi-index is correctly computed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tensorindex_a</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">tensorindex_b</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">tensorindex_c</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
    <tr><td class="paramname">tensorindex_d</td><td>the fourth <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_D</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad70e9824d819da51327073cce20f25f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad70e9824d819da51327073cce20f25f1">&#9670;&nbsp;</a></span>test_creation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename OptionTag  = TestCreationOpt&lt;T&gt;, typename Metavariables  = NoSuchType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T TestHelpers::test_creation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct an object or enum from a given string.</p>
<p>When creating a non-enum option the string must not contain the name of the option (specifically, the struct being created from options, which is the name of the struct by default if no <code>name()</code> function is present). For example, to create a struct named <code>ClassWithoutMetavariables</code> with an option tag named <code>SizeT</code> the following would be used:</p>
<div class="fragment"><div class="line">  CHECK(</div>
<div class="line">      TestHelpers::test_creation&lt;ClassWithoutMetavariables&gt;(<span class="stringliteral">&quot;SizeT: 7&quot;</span>).value ==</div>
<div class="line">      7);</div>
</div><!-- fragment --><p> When creating an enum option the string must not contain the name of the enum being constructed. The following is an example of an enum named <code>Color</code> with a member <code>Purple</code> being created from options.</p>
<div class="fragment"><div class="line">  CHECK(TestHelpers::test_creation&lt;Color&gt;(<span class="stringliteral">&quot;Purple&quot;</span>) == Color::Purple);</div>
</div><!-- fragment --><p> Option tags can be tested by passing them as the second template parameter. If the metavariables are required to create the class then the metavariables must be passed as the third template parameter. The default option tag is <code><a class="el" href="structTestHelpers_1_1TestCreationOpt.html">TestCreationOpt</a>&lt;T&gt;</code>. </p>

</div>
</div>
<a id="gaeae43aecf3e4fb517f2e227f67aa5c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeae43aecf3e4fb517f2e227f67aa5c09">&#9670;&nbsp;</a></span>test_element_wise_function()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementWiseFunction , typename AtFunction  = GetContainerElement, typename SizeFunction  = GetContainerSize, typename... Arguments&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void test_element_wise_function </td>
          <td>(</td>
          <td class="paramtype">ElementWiseFunction&#160;</td>
          <td class="paramname"><em>element_wise_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; Arguments... &gt; * &gt;&#160;</td>
          <td class="paramname"><em>arguments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AtFunction&#160;</td>
          <td class="paramname"><em>at</em> = <code><a class="el" href="structGetContainerElement.html">GetContainerElement</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeFunction&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="structGetContainerSize.html">GetContainerSize</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Approx&#160;</td>
          <td class="paramname"><em>custom_approx</em> = <code>approx</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for verifying the action of an element-wise function on containers, or on some combination of containers and compatible non-containers (e.g. <code>DataVectors</code> with <code>doubles</code>). </p>
<h3>Details</h3>
<p>The ability to specify custom functions for <code>at</code> and <code>size</code> is useful for more intricate containers. For instance, multidimensional types can be used with this function with a size function that returns the full number of elements, and an <code>at</code> function which indexes the multidimensional type in a flattened fashion.</p>
<p>parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element_wise_function</td><td>A callable which is expected to act in an element-wise fashion, must be compatible both with the container and its individual elements. </td></tr>
    <tr><td class="paramname">arguments</td><td>A tuple of arguments to be tested </td></tr>
    <tr><td class="paramname">at</td><td>A function to override the container access function. Defaults to an object which simply calls <code>container.at(i)</code>. A custom callable must take as arguments the container(s) used in <code>arguments</code> and a <code>size_t</code> index (in that order), and return an element compatible with <code>element_wise_function</code>. This function signature follows the convention of <code><a class="el" href="group__UtilitiesGroup.html#ga818f101f2f8bd824a3bc7c2c2361c560" title="Retrieve a entry from a container, with checks in Debug mode that the index being retrieved is valid.">gsl::at</a></code>. </td></tr>
    <tr><td class="paramname">size</td><td>A function to override the container size function. Defaults to an object which simply calls <code>container.size()</code>. A custom callable must take as argument the container(s) used in <code>arguments</code>, and return a size_t. This function signature follows the convention of <code>std::size</code>. </td></tr>
    <tr><td class="paramname">custom_approx</td><td>An object of type <code>Approx</code> specifying an alternative precision with which to test the element-wise function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7eeed237d2b270c574f0d118a4e173bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7eeed237d2b270c574f0d118a4e173bb">&#9670;&nbsp;</a></span>test_evaluate_rank_0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_0 </td>
          <td>(</td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 0 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>the data being stored in the Tensors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2ff246b302b57a05cac170908188ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ff246b302b57a05cac170908188ec79">&#9670;&nbsp;</a></span>test_evaluate_rank_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 1 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimensions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexType</td><td>the Tensors' <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname">Valence</td><td>the valence of the Tensors' index </td></tr>
    <tr><td class="paramname"><a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a></td><td>the <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti_a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6967be72b060806aa5d9bcecf9ee4d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6967be72b060806aa5d9bcecf9ee4d67">&#9670;&nbsp;</a></span>test_evaluate_rank_1_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename TensorIndexTypeList , auto &amp; TensorIndex&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_1_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 1 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeList</td><td>the Tensors' typelist containing their <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> </td></tr>
    <tr><td class="paramname"><a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a></td><td>the <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used in the the TensorExpression, e.g. <code>ti_a</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeaf3bd6076c329febb925afac926fe3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaf3bd6076c329febb925afac926fe3a">&#9670;&nbsp;</a></span>test_evaluate_rank_2_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_2_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 2 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The two possible cases that are checked are when the LHS tensor is evaluated with index order (a, b) and when it is evaluated with the index order (b, a).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c305cf2543cbee8dbd02923d568f0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c305cf2543cbee8dbd02923d568f0e5">&#9670;&nbsp;</a></span>test_evaluate_rank_2_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceA, UpLo ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_2_no_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_evaluate_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_evaluate_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>Note: <code>test_evaluate_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaed380eec1acd4a5df119fce26d177509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed380eec1acd4a5df119fce26d177509">&#9670;&nbsp;</a></span>test_evaluate_rank_2_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_2_symmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 2 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test nonsymmetric indices and symmetric indices across two functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;2, 1&gt; (<code>test_evaluate_rank_2_no_symmetry</code>)</li>
<li>&lt;1, 1&gt; (<code>test_evaluate_rank_2_symmetric</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code> and <code>TensorIndexB</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code> and <code>ti_b</code>. The "A" and "B" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used and <code>TensorIndexB</code> is the second index used.</p>
<p>Note: <code>test_evaluate_rank_2_symmetric</code> has fewer template parameters due to the two indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4376c85cfd93f01f2f774b833b09d5d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4376c85cfd93f01f2f774b833b09d5d7">&#9670;&nbsp;</a></span>test_evaluate_rank_3_ab_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceAB, UpLo ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_ab_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8e1ddf86635aff89f36b64e46694ffd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e1ddf86635aff89f36b64e46694ffd5">&#9670;&nbsp;</a></span>test_evaluate_rank_3_abc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexType, UpLo Valence, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_abc_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga827f107d76351e39457d3589c9fef82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga827f107d76351e39457d3589c9fef82c">&#9670;&nbsp;</a></span>test_evaluate_rank_3_ac_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeAC, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, UpLo ValenceAC, UpLo ValenceB, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_ac_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0f8f30068d400394fdff1b2b8d94eb3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f8f30068d400394fdff1b2b8d94eb3d">&#9670;&nbsp;</a></span>test_evaluate_rank_3_bc_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeBC, UpLo ValenceA, UpLo ValenceBC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_bc_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaabeae30ae8bee27e759201e6c3029568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabeae30ae8bee27e759201e6c3029568">&#9670;&nbsp;</a></span>test_evaluate_rank_3_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 3 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b, c), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The possible cases that are checked are when the LHS tensor is evaluated with index orders: (a, b, c), (a, c, b), (b, a, c), (b, c, a), (c, a, b), and (c, b, a).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaafede29f65b963f062dd534078c3395d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafede29f65b963f062dd534078c3395d">&#9670;&nbsp;</a></span>test_evaluate_rank_3_no_symmetry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeA, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeB, template&lt; size_t, UpLo, typename &gt; class TensorIndexTypeC, UpLo ValenceA, UpLo ValenceB, UpLo ValenceC, auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_3_no_symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iterate testing of evaluating single rank 3 Tensors on multiple <a class="el" href="namespaceFrame.html">Frame</a> types and dimension combinations. </p>
<p>We test various different symmetries across several functions to ensure that the code works correctly with symmetries. This function tests one of the following symmetries:</p><ul>
<li>&lt;3, 2, 1&gt; (<code>test_evaluate_rank_3_no_symmetry</code>)</li>
<li>&lt;2, 2, 1&gt; (<code>test_evaluate_rank_3_ab_symmetry</code>)</li>
<li>&lt;2, 1, 2&gt; (<code>test_evaluate_rank_3_ac_symmetry</code>)</li>
<li>&lt;2, 1, 1&gt; (<code>test_evaluate_rank_3_bc_symmetry</code>)</li>
<li>&lt;1, 1, 1&gt; (<code>test_evaluate_rank_3_abc_symmetry</code>)</li>
</ul>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, and <code>TensorIndexC</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, and <code>ti_c</code>. The "A", "B", and "C" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, and <code>TensorIndexC</code> is the third index used.</p>
<p>Note: the functions dealing with symmetric indices have fewer template parameters due to the indices having a shared <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> and valence</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">TensorIndexTypeA</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the first index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeB</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the second index of the RHS Tensor </td></tr>
    <tr><td class="paramname">TensorIndexTypeC</td><td>the <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a> of the third index of the RHS Tensor </td></tr>
    <tr><td class="paramname">ValenceA</td><td>the valence of the first index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceB</td><td>the valence of the second index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">ValenceC</td><td>the valence of the third index used on the RHS of the TensorExpression </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5cb356a3ed5c9b33fb849a9ffee7002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5cb356a3ed5c9b33fb849a9ffee7002">&#9670;&nbsp;</a></span>test_evaluate_rank_4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType , typename RhsSymmetry , typename RhsTensorIndexTypeList , auto &amp; TensorIndexA, auto &amp; TensorIndexB, auto &amp; TensorIndexC, auto &amp; TensorIndexD&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::TensorExpressions::test_evaluate_rank_4 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that evaluating a right hand side tensor expression containing a single rank 4 tensor correctly assigns the data to the evaluated left hand side tensor. </p>
<h3>Details</h3>
<p><code>TensorIndexA</code>, <code>TensorIndexB</code>, <code>TensorIndexC</code>, and <code>TensorIndexD</code> can be any type of <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> and are not necessarily <code>ti_a</code>, <code>ti_b</code>, <code>ti_c</code>, and <code>ti_d</code>. The "A", "B", "C", and "D" suffixes just denote the ordering of the generic indices of the RHS tensor expression. In the RHS tensor expression, it means <code>TensorIndexA</code> is the first index used, <code>TensorIndexB</code> is the second index used, <code>TensorIndexC</code> is the third index used, and <code>TensorIndexD</code> is the fourth index used.</p>
<p>If we consider the RHS tensor's generic indices to be (a, b, c, d), then this test checks that the data in the evaluated LHS tensor is correct according to the index orders of the LHS and RHS. The possible cases that are checked are when the LHS tensor is evaluated with index orders of all 24 permutations of (a, b, c, d), e.g. (a, b, d, c), (a, c, b, d), ...</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>the type of data being stored in the Tensors </td></tr>
    <tr><td class="paramname">RhsSymmetry</td><td>the <a class="el" href="group__TensorGroup.html#ga3b376e9167e178638a1adece2ab22ec9" title="Computes the canonical symmetry from the integers T">Symmetry</a> of the RHS Tensor </td></tr>
    <tr><td class="paramname">RhsTensorIndexTypeList</td><td>the RHS Tensor's typelist of <a class="el" href="group__TensorGroup.html#ga05c512b755e913cdbddce8634bdb4fa6">TensorIndexType</a>s </td></tr>
    <tr><td class="paramname">TensorIndexA</td><td>the first <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_a</code> </td></tr>
    <tr><td class="paramname">TensorIndexB</td><td>the second <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_B</code> </td></tr>
    <tr><td class="paramname">TensorIndexC</td><td>the third <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_c</code> </td></tr>
    <tr><td class="paramname">TensorIndexD</td><td>the fourth <a class="el" href="structTensorIndex.html" title="Represents the indices in a TensorExpression.">TensorIndex</a> used on the RHS of the TensorExpression, e.g. <code>ti_D</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4eda41a6ccec84a0ae929dc40664bad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4eda41a6ccec84a0ae929dc40664bad1">&#9670;&nbsp;</a></span>test_factory_creation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BaseClass , typename OptionTag  = TestCreationOpt&lt;std::unique_ptr&lt;BaseClass&gt;&gt;, typename Metavariables  = NoSuchType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;BaseClass&gt; TestHelpers::test_factory_creation </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>construction_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a factory object from a given string.</p>
<p>The string must contain the name of the option (specifically, the struct being created from options, which is the name of the struct). Note that it is not the name of the base class, but the name of the derived class that must be given. For example, to create a <code>BaseClass*</code> pointing to a derived class of type <code>size_t_argument_base</code> with an option tag name <code>SizeT</code> the following would be used:</p>
<div class="fragment"><div class="line">  CHECK(TestHelpers::test_factory_creation&lt;BaseClass&gt;(</div>
<div class="line">            <span class="stringliteral">&quot;DerivedClassWithoutMetavariables:\n&quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;  SizeT: 5&quot;</span>)</div>
<div class="line">            -&gt;get_value() == 5);</div>
</div><!-- fragment --><p> Option tags can be tested by passing them as the second template parameter. If the metavariables are required to create the class then the metavariables must be passed as the third template parameter. The default option tag is <code><a class="el" href="structTestHelpers_1_1TestCreationOpt.html">TestCreationOpt</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;BaseClass&gt;&gt;</code>. </p>

</div>
</div>
<a id="ga990527392f1401e09d2d9799b1a663a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga990527392f1401e09d2d9799b1a663a7">&#9670;&nbsp;</a></span>test_functions_with_vector_arguments()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TestKind Test, typename VectorType0 , typename... VectorTypes, typename... FunctionsAndArgumentBounds&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::VectorImpl::test_functions_with_vector_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FunctionsAndArgumentBounds... &gt; &amp;&#160;</td>
          <td class="paramname"><em>tuple_of_functions_and_argument_bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>General entry function for testing arbitrary math functions on vector types. </p>
<h3>Details</h3>
<p>This utility tests all combinations of the operator on the type arguments, and all combinations of reference or constant reference wrappers on all arguments. In certain test cases (see below), it also tests using the vector type's <code>value_type</code>s in the operators as well (e.g. <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a> + double</code>). This is very useful for quickly generating a lot of tests, but the number of tests scales exponentially in the number of arguments. Therefore, functions with many arguments can be time-consuming to run. 4-or-more-argument functions should be used only if completely necessary and with caution. Any number of vector types may be specified, and tests are run on all unique combinations of the provided. For instance, if only one type is provided, the tests will be run only on combinations of that single type and its <code>value_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple_of_functions_and_argument_bounds</td><td>A tuple of tuples, in which the inner tuple contains first a function object followed by a tuple of 2-element arrays equal to the number of arguments, which represent the bounds for the random generation of the respective arguments. This system is provided for robust testing of operators like <code>/</code>, where the left-hand side has a different valid set of values than the right-hand-side.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Test</td><td>from the <code>TestKind</code> enum, determines whether the tests will be:<ul>
<li><code>TestKind::Normal</code>: executed on all combinations of arguments and value types</li>
<li><code>TestKind::Strict</code>: executed on all combinations of arguments, for only the vector types</li>
<li><code>TestKind::Inplace</code>: executed on all combinations of arguments after the first, so first is always the 'left hand side' of the operator. In this case, at least two <code>VectorTypes</code> must be specified, where the first is used only for the left-hand side.</li>
<li><code>TestKind::GivenOrderOfArgumentsOnly</code>: executed on only the combination of arguments provided, in the order provided. In this case, the number of provided types in <code>typename VectorType0, typename... VectorTypes</code> must precisely match the number of arguments taken by the function.</li>
</ul>
</td></tr>
    <tr><td class="paramname">VectorType0</td><td>The first vector type for which combinations are tested. The first is accepted as a separate template argument for appropriately handling <code>Inplace</code> tests. </td></tr>
    <tr><td class="paramname">VectorTypes</td><td>The remaining types for which combinations are tested. Any number of types may be passed in, and the test will check the appropriate combinations of the vector types and (depending on the <code>Test</code>) the respective <code>value_type</code>s. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4294de51e79ce048d0a76bd72f80d19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4294de51e79ce048d0a76bd72f80d19a">&#9670;&nbsp;</a></span>test_serialization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_serialization </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests the serialization of comparable types. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;tuple&quot;</span>);</div>
<div class="line">    <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, double&gt;</a> um;</div>
<div class="line">    um[<span class="stringliteral">&quot;aaa&quot;</span>] = 1.589;</div>
<div class="line">    um[<span class="stringliteral">&quot;bbb&quot;</span>] = -10.7392;</div>
<div class="line">    <span class="keyword">auto</span> test_tuple = std::make_tuple&lt;int, double, <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,</div>
<div class="line">                                      <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;std::string, double&gt;</a>&gt;(</div>
<div class="line">                                          2, 0.57, <span class="stringliteral">&quot;blah&quot;</span>, std::move(um));</div>
<div class="line">    <a class="code" href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a>(test_tuple);</div>
<div class="line">  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga9032f7d7bb3698bab71a49d1df9c2d99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9032f7d7bb3698bab71a49d1df9c2d99">&#9670;&nbsp;</a></span>test_serialization_via_base()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B , typename D , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_serialization_via_base </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test the serialization of a derived class via a base class pointer. </p>
<h3>Example</h3>
<div class="fragment"><div class="line">  {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;unique_ptr.abstract_base&quot;</span>);</div>
<div class="line">    <a class="code" href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a>&lt;Test_Classes::Base,</div>
<div class="line">                                Test_Classes::DerivedInPupStlCpp11&gt;(</div>
<div class="line">                                    <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-1, 12.3, -7, 8});</div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>the base class </td></tr>
    <tr><td class="paramname">D</td><td>the derived class </td></tr>
    <tr><td class="paramname">Args</td><td>deduced from <code>args</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>arguments passed to a constructor of the derived class </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga809dd7c089188c1c15f847f73cf6d924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga809dd7c089188c1c15f847f73cf6d924">&#9670;&nbsp;</a></span>test_throw_exception()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Exception , typename ThrowingFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void test_throw_exception </td>
          <td>(</td>
          <td class="paramtype">const ThrowingFunctor &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Exception &amp;&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute <code>func</code> and check that it throws an exception <code>expected</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The <code>.what()</code> strings of the thrown and <code>expected</code> exceptions are compared for a partial match only: the <code>expected.what()</code> string must be contained in (or equal to) the <code>.what()</code> string of the thrown exception. </dd></dl>

</div>
</div>
<a id="gabc8106fbcf642235c3a21b28835e8041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc8106fbcf642235c3a21b28835e8041">&#9670;&nbsp;</a></span>vector_ref_test_size_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename ValueType  = typename VectorType::ElementType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TestHelpers::VectorImpl::vector_ref_test_size_error </td>
          <td>(</td>
          <td class="paramtype">RefSizeErrorTestKind&#160;</td>
          <td class="paramname"><em>test_kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::get_fundamental_type_t&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>low</em> = <code>tt::get_fundamental_type_t&lt;ValueType&gt;{-100.0}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tt::get_fundamental_type_t&lt; ValueType &gt;&#160;</td>
          <td class="paramname"><em>high</em> = <code>tt::get_fundamental_type_t&lt;ValueType&gt;{100.0}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test that assigning to a non-owning <code>VectorType</code> of the wrong size appropriately generates an error. </p>
<h3>Details</h3>
<p>a calling function should be an <code><a class="el" href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b" title="Mark a test to be checking an ASSERT.">ASSERTION_TEST()</a></code> and check for the string "Must copy into same size". Three types of tests are provided and one must be provided as the first function argument:</p><ul>
<li><code>RefSizeErrorTestKind::Copy</code>: Checks that copy-assigning to a non-owning <code>VectorType</code> from a <code>VectorType</code> with the wrong size generates an error.</li>
<li><code>RefSizeErrorTestKind::ExpressionAssign</code>: Checks that assigning to a non-owning <code>VectorType</code> from an expression with alias <code>ResultType</code> of <code>VectorType</code> with the wrong size generates an error</li>
<li><code>RefSizeErrorTestKind::Move</code>: Checks that move-assigning to a non-owning <code>VectorType</code> from a <code>VectorType</code> with the wrong size generates an error. </li>
</ul>

</div>
</div>
<a id="ga6992c8619ad085c9e128723f2b79aea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6992c8619ad085c9e128723f2b79aea5">&#9670;&nbsp;</a></span>verify_grmhd_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Solution &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verify_grmhd_solution </td>
          <td>(</td>
          <td class="paramtype">const Solution &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlock.html">Block</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>error_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>delta_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the given <code>solution</code> is a solution of the GRMHD equations. </p>
<p>Uses numerical derivatives to compute the solution, on the given <code>mesh</code> of the root <a class="el" href="classElement.html">Element</a> of the given <code>block</code> at the given <code>time</code> using a sixth-order derivative in time for the given <code>delta_time</code>. The maximum residual of the GRMHD equations must be zero within <code>error_tolerance</code> </p>

</div>
</div>
<a id="ga0ae659566b880c7f4fdee6ca53eedd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ae659566b880c7f4fdee6ca53eedd28">&#9670;&nbsp;</a></span>verify_smooth_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps, typename PackageFluxesArgs &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FirstOrderEllipticSolutionsTestHelpers::verify_smooth_solution </td>
          <td>(</td>
          <td class="paramtype">const SolutionType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename System::fluxes &amp;&#160;</td>
          <td class="paramname"><em>fluxes_computer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_scaling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackageFluxesArgs &amp;&amp;&#160;</td>
          <td class="paramname"><em>package_fluxes_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid and that the discretization error decreases as expected for a smooth function.</p>
<h3>Details</h3>
<p>We expect exponential convergence for a smooth solution, so the tolerance is computed as</p>
<p class="formulaDsp">
\begin{equation} C_1 \exp{\left(-C_2 * N_\mathrm{points}\right)} \end{equation}
</p>
<p>where \(C_1\) is the <code>tolerance_offset</code>, \(C_2\) is the <code>tolerance_scaling</code> and \(N_\mathrm{points}\) is the number of grid points per dimension. </p>

</div>
</div>
<a id="gae5d2e18354300a7e3fc41b46dd7a14ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5d2e18354300a7e3fc41b46dd7a14ab">&#9670;&nbsp;</a></span>verify_solution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename SolutionType , typename... Maps, typename... FluxesArgs, typename... SourcesArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FirstOrderEllipticSolutionsTestHelpers::verify_solution </td>
          <td>(</td>
          <td class="paramtype">const SolutionType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename System::fluxes &amp;&#160;</td>
          <td class="paramname"><em>fluxes_computer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; System::volume_dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt;&#160;</td>
          <td class="paramname"><em>coord_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; FluxesArgs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>fluxes_args</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;&gt;{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt; SourcesArgs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources_args</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a>&lt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid for the given tolerance </p>

</div>
</div>
<a id="ga56270746ff55c0378be522f9ba651bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56270746ff55c0378be522f9ba651bf7">&#9670;&nbsp;</a></span>verify_solution_with_power_law_convergence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename System , typename SolutionType , size_t Dim = System::volume_dim, typename... Maps&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FirstOrderEllipticSolutionsTestHelpers::verify_solution_with_power_law_convergence </td>
          <td>(</td>
          <td class="paramtype">const SolutionType &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename System::fluxes &amp;&#160;</td>
          <td class="paramname"><em>fluxes_computer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdomain_1_1CoordinateMap.html">domain::CoordinateMap</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, Maps... &gt; &amp;&#160;</td>
          <td class="paramname"><em>coord_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tolerance_pow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test that the <code>solution</code> numerically solves the <code>System</code> on the given grid and that the discretization error decreases as a power law.</p>
<h3>Details</h3>
<p>The tolerance is computed as</p>
<p class="formulaDsp">
\begin{equation} C \left(N_\mathrm{points}\right)^{-p} \end{equation}
</p>
<p>where \(C\) is the <code>tolerance_offset</code>, \(p\) is the <code>tolerance_pow</code> and \(N_\mathrm{points}\) is the number of grid points per dimension. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga8cd2549e4a5627f34f8201af2bcbfd34"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga8cd2549e4a5627f34f8201af2bcbfd34">INVOKE_TEST_FUNCTION</a></div><div class="ttdeci">#define INVOKE_TEST_FUNCTION(FUNCTION_NAME, TUPLE_ARGS,...)</div><div class="ttdoc">Macro used to invoke a test function of multiple template arguments.</div><div class="ttdef"><b>Definition:</b> CheckWithRandomValues.hpp:784</div></div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_gacd515a98a97cf7fc82e722274b17e7ce"><div class="ttname"><a href="group__TestingFrameworkGroup.html#gacd515a98a97cf7fc82e722274b17e7ce">OUTPUT_TEST</a></div><div class="ttdeci">#define OUTPUT_TEST()</div><div class="ttdoc">Mark a test as checking the output with a regular expression.</div><div class="ttdef"><b>Definition:</b> TestingFramework.hpp:358</div></div>
<div class="ttc" id="aclassSlab_html"><div class="ttname"><a href="classSlab.html">Slab</a></div><div class="ttdef"><b>Definition:</b> Slab.hpp:27</div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga4294de51e79ce048d0a76bd72f80d19a"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga4294de51e79ce048d0a76bd72f80d19a">test_serialization</a></div><div class="ttdeci">void test_serialization(const T &amp;t)</div><div class="ttdoc">Tests the serialization of comparable types.</div><div class="ttdef"><b>Definition:</b> TestHelpers.hpp:68</div></div>
<div class="ttc" id="acos_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/math/cos.html">std::cos</a></div><div class="ttdeci">T cos(T... args)</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gae21964b5d28608afd21ae090c1c4c073"><div class="ttname"><a href="group__ParallelGroup.html#gae21964b5d28608afd21ae090c1c4c073">Parallel::printf</a></div><div class="ttdeci">void printf(const std::string &amp;format, Args &amp;&amp;... args)</div><div class="ttdoc">Print an atomic message to stdout with C printf usage.</div><div class="ttdef"><b>Definition:</b> Printf.hpp:103</div></div>
<div class="ttc" id="acommon_type_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/common_type.html">std::common_type_t</a></div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_gaf962c28abc1a1f014f2a6b32c6f01680"><div class="ttname"><a href="group__TestingFrameworkGroup.html#gaf962c28abc1a1f014f2a6b32c6f01680">ERROR_TEST</a></div><div class="ttdeci">#define ERROR_TEST()</div><div class="ttdoc">Mark a test as checking a call to ERROR.</div><div class="ttdef"><b>Definition:</b> TestingFramework.hpp:308</div></div>
<div class="ttc" id="agroup__TensorGroup_html_gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504"><div class="ttname"><a href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8ea33d7f1ec5fe18e7ba799474138e71504">IndexType::Spatial</a></div><div class="ttdeci">@ Spatial</div><div class="ttdoc">The TensorIndexType is purely spatial.</div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga4439208ed8accb2887ff47388e91e58b"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga4439208ed8accb2887ff47388e91e58b">ASSERTION_TEST</a></div><div class="ttdeci">#define ASSERTION_TEST()</div><div class="ttdoc">Mark a test to be checking an ASSERT.</div><div class="ttdef"><b>Definition:</b> TestingFramework.hpp:339</div></div>
<div class="ttc" id="amersenne_twister_engine_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine.html">std::mt19937</a></div></div>
<div class="ttc" id="agroup__ErrorHandlingGroup_html_ga1d27028c1827976007fe9d29ad3a2f66"><div class="ttname"><a href="group__ErrorHandlingGroup.html#ga1d27028c1827976007fe9d29ad3a2f66">ERROR</a></div><div class="ttdeci">#define ERROR(m)</div><div class="ttdoc">prints an error message to the standard error stream and aborts the program.</div><div class="ttdef"><b>Definition:</b> Error.hpp:36</div></div>
<div class="ttc" id="agroup__TensorGroup_html_gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e"><div class="ttname"><a href="group__TensorGroup.html#gga875b107b929ff008a27078792ac0bc8eaed5df3a695921f514a83c22d119c0f8e">IndexType::Spacetime</a></div><div class="ttdeci">@ Spacetime</div><div class="ttdoc">The TensorIndexType is a spacetime index.</div></div>
<div class="ttc" id="arandom_device_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/random/random_device.html">std::random_device</a></div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga21fcbc0b07905e0d2f8b012b388acd73"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga21fcbc0b07905e0d2f8b012b388acd73">CHECK_FOR_DOUBLES_AND_DATAVECTORS</a></div><div class="ttdeci">#define CHECK_FOR_DOUBLES_AND_DATAVECTORS(FUNCTION_NAME,...)</div><div class="ttdoc">Macro used to test functions whose parameter can be a double or a DataVector.</div><div class="ttdef"><b>Definition:</b> CheckWithRandomValues.hpp:928</div></div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:42</div></div>
<div class="ttc" id="adecay_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a></div></div>
<div class="ttc" id="asin_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/numeric/math/sin.html">std::sin</a></div><div class="ttdeci">T sin(T... args)</div></div>
<div class="ttc" id="aclassTime_html"><div class="ttname"><a href="classTime.html">Time</a></div><div class="ttdef"><b>Definition:</b> Time.hpp:29</div></div>
<div class="ttc" id="agroup__TestingFrameworkGroup_html_ga9032f7d7bb3698bab71a49d1df9c2d99"><div class="ttname"><a href="group__TestingFrameworkGroup.html#ga9032f7d7bb3698bab71a49d1df9c2d99">test_serialization_via_base</a></div><div class="ttdeci">void test_serialization_via_base(Args &amp;&amp;... args)</div><div class="ttdoc">Test the serialization of a derived class via a base class pointer.</div><div class="ttdef"><b>Definition:</b> TestHelpers.hpp:82</div></div>
<div class="ttc" id="agroup__ParallelGroup_html_gaccc68e564135958d18110d2847dcc1b3"><div class="ttname"><a href="group__ParallelGroup.html#gaccc68e564135958d18110d2847dcc1b3">Parallel::abort</a></div><div class="ttdeci">void abort(const std::string &amp;message)</div><div class="ttdef"><b>Definition:</b> Abort.hpp:23</div></div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a></div></div>
<div class="ttc" id="anumeric_limits_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a></div></div>
<div class="ttc" id="aclassMakeString_html"><div class="ttname"><a href="classMakeString.html">MakeString</a></div><div class="ttdoc">Make a string by streaming into object.</div><div class="ttdef"><b>Definition:</b> MakeString.hpp:18</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
