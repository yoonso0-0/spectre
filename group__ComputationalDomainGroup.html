<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Computational Domain</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Computational Domain</div>  </div>
</div><!--header-->
<div class="contents">

<p>The building blocks used to describe the computational domain.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceamr"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceamr.html">amr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1CoordinateMaps_1_1Tags.html">domain::CoordinateMaps::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1CoordinateMaps_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the coordinate maps. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators.html">domain::creators</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines classes that create Domains. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1creators_1_1time__dependence"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1creators_1_1time__dependence.html">domain::creators::time_dependence</a></td></tr>
<tr class="memdesc:namespacedomain_1_1creators_1_1time__dependence"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classes and functions for adding time dependence to a domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1FunctionsOfTime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1FunctionsOfTime.html">domain::FunctionsOfTime</a></td></tr>
<tr class="memdesc:namespacedomain_1_1FunctionsOfTime"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains functions of time to support the dual frame system. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacedomain_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedomain_1_1Tags.html">domain::Tags</a></td></tr>
<tr class="memdesc:namespacedomain_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags for the domain. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlock.html">Block&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1CoordinateMaps_1_1Tags_1_1CoordinateMap.html">domain::CoordinateMaps::Tags::CoordinateMap&lt; VolumeDim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1creators_1_1BinaryCompactObject.html">domain::creators::BinaryCompactObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general domain for two compact objects.  <a href="classdomain_1_1creators_1_1BinaryCompactObject.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomainCreator.html">DomainCreator&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for creating Domains from an option string.  <a href="classDomainCreator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDomain.html">Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around a vector of Blocks that represent the computational domain.  <a href="classDomain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPairOfFaces.html">PairOfFaces</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVolumeCornerIterator.html">VolumeCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFaceCornerIterator.html">FaceCornerIterator&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder&lt; Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementMap.html">ElementMap&lt; Dim, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMap for the <a class="el" href="classElement.html">Element</a> from the Logical frame to the <code>TargetFrame</code>  <a href="classElementMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1UnnormalizedFaceNormal.html">domain::Tags::UnnormalizedFaceNormal&lt; VolumeDim, Frame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute_3_01Tags_1_1BoundaryDirectionsExterior_3_01VolumeDim_0184ce0938d30efe351cc7c3751f2e8f00.html">domain::Tags::InterfaceCompute&lt; Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;, UnnormalizedFaceNormalCompute&lt; VolumeDim, Frame &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="namespacedomain_1_1FunctionsOfTime.html" title="Contains functions of time to support the dual frame system.">FunctionsOfTime</a>.  <a href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html">domain::FunctionsOfTime::PiecewisePolynomial&lt; MaxDeriv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that has a piecewise-constant <code>MaxDeriv</code>th derivative.  <a href="classdomain_1_1FunctionsOfTime_1_1PiecewisePolynomial.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceCompute.html">domain::Tags::InterfaceCompute&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing items computed on a set of interfaces. Can be retrieved using <code><a class="el" href="structdomain_1_1Tags_1_1Interface.html" title="Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts...">Tags::Interface</a>&lt;DirectionsTag, Tag&gt;</code>  <a href="structdomain_1_1Tags_1_1InterfaceCompute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Slice.html">domain::Tags::Slice&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute tag for representing a compute item that slices data from the volume to a set of interfaces.  <a href="structdomain_1_1Tags_1_1Slice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InterfaceMesh.html">domain::Tags::InterfaceMesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryCoordinates.html">domain::Tags::BoundaryCoordinates&lt; VolumeDim, MovingMesh &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1LogicalCoordinates.html">domain::Tags::LogicalCoordinates&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MinimumGridSpacing.html">domain::Tags::MinimumGridSpacing&lt; Dim, Frame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1OptionTags_1_1DomainCreator.html">domain::OptionTags::DomainCreator&lt; Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1SizeOfElement.html">domain::Tags::SizeOfElement&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classIndex.html">Index</a> a block of the computational domain.  <a href="classdomain_1_1BlockId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockNeighbor.html">BlockNeighbor&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirection.html">Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDirectionHash.html">DirectionHash&lt; Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDirectionMap.html">DirectionMap&lt; Dim, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElement.html">Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classElementId.html">ElementId&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> uniquely labels an <a class="el" href="classElement.html">Element</a>.  <a href="classElementId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNeighbors.html">Neighbors&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSegmentId.html">SegmentId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classSegmentId.html" title="A SegmentId labels a segment of the interval [-1,1] and is used to identify the bounds of an Element ...">SegmentId</a> labels a segment of the interval [-1,1] and is used to identify the bounds of an <a class="el" href="classElement.html">Element</a> in a <a class="el" href="classBlock.html">Block</a> in each dimension.  <a href="classSegmentId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Domain.html">domain::Tags::Domain&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialExtents.html">domain::Tags::InitialExtents&lt; Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InitialRefinementLevels.html">domain::Tags::InitialRefinementLevels&lt; Dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Element.html">domain::Tags::Element&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Mesh.html">domain::Tags::Mesh&lt; VolumeDim &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The computational grid of the <a class="el" href="structdomain_1_1Tags_1_1Element.html">Element</a> in the DataBox.  <a href="structdomain_1_1Tags_1_1Mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1ElementMap.html">domain::Tags::ElementMap&lt; VolumeDim, TargetFrame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Coordinates.html">domain::Tags::Coordinates&lt; Dim, Frame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1MappedCoordinates.html">domain::Tags::MappedCoordinates&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobian.html">domain::Tags::InverseJacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1InverseJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InverseJacobianCompute.html">domain::Tags::InverseJacobianCompute&lt; MapTag, SourceCoordsTag &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Jacobian.html">domain::Tags::Jacobian&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1Jacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1JacobianCompute.html">domain::Tags::JacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobian.html">domain::Tags::DetInvJacobian&lt; SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The determinant of the inverse <a class="el" href="structdomain_1_1Tags_1_1Jacobian.html" title="The Jacobian from the source frame to the target frame.">Jacobian</a> from the source frame to the target frame.  <a href="structdomain_1_1Tags_1_1DetInvJacobian.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1DetInvJacobianCompute.html">domain::Tags::DetInvJacobianCompute&lt; Dim, SourceFrame, TargetFrame &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1VariablesBoundaryData.html">domain::Tags::VariablesBoundaryData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1InternalDirections.html">domain::Tags::InternalDirections&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsInterior.html">domain::Tags::BoundaryDirectionsInterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1BoundaryDirectionsExterior.html">domain::Tags::BoundaryDirectionsExterior&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Interface.html">domain::Tags::Interface&lt; DirectionsTag, Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag which is either a SimpleTag for quantities on an interface, base tag to a compute item which acts on tags on an interface, or base tag to a compute item which slices a tag from the volume to an interface.  <a href="structdomain_1_1Tags_1_1Interface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdomain_1_1Tags_1_1Direction.html">domain::Tags::Direction&lt; VolumeDim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga39eb7361b3bcfe317a1576be5141b10f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">More...</a><br /></td></tr>
<tr class="separator:ga39eb7361b3bcfe317a1576be5141b10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45607952ebcf523987906a5c27ccef59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>(_,  data)</td></tr>
<tr class="memdesc:ga45607952ebcf523987906a5c27ccef59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">More...</a><br /></td></tr>
<tr class="separator:ga45607952ebcf523987906a5c27ccef59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8773fe02f44b68af479cb53dd4383978"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(MAPS_TUPLE,  SOURCE_FRAME,  TARGET_FRAMES_TUPLE,  TYPES_TUPLE)</td></tr>
<tr class="memdesc:ga8773fe02f44b68af479cb53dd4383978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate instantiations of member functions of the <code>CoordinateMap</code> class template.  <a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">More...</a><br /></td></tr>
<tr class="separator:ga8773fe02f44b68af479cb53dd4383978"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a> { <br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360">amr::Flag::Undefined</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f">amr::Flag::Join</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147">amr::Flag::DecreaseResolution</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7">amr::Flag::DoNothing</a>, 
<br />
&#160;&#160;<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273">amr::Flag::IncreaseResolution</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2">amr::Flag::Split</a>
<br />
 }</td></tr>
<tr class="memdesc:ga6874579f1400ff7d0d77cbfa978289e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags that represent decisions about mesh refinement.  <a href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">More...</a><br /></td></tr>
<tr class="separator:ga6874579f1400ff7d0d77cbfa978289e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> { <a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45">ShellWedges::FourOnEquator</a>, 
<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb">ShellWedges::OneAlongMinusX</a>
 }</td></tr>
<tr class="separator:gac672a529d9aaa6a948b8b7eb6ec9b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a> { <b>Lower</b>, 
<b>Upper</b>
 }</td></tr>
<tr class="separator:ga8c0137d7160ad71b6ed265c53c99ed00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaefd6db279218361a4f20f85771e12aa6"><td class="memTemplParams" colspan="2"><a id="gaefd6db279218361a4f20f85771e12aa6"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaefd6db279218361a4f20f85771e12aa6"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaefd6db279218361a4f20f85771e12aa6">amr::desired_refinement_levels</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;flags) noexcept</td></tr>
<tr class="memdesc:gaefd6db279218361a4f20f85771e12aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of the <a class="el" href="classElement.html">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>id</code> given the desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>flags</code> <br /></td></tr>
<tr class="separator:gaefd6db279218361a4f20f85771e12aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gab6b39332c0ebaf70aa94de13661b2e13">amr::desired_refinement_levels_of_neighbor</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_flags, const OrientationMap&lt; VolumeDim &gt; &amp;orientation) noexcept</td></tr>
<tr class="memdesc:gab6b39332c0ebaf70aa94de13661b2e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the desired refinement level of a neighboring <a class="el" href="classElement.html">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>neighbor_flags</code> taking into account the OrientationMap <code>orientation</code> of the neighbor.  <a href="group__ComputationalDomainGroup.html#gab6b39332c0ebaf70aa94de13661b2e13">More...</a><br /></td></tr>
<tr class="separator:gab6b39332c0ebaf70aa94de13661b2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memTemplParams" colspan="2"><a id="gaf0e7346e59a71819c08d9efbfcb99ea2"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaf0e7346e59a71819c08d9efbfcb99ea2">amr::has_potential_sibling</a> (const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;element_id, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the <a class="el" href="classElement.html">Element</a> with <code>element_id</code> can have a sibling in the given <code>direction</code> <br /></td></tr>
<tr class="separator:gaf0e7346e59a71819c08d9efbfcb99ea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f">amr::update_amr_decision</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; * &gt; my_current_amr_flags, const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;element, const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;neighbor_id, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;neighbor_amr_flags) noexcept</td></tr>
<tr class="memdesc:gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code>.  <a href="group__ComputationalDomainGroup.html#gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f">More...</a><br /></td></tr>
<tr class="separator:gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1208d2e0efaa21c6721ee9a2754d4c70"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:ga1208d2e0efaa21c6721ee9a2754d4c70"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1208d2e0efaa21c6721ee9a2754d4c70">block_logical_coordinates</a> (const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;domain, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;x, double time=<a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt; double &gt;::signaling_NaN(), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt;&gt; &amp;functions_of_time=<a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt;&gt;{}) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, ::<a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt;</td></tr>
<tr class="separator:ga1208d2e0efaa21c6721ee9a2754d4c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8313460096176264f7bc06ac58aa34e6"><td class="memTemplParams" colspan="2"><a id="ga8313460096176264f7bc06ac58aa34e6"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga8313460096176264f7bc06ac58aa34e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8313460096176264f7bc06ac58aa34e6">domain::make_coordinate_map</a> (Maps &amp;&amp;... maps) noexcept -&gt; <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;</td></tr>
<tr class="memdesc:ga8313460096176264f7bc06ac58aa34e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga8313460096176264f7bc06ac58aa34e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga281275a17c14e1361ab43e8079d545fc"><td class="memTemplParams" colspan="2"><a id="ga281275a17c14e1361ab43e8079d545fc"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps&gt; </td></tr>
<tr class="memitem:ga281275a17c14e1361ab43e8079d545fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga281275a17c14e1361ab43e8079d545fc">domain::make_coordinate_map_base</a> (Maps &amp;&amp;... maps) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Maps &gt;... &gt;::dim &gt;&gt;</td></tr>
<tr class="memdesc:ga281275a17c14e1361ab43e8079d545fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;</code> of <code>maps...</code> <br /></td></tr>
<tr class="separator:ga281275a17c14e1361ab43e8079d545fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e72842eb76ca8b91e595319a38636ac"><td class="memTemplParams" colspan="2"><a id="ga1e72842eb76ca8b91e595319a38636ac"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename Arg0 , typename... Args&gt; </td></tr>
<tr class="memitem:ga1e72842eb76ca8b91e595319a38636ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga1e72842eb76ca8b91e595319a38636ac">domain::make_vector_coordinate_map_base</a> (Arg0 &amp;&amp;arg_0, Args &amp;&amp;... remaining_args) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/decay.html">std::decay_t</a>&lt; Arg0 &gt;::dim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga1e72842eb76ca8b91e595319a38636ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each argument passed in. <br /></td></tr>
<tr class="separator:ga1e72842eb76ca8b91e595319a38636ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada681fd92fb5c963e51df2027f7a3324"><td class="memTemplParams" colspan="2"><a id="gada681fd92fb5c963e51df2027f7a3324"></a>
template&lt;typename SourceFrame , typename TargetFrame , size_t Dim, typename Map , typename... Maps&gt; </td></tr>
<tr class="memitem:gada681fd92fb5c963e51df2027f7a3324"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gada681fd92fb5c963e51df2027f7a3324">domain::make_vector_coordinate_map_base</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; Map &gt; maps, const Maps &amp;... remaining_maps) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">CoordinateMapBase</a>&lt; SourceFrame, TargetFrame, Dim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:gada681fd92fb5c963e51df2027f7a3324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;<a class="el" href="classdomain_1_1CoordinateMapBase.html" title="Abstract base class for CoordinateMap.">CoordinateMapBase</a>&gt;&gt;</code> containing the result of <code>make_coordinate_map_base</code> applied to each element of the vector of maps composed with the rest of the arguments passed in. <br /></td></tr>
<tr class="separator:gada681fd92fb5c963e51df2027f7a3324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga398bdce722c9ba655f479a7712f1a0e5"><td class="memTemplParams" colspan="2"><a id="ga398bdce722c9ba655f479a7712f1a0e5"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:ga398bdce722c9ba655f479a7712f1a0e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps..., NewMap &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga398bdce722c9ba655f479a7712f1a0e5">domain::push_back</a> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map) noexcept</td></tr>
<tr class="memdesc:ga398bdce722c9ba655f479a7712f1a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by appending the new map to the end of the old maps. <br /></td></tr>
<tr class="separator:ga398bdce722c9ba655f479a7712f1a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadd52d75ebc604a2ecf7a505c7c5d095"><td class="memTemplParams" colspan="2"><a id="gaadd52d75ebc604a2ecf7a505c7c5d095"></a>
template&lt;typename SourceFrame , typename TargetFrame , typename... Maps, typename NewMap &gt; </td></tr>
<tr class="memitem:gaadd52d75ebc604a2ecf7a505c7c5d095"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, NewMap, Maps... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaadd52d75ebc604a2ecf7a505c7c5d095">domain::push_front</a> (<a class="el" href="classdomain_1_1CoordinateMap.html">CoordinateMap</a>&lt; SourceFrame, TargetFrame, Maps... &gt; old_map, NewMap new_map) noexcept</td></tr>
<tr class="memdesc:gaadd52d75ebc604a2ecf7a505c7c5d095"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <code><a class="el" href="classdomain_1_1CoordinateMap.html" title="A coordinate map or composition of coordinate maps.">CoordinateMap</a></code> by prepending the new map to the beginning of the old maps. <br /></td></tr>
<tr class="separator:gaadd52d75ebc604a2ecf7a505c7c5d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga352a96e2ad69bb9fd2d71d412a4fc8b7"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga352a96e2ad69bb9fd2d71d412a4fc8b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga352a96e2ad69bb9fd2d71d412a4fc8b7">set_internal_boundaries</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;corners_of_all_blocks) noexcept</td></tr>
<tr class="separator:ga352a96e2ad69bb9fd2d71d412a4fc8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7a70c8db5cee22de8f4d074b2b1a92a"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaa7a70c8db5cee22de8f4d074b2b1a92a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa7a70c8db5cee22de8f4d074b2b1a92a">set_internal_boundaries</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt; neighbors_of_all_blocks, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt;&gt;&gt; &amp;maps) noexcept</td></tr>
<tr class="separator:gaa7a70c8db5cee22de8f4d074b2b1a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5640402fc85ec353685c6914a9750459"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga5640402fc85ec353685c6914a9750459"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga5640402fc85ec353685c6914a9750459">set_identified_boundaries</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;corners_of_all_blocks, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt; neighbors_of_all_blocks) noexcept</td></tr>
<tr class="separator:ga5640402fc85ec353685c6914a9750459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba91825909e9aa842eb091df693e919e"><td class="memTemplParams" colspan="2"><a id="gaba91825909e9aa842eb091df693e919e"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gaba91825909e9aa842eb091df693e919e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaba91825909e9aa842eb091df693e919e">indices_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt;</td></tr>
<tr class="memdesc:gaba91825909e9aa842eb091df693e919e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The multi-indices that identify the individual Blocks in the lattice. <br /></td></tr>
<tr class="separator:gaba91825909e9aa842eb091df693e919e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18341ca86191b511f92daf2d8c69302c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga18341ca86191b511f92daf2d8c69302c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga18341ca86191b511f92daf2d8c69302c">corners_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt;</td></tr>
<tr class="memdesc:ga18341ca86191b511f92daf2d8c69302c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a rectilinear domain made of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga18341ca86191b511f92daf2d8c69302c">More...</a><br /></td></tr>
<tr class="separator:ga18341ca86191b511f92daf2d8c69302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9">sph_wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double inner_sphericity, double outer_sphericity, bool use_equiangular_map, double x_coord_of_shell_center=0.0, bool use_half_wedges=false, double aspect_ratio=1.0, bool use_logarithmic_map=false, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>, size_t number_of_layers=1) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td></tr>
<tr class="separator:ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga86534fcfbcabd6acc079b6fc38cdfbea">frustum_coordinate_maps</a> (double length_inner_cube, double length_outer_cube, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;origin_preimage={{0.0, 0.0, 0.0}}, double projective_scale_factor=1.0) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td></tr>
<tr class="separator:ga86534fcfbcabd6acc079b6fc38cdfbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18526a75399d20dfb670b233fa55cff8"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga18526a75399d20dfb670b233fa55cff8">corners_for_radially_layered_domains</a> (size_t number_of_layers, bool include_central_block, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners={{1, 2, 3, 4, 5, 6, 7, 8}}, <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a> which_wedges=<a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a>) noexcept</td></tr>
<tr class="memdesc:ga18526a75399d20dfb670b233fa55cff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with radial layers.  <a href="group__ComputationalDomainGroup.html#ga18526a75399d20dfb670b233fa55cff8">More...</a><br /></td></tr>
<tr class="separator:ga18526a75399d20dfb670b233fa55cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa76c0e8c51614f3393118e403ed35a5f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gaa76c0e8c51614f3393118e403ed35a5f">corners_for_biradially_layered_domains</a> (size_t number_of_radial_layers, size_t number_of_biradial_layers, bool include_central_block_lhs, bool include_central_block_rhs, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;central_block_corners_lhs={ {1, 2, 3, 4, 5, 6, 7, 8}}) noexcept</td></tr>
<tr class="memdesc:gaa76c0e8c51614f3393118e403ed35a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a domain with biradial layers.  <a href="group__ComputationalDomainGroup.html#gaa76c0e8c51614f3393118e403ed35a5f">More...</a><br /></td></tr>
<tr class="separator:gaa76c0e8c51614f3393118e403ed35a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7646c1d656ceff2433e293b1200a8b3e"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga7646c1d656ceff2433e293b1200a8b3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga7646c1d656ceff2433e293b1200a8b3e">cyl_wedge_coordinate_maps</a> (double inner_radius, double outer_radius, double lower_bound, double upper_bound, bool use_equiangular_map, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;radial_partitioning={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;height_partitioning={}) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td></tr>
<tr class="separator:ga7646c1d656ceff2433e293b1200a8b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc">corners_for_cylindrical_layered_domains</a> (size_t number_of_shells, size_t number_of_discs) noexcept</td></tr>
<tr class="memdesc:ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The corners for a cylindrical domain split into discs with radial shells.  <a href="group__ComputationalDomainGroup.html#ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc">More...</a><br /></td></tr>
<tr class="separator:ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8c80443a66a28ba3cd542cf5f2d223c5">discrete_rotation</a> (const OrientationMap&lt; VolumeDim &gt; &amp;orientation, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;corners_of_aligned) noexcept</td></tr>
<tr class="memdesc:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the corner numbers of an n-cube.  <a href="group__ComputationalDomainGroup.html#ga8c80443a66a28ba3cd542cf5f2d223c5">More...</a><br /></td></tr>
<tr class="separator:ga8c80443a66a28ba3cd542cf5f2d223c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memTemplParams" colspan="2">template&lt;typename TargetFrame , size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">maps_for_rectilinear_domains</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;orientations_of_all_blocks={}, bool use_equiangular_map=false) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CoordinateMaps for a rectilinear domain of n-cubes.  <a href="group__ComputationalDomainGroup.html#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">More...</a><br /></td></tr>
<tr class="separator:ga2fa6f4a3bbb32cae7c59d29c519ce4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18dade6a071f22fdd5c32487d79f04cb"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga18dade6a071f22fdd5c32487d79f04cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDomain.html">Domain</a>&lt; VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga18dade6a071f22fdd5c32487d79f04cb">rectilinear_domain</a> (const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;domain_extents, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;block_demarcations, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;block_indices_to_exclude={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;orientations_of_all_blocks={}, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;dimension_is_periodic=<a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a>&lt; VolumeDim &gt;(false), const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;identifications={}, bool use_equiangular_map=false) noexcept</td></tr>
<tr class="memdesc:ga18dade6a071f22fdd5c32487d79f04cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes.  <a href="group__ComputationalDomainGroup.html#ga18dade6a071f22fdd5c32487d79f04cb">More...</a><br /></td></tr>
<tr class="separator:ga18dade6a071f22fdd5c32487d79f04cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga11187dd6e2dcf301fceabe0e4e4260fa">element_logical_coordinates</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt; &amp;element_ids, const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt; &amp;block_coord_holders) noexcept -&gt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt;&gt;</td></tr>
<tr class="separator:ga11187dd6e2dcf301fceabe0e4e4260fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b765bb8483842f249f114d3704985a4"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TargetFrame &gt; </td></tr>
<tr class="memitem:ga4b765bb8483842f249f114d3704985a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga4b765bb8483842f249f114d3704985a4">unnormalized_face_normal</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt; result, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;map, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:ga4b765bb8483842f249f114d3704985a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the outward grid normal on a face of an <a class="el" href="classElement.html">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga4b765bb8483842f249f114d3704985a4">More...</a><br /></td></tr>
<tr class="separator:ga4b765bb8483842f249f114d3704985a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6070224843ce605a36853fab86c8c2ca"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga6070224843ce605a36853fab86c8c2ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga6070224843ce605a36853fab86c8c2ca">logical_coordinates</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt; * &gt; logical_coords, const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;mesh) noexcept</td></tr>
<tr class="memdesc:ga6070224843ce605a36853fab86c8c2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates in an <a class="el" href="classElement.html">Element</a>.  <a href="group__ComputationalDomainGroup.html#ga6070224843ce605a36853fab86c8c2ca">More...</a><br /></td></tr>
<tr class="separator:ga6070224843ce605a36853fab86c8c2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memTemplItemLeft" align="right" valign="top">tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">interface_logical_coordinates</a> (const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;mesh, const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;direction) noexcept</td></tr>
<tr class="memdesc:gac857ec0446d088d1d17cf96376ba8e3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logical coordinates on a face of an <a class="el" href="classElement.html">Element</a>.  <a href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">More...</a><br /></td></tr>
<tr class="separator:gac857ec0446d088d1d17cf96376ba8e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memTemplParams" colspan="2">template&lt;size_t Dim, typename Frame &gt; </td></tr>
<tr class="memitem:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga8fd6a7e52fee97306c6158477c84b71c">minimum_grid_spacing</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;coords) noexcept</td></tr>
<tr class="separator:ga8fd6a7e52fee97306c6158477c84b71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga832807abf863e6287a5451de7d5cf2d9"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga832807abf863e6287a5451de7d5cf2d9"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga832807abf863e6287a5451de7d5cf2d9">size_of_element</a> (const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;logical_to_inertial_map) noexcept</td></tr>
<tr class="memdesc:ga832807abf863e6287a5451de7d5cf2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inertial-coordinate size of an element along each of its logical directions.  <a href="group__ComputationalDomainGroup.html#ga832807abf863e6287a5451de7d5cf2d9">More...</a><br /></td></tr>
<tr class="separator:ga832807abf863e6287a5451de7d5cf2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc46e3154da75aacf6dbfe0f629c0285"><td class="memTemplParams" colspan="2">template&lt;size_t Dim&gt; </td></tr>
<tr class="memitem:gadc46e3154da75aacf6dbfe0f629c0285"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gadc46e3154da75aacf6dbfe0f629c0285">index_to_slice_at</a> (const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;extents, const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;direction, const size_t offset=0) noexcept</td></tr>
<tr class="memdesc:gadc46e3154da75aacf6dbfe0f629c0285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the index in the perpendicular dimension of an element boundary.  <a href="group__ComputationalDomainGroup.html#gadc46e3154da75aacf6dbfe0f629c0285">More...</a><br /></td></tr>
<tr class="separator:gadc46e3154da75aacf6dbfe0f629c0285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd6da000524acf8f467d9f297ff648c"><td class="memTemplParams" colspan="2"><a id="gadbd6da000524acf8f467d9f297ff648c"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:gadbd6da000524acf8f467d9f297ff648c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gadbd6da000524acf8f467d9f297ff648c">initial_element_ids</a> (size_t block_id, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; initial_ref_levs) noexcept</td></tr>
<tr class="memdesc:gadbd6da000524acf8f467d9f297ff648c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the a single <a class="el" href="classBlock.html">Block</a>. <br /></td></tr>
<tr class="separator:gadbd6da000524acf8f467d9f297ff648c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memTemplParams" colspan="2"><a id="ga3dc8997f1019309f79ef4ba9cc7848a8"></a>
template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga3dc8997f1019309f79ef4ba9cc7848a8">initial_element_ids</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt;&gt; &amp;initial_refinement_levels) noexcept</td></tr>
<tr class="memdesc:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s of the initial computational domain. <br /></td></tr>
<tr class="separator:ga3dc8997f1019309f79ef4ba9cc7848a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8cb44daebc8f9e080718961530be89"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#gafa8cb44daebc8f9e080718961530be89">maximum_number_of_neighbors</a> (const size_t dim)</td></tr>
<tr class="separator:gafa8cb44daebc8f9e080718961530be89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga45ff23a83bb3bab32bd30a13bc9a41a0">maximum_number_of_neighbors_per_direction</a> (const size_t dim)</td></tr>
<tr class="separator:ga45ff23a83bb3bab32bd30a13bc9a41a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b10be7003c5a457911e520865ddd91c"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename T &gt; </td></tr>
<tr class="memitem:ga5b10be7003c5a457911e520865ddd91c"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; tt::remove_cvref_wrap_t&lt; T &gt;, VolumeDim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga5b10be7003c5a457911e520865ddd91c">discrete_rotation</a> (const OrientationMap&lt; VolumeDim &gt; &amp;rotation, <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, VolumeDim &gt; source_coords) noexcept</td></tr>
<tr class="separator:ga5b10be7003c5a457911e520865ddd91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga026c1241e187aa9ad0459c1720747887"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TagsList &gt; </td></tr>
<tr class="memitem:ga026c1241e187aa9ad0459c1720747887"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; TagsList &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga026c1241e187aa9ad0459c1720747887">orient_variables</a> (const Variables&lt; TagsList &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const OrientationMap&lt; VolumeDim &gt; &amp;orientation_of_neighbor) noexcept</td></tr>
<tr class="separator:ga026c1241e187aa9ad0459c1720747887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e62c01507cebe8653279f8d401e8664"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim&gt; </td></tr>
<tr class="memitem:ga4e62c01507cebe8653279f8d401e8664"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ComputationalDomainGroup.html#ga4e62c01507cebe8653279f8d401e8664">orient_variables</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;variables, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;extents, const OrientationMap&lt; VolumeDim &gt; &amp;orientation_of_neighbor) noexcept</td></tr>
<tr class="separator:ga4e62c01507cebe8653279f8d401e8664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The building blocks used to describe the computational domain. </p>
<h3><a class="anchor" id="autotoc_md0"></a>
Description</h3>
<p>The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html">Block</a>s. Each <a class="el" href="classBlock.html">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html">Block</a>. Each <a class="el" href="classBlock.html">Block</a> is subdivided into one or more <a class="el" href="classElement.html">Element</a>s that may be changed dynamically if AMR is enabled.</p>
<h3><a class="anchor" id="autotoc_md148"></a>
Description</h3>
<p>The VolumeDim-dimensional computational <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> is constructed from a set of non-overlapping <a class="el" href="classBlock.html">Block</a>s. Each <a class="el" href="classBlock.html">Block</a> is a distorted VolumeDim-dimensional hypercube. Each codimension-1 boundary of a <a class="el" href="classBlock.html">Block</a> is either part of the external boundary of the computational domain, or is identical to a boundary of one other <a class="el" href="classBlock.html">Block</a>. Each <a class="el" href="classBlock.html">Block</a> is subdivided into one or more <a class="el" href="classElement.html">Element</a>s that may be changed dynamically if AMR is enabled. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga45607952ebcf523987906a5c27ccef59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45607952ebcf523987906a5c27ccef59">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p>Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code" href="structFrame_1_1Logical.html">Frame::Logical</a>),</div>
<div class="line">                        (<a class="code" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                        (<span class="keywordtype">double</span>, <a class="code" href="classDataVector.html">DataVector</a>))</div>
</div><!-- fragment --><p>The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>. The last tuple is the data types for which to instantiate the functions, usually <code>double</code> and <code><a class="el" href="classDataVector.html" title="Stores a collection of function values.">DataVector</a></code>.</p>
<p>Instantiates:</p><ul>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga8773fe02f44b68af479cb53dd4383978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8773fe02f44b68af479cb53dd4383978">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">MAPS_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">SOURCE_FRAME, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TARGET_FRAMES_TUPLE, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TYPES_TUPLE&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">  <a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>, MAPS_TUPLE,    \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE)                \</div>
<div class="line">  GENERATE_INSTANTIATIONS(<a class="code" href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a>, MAPS_TUPLE, \</div>
<div class="line">                          SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div>
</div><!-- fragment -->
<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p>Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a>(((Affine2d), (Affine3d)), (<a class="code" href="structFrame_1_1Logical.html">Frame::Logical</a>),</div>
<div class="line">                           (<a class="code" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code" href="structFrame_1_1Inertial.html">Frame::Inertial</a>),</div>
<div class="line">                           (<span class="keywordtype">double</span>, <a class="code" href="classDataVector.html">DataVector</a>))</div>
</div><!-- fragment --><p>The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p>Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code></li>
<li><code>call_impl</code></li>
<li><code>inv_jacobian_impl</code></li>
<li><code>jacobian_impl</code></li>
<li><code>coords_frame_velocity_jacobians_impl</code> </li>
</ul>

</div>
</div>
<a id="ga39eb7361b3bcfe317a1576be5141b10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39eb7361b3bcfe317a1576be5141b10f">&#9670;&nbsp;</a></span>INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate instantiations of member functions of the <code>CoordinateMap</code> class template. </p>
<p>Called as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> Affine2d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"><span class="keyword">using</span> Affine3d =</div>
<div class="line">    <a class="code" href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a>&lt;<a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>,</div>
<div class="line">                                           <a class="code" href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a>&gt;;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a>(<a class="code" href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a>,</div>
<div class="line">                        ((Affine2d), (Affine3d)), (<a class="code" href="structFrame_1_1Logical.html">Frame::Logical</a>),</div>
<div class="line">                        (<a class="code" href="structFrame_1_1Grid.html">Frame::Grid</a>, <a class="code" href="structFrame_1_1Inertial.html">Frame::Inertial</a>))</div>
</div><!-- fragment --><p>The first tuple passed to <code>GENERATE_INSTANTIATIONS</code> has a bunch of tuples in it that is the list of maps being composed. The reason for defining the type aliases <code>Affine2d</code> and <code>Affine3d</code> is that otherwise the number of maps being composed is calculated incorrectly. The second tuple contains the source frames for the map. The third tuple passed to <code>GENERATE_INSTANTIATIONS</code> contains the target frames to instantiate for, typically <code><a class="el" href="structFrame_1_1Grid.html">Frame::Grid</a></code> and <code><a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a></code>.</p>
<p>Instantiates:</p><ul>
<li><code>get_to_grid_frame_impl</code></li>
<li><code>inverse_impl</code></li>
<li><code>class CoordinateMap</code> </li>
</ul>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga6874579f1400ff7d0d77cbfa978289e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6874579f1400ff7d0d77cbfa978289e2">&#9670;&nbsp;</a></span>Flag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags that represent decisions about mesh refinement. </p>
<p>In order to support anisotropic mesh refinement, a flag is specified for each dimension. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aec0fc0100c4fc1ce4eea230c3dc10360"></a>Undefined&#160;</td><td class="fielddoc"><p>used to initialize flags before a decision is made </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2aa286d9991c6a547ae25a5f5216164b8f"></a>Join&#160;</td><td class="fielddoc"><p>join the sibling of an <a class="el" href="classElement.html">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2ae566bdf06d954aec108ff063196a4147"></a>DecreaseResolution&#160;</td><td class="fielddoc"><p>decrease number of points in an <a class="el" href="classElement.html">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a71b7f3fcd4098ebf8a3b387579d90dd7"></a>DoNothing&#160;</td><td class="fielddoc"><p>stay the same </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a1f8c283304e4a6a17283ca12b9868273"></a>IncreaseResolution&#160;</td><td class="fielddoc"><p>increase number of points in an <a class="el" href="classElement.html">Element</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="gga6874579f1400ff7d0d77cbfa978289e2a8a9e64d86ed12ad40de129bc7f4683b2"></a>Split&#160;</td><td class="fielddoc"><p>split the <a class="el" href="classElement.html">Element</a> into two smaller elements </p>
</td></tr>
</table>

</div>
</div>
<a id="gac672a529d9aaa6a948b8b7eb6ec9b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac672a529d9aaa6a948b8b7eb6ec9b528">&#9670;&nbsp;</a></span>ShellWedges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The number of wedges to include in the Shell domain. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680"></a>All&#160;</td><td class="fielddoc"><p>Use the entire shell. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ace553534ea34f25db4b4a8b5bd29cf45"></a>FourOnEquator&#160;</td><td class="fielddoc"><p>Use only the four equatorial wedges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggac672a529d9aaa6a948b8b7eb6ec9b528ae9d8dbfbf81de7cf729066f677661edb"></a>OneAlongMinusX&#160;</td><td class="fielddoc"><p>Use only the single wedge along -x. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga8c0137d7160ad71b6ed265c53c99ed00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c0137d7160ad71b6ed265c53c99ed00">&#9670;&nbsp;</a></span>Side</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__ComputationalDomainGroup.html#ga8c0137d7160ad71b6ed265c53c99ed00">Side</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A label for the side of a manifold.</p>
<p>Lower and Upper are with respect to the logical coordinate whose axis is normal to the side, i.e. beyond the Upper (Lower) side, the logical coordinate is increasing (decreasing). </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1208d2e0efaa21c6721ee9a2754d4c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1208d2e0efaa21c6721ee9a2754d4c70">&#9670;&nbsp;</a></span>block_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto block_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDomain.html">Domain</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/types/numeric_limits.html">std::numeric_limits</a>&lt;&#160;double&#160;&gt;::signaling_NaN()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>, <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>functions_of_time</em> = <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt;&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>,&#160;<a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt;&#160;<a class="el" href="classdomain_1_1FunctionsOfTime_1_1FunctionOfTime.html">domain::FunctionsOfTime::FunctionOfTime</a>&#160;&gt;&gt;{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, ::<a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the block logical coordinates and the containing <code>BlockId</code> of a set of points, given coordinates in a particular frame.</p>
<h3>Details</h3>
<p>Returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;boost::optional&lt;IdPair&lt;BlockId,coords&gt;&gt;&gt;, where the vector runs over the points and is indexed in the same order as the input coordinates <code>x</code>. For each point, the <code><a class="el" href="structIdPair.html" title="A data structure that contains an ID and data associated with that ID.">IdPair</a></code> holds the block logical coords of that point and the <code>BlockId</code> of the <code><a class="el" href="classBlock.html">Block</a></code> that contains that point. The boost::optional is empty if the point is not in any <a class="el" href="classBlock.html">Block</a>. If a point is on a shared boundary of two or more <code><a class="el" href="classBlock.html">Block</a></code>s, it is returned only once, and is considered to belong to the <code><a class="el" href="classBlock.html">Block</a></code> with the smaller <code>BlockId</code>. </p>

</div>
</div>
<a id="gaa76c0e8c51614f3393118e403ed35a5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa76c0e8c51614f3393118e403ed35a5f">&#9670;&nbsp;</a></span>corners_for_biradially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, 8&gt; &gt; corners_for_biradially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_biradial_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners_lhs</em> = <code>{&#160;{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a domain with biradial layers. </p>
<p>Generates the corners for a BBH-like <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping two interior volumes. The <code>number_of_radial_layers</code> gives the number of layers that fully envelop each interior volume with six Blocks each. The <code>number_of_biradial_layers</code> gives the number of layers that fully envelop both volumes at once, using ten Blocks per layer as opposed to six. The <code>central_block_corners_lhs</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25fa2b3f359fdcd8fd7d15c7b0ce1dbc">&#9670;&nbsp;</a></span>corners_for_cylindrical_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, 8&gt; &gt; corners_for_cylindrical_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_discs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a cylindrical domain split into discs with radial shells. </p>
<p>Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more stacked discs consisting of layers of Blocks enveloping an interior square prism. The <code>number_of_shells</code> specifies how many of these layers of Blocks to have in each disc.</p>
<p>The <code>number_of_discs</code> specifies how many discs make up the domain. The very basic cylinder with one shell and one layer serves as a base to generate the corners for subsequent shells first and discs second. </p>

</div>
</div>
<a id="ga18526a75399d20dfb670b233fa55cff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18526a75399d20dfb670b233fa55cff8">&#9670;&nbsp;</a></span>corners_for_radially_layered_domains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;<a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, 8&gt; &gt; corners_for_radially_layered_domains </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_layers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_central_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, 8 &gt; &amp;&#160;</td>
          <td class="paramname"><em>central_block_corners</em> = <code>{{1,&#160;2,&#160;3,&#160;4,&#160;5,&#160;6,&#160;7,&#160;8}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a domain with radial layers. </p>
<p>Generates the corners for a <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> which is made of one or more layers of Blocks fully enveloping an interior volume, e.g. Shell or Sphere. The <code>number_of_layers</code> specifies how many of these layers of Blocks to have in the final domain. <code>include_central_block</code> is set to <code>true</code> in Sphere, where the interior volume is filled with a central <a class="el" href="classBlock.html">Block</a>, and <code>false</code> in Shell, where the interior volume is left empty. The <code>central_block_corners</code> are used as seed values to generate the corners for the surrounding Blocks. </p>

</div>
</div>
<a id="ga18341ca86191b511f92daf2d8c69302c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18341ca86191b511f92daf2d8c69302c">&#9670;&nbsp;</a></span>corners_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto corners_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The corners for a rectilinear domain made of n-cubes. </p>
<p>The <code>domain_extents</code> argument holds the number of blocks to have in each dimension. The blocks all have aligned orientations by construction. The <code>block_indices_to_exclude</code> argument allows the user to selectively exclude blocks from the resulting domain. This allows for the creation of non-trivial shapes such as the net for a tesseract. </p>

</div>
</div>
<a id="ga7646c1d656ceff2433e293b1200a8b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7646c1d656ceff2433e293b1200a8b3e">&#9670;&nbsp;</a></span>cyl_wedge_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cyl_wedge_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>radial_partitioning</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>height_partitioning</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the CoordinateMaps used in the Cylinder <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a>.</p>
<p>The <code>radial_partitioning</code> specifies the radial boundaries of sub-shells between <code>inner_radius</code> and <code>outer_radius</code>, while <code>height_partitioning</code> specifies the z-boundaries, splitting the cylinder into stacked 3-dimensional disks. The circularity of the shell wedges changes from 0 to 1 within the innermost sub-shell. </p>

</div>
</div>
<a id="gab6b39332c0ebaf70aa94de13661b2e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b39332c0ebaf70aa94de13661b2e13">&#9670;&nbsp;</a></span>desired_refinement_levels_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, VolumeDim &gt; amr::desired_refinement_levels_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the desired refinement level of a neighboring <a class="el" href="classElement.html">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> given its desired <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2" title="Flags that represent decisions about mesh refinement.">amr::Flag</a>s <code>neighbor_flags</code> taking into account the OrientationMap <code>orientation</code> of the neighbor. </p>
<h3>Details</h3>
<p>The OrientationMap <code>orientation</code> is that from the <a class="el" href="classElement.html">Element</a> that has a neighbor with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code> </p>

</div>
</div>
<a id="ga8c80443a66a28ba3cd542cf5f2d223c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c80443a66a28ba3cd542cf5f2d223c5">&#9670;&nbsp;</a></span>discrete_rotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; discrete_rotation </td>
          <td>(</td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_aligned</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Permutes the corner numbers of an n-cube. </p>
<p>Returns the correct ordering of global corner numbers for a rotated block in an otherwise aligned edifice of blocks, given the OrientationMap a block aligned with the edifice has relative to this one, and given the corner numbering the rotated block would have if it were aligned. This is useful in creating domains for testing purposes, e.g. RotatedIntervals, RotatedRectangles, and RotatedBricks. </p>

</div>
</div>
<a id="ga5b10be7003c5a457911e520865ddd91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b10be7003c5a457911e520865ddd91c">&#9670;&nbsp;</a></span>discrete_rotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;tt::remove_cvref_wrap_t&lt;T&gt;, VolumeDim&gt; discrete_rotation </td>
          <td>(</td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rotation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; T, VolumeDim &gt;&#160;</td>
          <td class="paramname"><em>source_coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>OrientationMap</code>s define an active rotation of the logical axes that bring the axes of a host block into alignment with the logical axes of the neighbor block. <code>discrete_rotation</code> applies this active rotation on the coordinates as opposed to the axes. For a two-dimensional example, consider a host block and a neighbor block, where the OrientationMap between them is \(\{-\eta,+\xi\}\). A quarter- turn counterclockwise of the host block's logical axes would bring them into alignment with those of the neighbor. That is, after this active rotation, the blocks would be Aligned. Now consider a point A with coordinates (+1.0,-0.5). An active quarter-turn rotation counter-clockwise about the origin, keeping the axes fixed, brings point A into the coordinates (+0.5,+1.0). This is how <code>discrete_rotation</code> interprets the <code>OrientationMap</code> passed to it. </p>

</div>
</div>
<a id="ga11187dd6e2dcf301fceabe0e4e4260fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga11187dd6e2dcf301fceabe0e4e4260fa">&#9670;&nbsp;</a></span>element_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto element_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>element_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; boost::optional&lt; <a class="el" href="structIdPair.html">IdPair</a>&lt; <a class="el" href="classdomain_1_1BlockId.html">domain::BlockId</a>, tnsr::I&lt; double, Dim, typename <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_coord_holders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a>&lt; <a class="el" href="classElementId.html">ElementId</a>&lt; Dim &gt;, <a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a>&lt; Dim &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of points in block logical coordinates and their <code>BlockIds</code>, as returned from the function <code>block_logical_coordinates</code>, determines which <code><a class="el" href="classElement.html">Element</a></code>s in a list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s contains each point, and determines the element logical coordinates of each point.</p>
<h3>Details</h3>
<p>Returns a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map</a> from <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s to <code><a class="el" href="structElementLogicalCoordHolder.html">ElementLogicalCoordHolder</a></code>s. It is expected that only a subset of the points will be found in the given <code><a class="el" href="classElement.html">Element</a></code>s. If a point is on a shared boundary of two or more <code><a class="el" href="classElement.html">Element</a></code>s, it will be returned only once, and will be considered to belong to the first <code><a class="el" href="classElement.html">Element</a></code> in the list of <code><a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a></code>s. </p>

</div>
</div>
<a id="ga86534fcfbcabd6acc079b6fc38cdfbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86534fcfbcabd6acc079b6fc38cdfbea">&#9670;&nbsp;</a></span>frustum_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto frustum_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_inner_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>length_outer_cube</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; double, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin_preimage</em> = <code>{{0.0,&#160;0.0,&#160;0.0}}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>projective_scale_factor</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the ten Frustums used in the DomainCreators for binary compact objects. The Frustums partition the volume defined by two bounding surfaces: The inner surface is the surface of the two joined inner cubes enveloping the two compact objects, while the outer is the surface of the outer cube. The cubes enveloping the two Shells each have a side length of <code>length_inner_cube</code>. The outer cube has a side length of <code>length_outer_cube</code>. <code>origin_preimage</code> is a parameter that moves the center of the two joined inner cubes away from the origin and to <code>-origin_preimage</code>. <code>projective_scale_factor</code> acts to change the gridpoint distribution in the radial direction. </p><dl class="section see"><dt>See also</dt><dd>Frustum for details. </dd></dl>

</div>
</div>
<a id="gadc46e3154da75aacf6dbfe0f629c0285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc46e3154da75aacf6dbfe0f629c0285">&#9670;&nbsp;</a></span>index_to_slice_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_to_slice_at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the index in the perpendicular dimension of an element boundary. </p>
<p>Optionally provide an <code>offset</code> to find an index offset from the element boundary. </p>

</div>
</div>
<a id="gac857ec0446d088d1d17cf96376ba8e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac857ec0446d088d1d17cf96376ba8e3c">&#9670;&nbsp;</a></span>interface_logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tnsr::I&lt;<a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>&gt; interface_logical_coordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the logical coordinates on a face of an <a class="el" href="classElement.html">Element</a>. </p>
<p><em>Returns:</em> logical-frame vector holding coordinates</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;2&gt;</a> mesh_3d_zbdry{</div>
<div class="line">      {{5, 3}}, Spectral::Basis::Legendre, Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d_lb_zeta = map_3d(</div>
<div class="line">      <a class="code" href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">interface_logical_coordinates</a>(mesh_3d_zbdry, <a class="code" href="classDirection.html">Direction&lt;3&gt;::lower_zeta</a>()));</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga6070224843ce605a36853fab86c8c2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6070224843ce605a36853fab86c8c2ca">&#9670;&nbsp;</a></span>logical_coordinates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void logical_coordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a> &gt; * &gt;&#160;</td>
          <td class="paramname"><em>logical_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the logical coordinates in an <a class="el" href="classElement.html">Element</a>. </p>
<h3>Details</h3>
<p>The logical coordinates are the collocation points associated to the spectral basis functions and quadrature of the <code>mesh</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;3&gt;</a> mesh_3d{{{5, 3, 2}},</div>
<div class="line">                        Spectral::Basis::Legendre,</div>
<div class="line">                        Spectral::Quadrature::GaussLobatto};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine x_map{-1.0, 1.0, -3.0, 7.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine y_map{-1.0, 1.0, -13.0, 47.0};</div>
<div class="line">  <span class="keyword">const</span> CoordinateMaps::Affine z_map{-1.0, 1.0, -32.0, 74.0};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_3d = make_coordinate_map&lt;Frame::Logical, Frame::Grid&gt;(</div>
<div class="line">      Affine3d{x_map, y_map, z_map});</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> x_3d = map_3d(<a class="code" href="group__ComputationalDomainGroup.html#ga6070224843ce605a36853fab86c8c2ca">logical_coordinates</a>(mesh_3d));</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga2fa6f4a3bbb32cae7c59d29c519ce4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa6f4a3bbb32cae7c59d29c519ce4a3">&#9670;&nbsp;</a></span>maps_for_rectilinear_domains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame , size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto maps_for_rectilinear_domains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, VolumeDim &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The CoordinateMaps for a rectilinear domain of n-cubes. </p>
<p>Allows for both Affine and Equiangular maps. </p>

</div>
</div>
<a id="gafa8cb44daebc8f9e080718961530be89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8cb44daebc8f9e080718961530be89">&#9670;&nbsp;</a></span>maximum_number_of_neighbors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of neighbors an element can have in <code>dim</code> dimensions.</p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga45ff23a83bb3bab32bd30a13bc9a41a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45ff23a83bb3bab32bd30a13bc9a41a0">&#9670;&nbsp;</a></span>maximum_number_of_neighbors_per_direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t maximum_number_of_neighbors_per_direction </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum number of neighbors in each direction an element can have in <code>dim</code> dimensions.</p>
<dl class="section note"><dt>Note</dt><dd>Assumes a maximum 2-to-1 refinement between two adjacent Elements. </dd></dl>

</div>
</div>
<a id="ga8fd6a7e52fee97306c6158477c84b71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd6a7e52fee97306c6158477c84b71c">&#9670;&nbsp;</a></span>minimum_grid_spacing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Dim, typename Frame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double minimum_grid_spacing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, Dim, Frame &gt; &amp;&#160;</td>
          <td class="paramname"><em>coords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds the minimum coordinate distance between grid points. </p>

</div>
</div>
<a id="ga4e62c01507cebe8653279f8d401e8664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e62c01507cebe8653279f8d401e8664">&#9670;&nbsp;</a></span>orient_variables() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt; orient_variables </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Orient data in a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt;double&gt;</code> representing one or more tensor components.</p>
<p>In most cases the <code>Variables</code> version of <code>orient_variables</code> should be called. However, in some cases the tags and thus the type of the data being sent is determined at runtime. In these cases the <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a></code> version of <code>orient_variables</code> is useful. A concrete example of this is when hybridizing DG with finite difference methods, where sometimes the data sent is both the variables for reconstruction and the fluxes for either the DG or finite difference scheme, while at other points only one of these three is sent. </p>

</div>
</div>
<a id="ga026c1241e187aa9ad0459c1720747887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga026c1241e187aa9ad0459c1720747887">&#9670;&nbsp;</a></span>orient_variables() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TagsList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt;TagsList&gt; orient_variables </td>
          <td>(</td>
          <td class="paramtype">const Variables&lt; TagsList &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OrientationMap&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>orientation_of_neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Orient variables to the data-storage order of a neighbor element with the given orientation. </p>

</div>
</div>
<a id="ga18dade6a071f22fdd5c32487d79f04cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18dade6a071f22fdd5c32487d79f04cb">&#9670;&nbsp;</a></span>rectilinear_domain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDomain.html">Domain</a>&lt;VolumeDim&gt; rectilinear_domain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>domain_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; double &gt;, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_demarcations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>block_indices_to_exclude</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; OrientationMap&lt; VolumeDim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>orientations_of_all_blocks</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; bool, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dimension_is_periodic</em> = <code><a class="el" href="group__UtilitiesGroup.html#gaea51ad2c5ef8f8f99279545e1389d056">make_array</a>&lt;&#160;VolumeDim&#160;&gt;(false)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>identifications</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a rectilinear <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a> of multicubes. </p>
<h3>Details</h3>
<p>Useful for constructing domains for testing non-trivially connected rectilinear domains made up of cubes. We refer to a domain of this type as an edifice. The <code>domain_extents</code> provides the size (in the number of blocks) of the initial aligned edifice to construct. The <code>block_indices_to_exclude</code> parameter is used in refining the shape of the edifice from a cube to sometime more non-trivial, such as an L-shape or the net of a tesseract. The <code>block_demarcations</code> and <code>use_equiangular_map</code> parameters determine the CoordinateMaps to be used. <code>orientations_of_all_blocks</code> contains the OrientationMap of the edifice relative to each block.</p>
<p>The <code>identifications</code> parameter is used when identifying the faces of blocks in an edifice. This is used to identify the 1D boundaries in the 2D net for a 3D cube to construct a domain with topology S2. Note: If the user wishes to rotate the blocks as well as manually identify their faces, the user must provide the <a class="el" href="structPairOfFaces.html">PairOfFaces</a> corresponding to the rotated corners. </p>

</div>
</div>
<a id="ga5640402fc85ec353685c6914a9750459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5640402fc85ec353685c6914a9750459">&#9670;&nbsp;</a></span>set_identified_boundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_identified_boundaries </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="structPairOfFaces.html">PairOfFaces</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>identifications</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_all_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>neighbors_of_all_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets up additional BlockNeighbors corresponding to any identifications of faces provided by the user. Can be used for manually setting up periodic boundary conditions. </p>

</div>
</div>
<a id="ga352a96e2ad69bb9fd2d71d412a4fc8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga352a96e2ad69bb9fd2d71d412a4fc8b7">&#9670;&nbsp;</a></span>set_internal_boundaries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_internal_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>neighbors_of_all_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; size_t, <a class="el" href="group__ConstantExpressionsGroup.html#ga6c01ded3973bb4b9973e5381c32c0807">two_to_the</a>(VolumeDim)&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>corners_of_all_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets up the BlockNeighbors using the corner numbering scheme provided by the user to deduce the correct neighbors and orientations. Does not set up periodic boundary conditions. </p>

</div>
</div>
<a id="gaa7a70c8db5cee22de8f4d074b2b1a92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7a70c8db5cee22de8f4d074b2b1a92a">&#9670;&nbsp;</a></span>set_internal_boundaries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void set_internal_boundaries </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="el" href="classDirectionMap.html">DirectionMap</a>&lt; VolumeDim, <a class="el" href="classBlockNeighbor.html">BlockNeighbor</a>&lt; VolumeDim &gt;&gt;&gt; * &gt;&#160;</td>
          <td class="paramname"><em>neighbors_of_all_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a>, VolumeDim &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>maps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets up the BlockNeighbors using the corner numbering scheme implied by the maps provided by the user to deduce the correct neighbors and orientations. </p><dl class="section warning"><dt>Warning</dt><dd>Does not set up periodic boundary conditions. </dd></dl>

</div>
</div>
<a id="ga832807abf863e6287a5451de7d5cf2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga832807abf863e6287a5451de7d5cf2d9">&#9670;&nbsp;</a></span>size_of_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;double, VolumeDim&gt; size_of_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, <a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logical_to_inertial_map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inertial-coordinate size of an element along each of its logical directions. </p>
<p>For each logical direction, compute the distance (in inertial coordinates) between the element's lower and upper faces in that logical direction. The distance is measured between centers of the faces, with the centers defined in the logical coordinates. Note that for curved elements, this is an approximate measurement of size.</p>
<h3>Details</h3>
<p>Because this quantity is defined in terms of specific coordinates, it is not well represented by a <code>Tensor</code>, so we use a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></code>. </p>

</div>
</div>
<a id="ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97cfbd5a2ed53f5ac5a1d46bf6afe2f9">&#9670;&nbsp;</a></span>sph_wedge_coordinate_maps()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sph_wedge_coordinate_maps </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>inner_sphericity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>outer_sphericity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_equiangular_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_coord_of_shell_center</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_half_wedges</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>aspect_ratio</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_logarithmic_map</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__ComputationalDomainGroup.html#gac672a529d9aaa6a948b8b7eb6ec9b528">ShellWedges</a>&#160;</td>
          <td class="paramname"><em>which_wedges</em> = <code><a class="el" href="group__ComputationalDomainGroup.html#ggac672a529d9aaa6a948b8b7eb6ec9b528ab1c94ca2fbc3e78fc30069c8d0f01680">ShellWedges::All</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_layers</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/unique_ptr.html">std::unique_ptr</a>&lt; <a class="el" href="classdomain_1_1CoordinateMapBase.html">domain::CoordinateMapBase</a>&lt; <a class="el" href="structFrame_1_1Logical.html">Frame::Logical</a>, TargetFrame, 3 &gt;&gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>These are the CoordinateMaps of the Wedge3Ds used in the Sphere, Shell, and binary compact object DomainCreators. This function can also be used to wrap the Sphere or Shell in a cube made of six Wedge3Ds. The argument <code>x_coord_of_shell_center</code> specifies a translation of the Shell in the x-direction in the TargetFrame. For example, the BBH <a class="el" href="classDomainCreator.html" title="Base class for creating Domains from an option string.">DomainCreator</a> uses this to set the position of each BH. When the argument <code>use_half_wedges</code> is set to <code>true</code>, the wedges in the +z,-z,+y,-y directions are cut in half along their xi-axes. The resulting ten CoordinateMaps are used for the outermost Blocks of the BBH <a class="el" href="classDomain.html" title="A wrapper around a vector of Blocks that represent the computational domain.">Domain</a>. The argument <code>aspect_ratio</code> sets the equatorial compression factor, used by the EquatorialCompression maps which get composed with the Wedges. This is done if <code>aspect_ratio</code> is set to something other than the default value of one. When the argument <code>use_logarithmic_map</code> is set to <code>true</code>, the radial gridpoints of the wedge map are set to be spaced logarithmically. The <code>number_of_layers</code> is used when the user wants to have multiple layers of Blocks in the radial direction. </p>

</div>
</div>
<a id="ga4b765bb8483842f249f114d3704985a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b765bb8483842f249f114d3704985a4">&#9670;&nbsp;</a></span>unnormalized_face_normal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TargetFrame &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unnormalized_face_normal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classDataVector.html">DataVector</a>, VolumeDim, TargetFrame &gt; * &gt;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; VolumeDim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>interface_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementMap.html">ElementMap</a>&lt; VolumeDim, TargetFrame &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDirection.html">Direction</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the outward grid normal on a face of an <a class="el" href="classElement.html">Element</a>. </p>
<h3>Details</h3>
<p>Computes the grid-frame normal by taking the logical-frame unit one-form in the given <a class="el" href="classDirection.html">Direction</a> and mapping it to the grid frame with the given map.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <a class="code" href="classMesh.html">Mesh&lt;0&gt;</a> mesh_0d;</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> map_1d = make_coordinate_map&lt;Frame::Logical, Frame::Grid&gt;(</div>
<div class="line">      CoordinateMaps::Affine(-1.0, 1.0, -3.0, 7.0));</div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> normal_1d_lower =</div>
<div class="line">      <a class="code" href="group__ComputationalDomainGroup.html#ga4b765bb8483842f249f114d3704985a4">unnormalized_face_normal</a>(mesh_0d, map_1d, <a class="code" href="classDirection.html">Direction&lt;1&gt;::lower_xi</a>());</div>
</div><!-- fragment -->
</div>
</div>
<a id="gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb5d7ccd64c0bd2d5c87f9a0eeabd73f">&#9670;&nbsp;</a></span>update_amr_decision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool amr::update_amr_decision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; * &gt;&#160;</td>
          <td class="paramname"><em>my_current_amr_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElement.html">Element</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classElementId.html">ElementId</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt; <a class="el" href="group__ComputationalDomainGroup.html#ga6874579f1400ff7d0d77cbfa978289e2">amr::Flag</a>, VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbor_amr_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the AMR decisions <code>my_current_amr_flags</code> of the <a class="el" href="classElement.html">Element</a> <code>element</code> based on the AMR decisions <code>neighbor_amr_flags</code> of a neighbor <a class="el" href="classElement.html">Element</a> with <a class="el" href="classElementId.html" title="An ElementId uniquely labels an Element.">ElementId</a> <code>neighbor_id</code>. </p>
<h3>Details</h3>
<p>This function is called by each element when it receives the AMR decisions of one of its neighbors. If any of its flags are updated, the element should send its new decisions to each of its neighbors. The following changes are made to the current flags of the element:</p><ul>
<li>If the neighbor wants to be two or more refinement levels higher than the element, the flag is updated to bring the element to within one level</li>
<li>If the element wants to join, and the neighbor is a potential sibling but wants to be at a different refinement level in any dimension, the flag is updated to not do h-refinement.</li>
</ul>
<p><em>Returns:</em> true if any flag is changed</p>
<dl class="section note"><dt>Note</dt><dd>Modifies <code>my_current_amr_flags</code> which are the AMR decisions of <code>element</code>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf3Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf3Maps.html">domain::CoordinateMaps::ProductOf3Maps</a></div><div class="ttdoc">Product of three one-dimensional CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:86</div></div>
<div class="ttc" id="astructFrame_1_1Inertial_html"><div class="ttname"><a href="structFrame_1_1Inertial.html">Frame::Inertial</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:44</div></div>
<div class="ttc" id="astructFrame_1_1Grid_html"><div class="ttname"><a href="structFrame_1_1Grid.html">Frame::Grid</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:43</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_gac857ec0446d088d1d17cf96376ba8e3c"><div class="ttname"><a href="group__ComputationalDomainGroup.html#gac857ec0446d088d1d17cf96376ba8e3c">interface_logical_coordinates</a></div><div class="ttdeci">tnsr::I&lt; DataVector, VolumeDim, Frame::Logical &gt; interface_logical_coordinates(const Mesh&lt; VolumeDim - 1 &gt; &amp;mesh, const Direction&lt; VolumeDim &gt; &amp;direction) noexcept</div><div class="ttdoc">Compute the logical coordinates on a face of an Element.</div><div class="ttdef"><b>Definition:</b> LogicalCoordinates.cpp:46</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1ProductOf2Maps_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1ProductOf2Maps.html">domain::CoordinateMaps::ProductOf2Maps</a></div><div class="ttdoc">Product of two codimension=0 CoordinateMaps.</div><div class="ttdef"><b>Definition:</b> ProductMaps.hpp:35</div></div>
<div class="ttc" id="aclassDirection_html"><div class="ttname"><a href="classDirection.html">Direction</a></div><div class="ttdef"><b>Definition:</b> Direction.hpp:23</div></div>
<div class="ttc" id="aclassdomain_1_1CoordinateMaps_1_1Affine_html"><div class="ttname"><a href="classdomain_1_1CoordinateMaps_1_1Affine.html">domain::CoordinateMaps::Affine</a></div><div class="ttdoc">Affine map from .</div><div class="ttdef"><b>Definition:</b> Affine.hpp:37</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga45607952ebcf523987906a5c27ccef59"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga45607952ebcf523987906a5c27ccef59">INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_DATA_TYPE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:149</div></div>
<div class="ttc" id="aclassDataVector_html"><div class="ttname"><a href="classDataVector.html">DataVector</a></div><div class="ttdoc">Stores a collection of function values.</div><div class="ttdef"><b>Definition:</b> DataVector.hpp:42</div></div>
<div class="ttc" id="aclassMesh_html"><div class="ttname"><a href="classMesh.html">Mesh</a></div><div class="ttdoc">Holds the number of grid points, basis, and quadrature in each direction of the computational grid.</div><div class="ttdef"><b>Definition:</b> Mesh.hpp:48</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga6070224843ce605a36853fab86c8c2ca"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga6070224843ce605a36853fab86c8c2ca">logical_coordinates</a></div><div class="ttdeci">void logical_coordinates(gsl::not_null&lt; tnsr::I&lt; DataVector, VolumeDim, Frame::Logical &gt; * &gt; logical_coords, const Mesh&lt; VolumeDim &gt; &amp;mesh) noexcept</div><div class="ttdoc">Compute the logical coordinates in an Element.</div></div>
<div class="ttc" id="astructFrame_1_1Logical_html"><div class="ttname"><a href="structFrame_1_1Logical.html">Frame::Logical</a></div><div class="ttdef"><b>Definition:</b> IndexType.hpp:42</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga8773fe02f44b68af479cb53dd4383978"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga8773fe02f44b68af479cb53dd4383978">INSTANTIATE_MAPS_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_FUNCTIONS(MAPS_TUPLE, SOURCE_FRAME, TARGET_FRAMES_TUPLE, TYPES_TUPLE)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:267</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga4b765bb8483842f249f114d3704985a4"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga4b765bb8483842f249f114d3704985a4">unnormalized_face_normal</a></div><div class="ttdeci">void unnormalized_face_normal(gsl::not_null&lt; tnsr::i&lt; DataVector, VolumeDim, TargetFrame &gt; * &gt; result, const Mesh&lt; VolumeDim - 1 &gt; &amp;interface_mesh, const ElementMap&lt; VolumeDim, TargetFrame &gt; &amp;map, const Direction&lt; VolumeDim &gt; &amp;direction) noexcept</div><div class="ttdoc">Compute the outward grid normal on a face of an Element.</div></div>
<div class="ttc" id="agroup__UtilitiesGroup_html_gad7b776398a66e9a6bd561c8decf08b47"><div class="ttname"><a href="group__UtilitiesGroup.html#gad7b776398a66e9a6bd561c8decf08b47">GENERATE_INSTANTIATIONS</a></div><div class="ttdeci">#define GENERATE_INSTANTIATIONS(INSTANTIATION_MACRO,...)</div><div class="ttdoc">Macro useful for generating many explicit instantiations of function or class templates.</div><div class="ttdef"><b>Definition:</b> GenerateInstantiations.hpp:160</div></div>
<div class="ttc" id="agroup__ComputationalDomainGroup_html_ga39eb7361b3bcfe317a1576be5141b10f"><div class="ttname"><a href="group__ComputationalDomainGroup.html#ga39eb7361b3bcfe317a1576be5141b10f">INSTANTIATE_MAPS_SIMPLE_FUNCTIONS</a></div><div class="ttdeci">#define INSTANTIATE_MAPS_SIMPLE_FUNCTIONS(_, data)</div><div class="ttdoc">Generate instantiations of member functions of the CoordinateMap class template.</div><div class="ttdef"><b>Definition:</b> MapInstantiationMacros.hpp:78</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
