<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.17"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: DataBox</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="./MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v2020.12.07</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="versioning_and_releases.html">
              <i class="octicon octicon-versions"></i><span>Releases</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">DataBox</div>  </div>
</div><!--header-->
<div class="contents">

<p>Documentation, functions, metafunctions, and classes necessary for using DataBox.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedb"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedb.html">db</a></td></tr>
<tr class="memdesc:namespacedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for DataBox related things. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__databox.html">db::is_databox&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if a type <code>T</code> is as db::DataBox.  <a href="structdb_1_1is__databox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdb_1_1DataBox_3_01tmpl_1_1list_3_01Tags_8_8_8_01_4_01_4.html">db::DataBox&lt; tmpl::list&lt; Tags... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A DataBox stores objects that can be retrieved by using Tags.  <a href="classdb_1_1DataBox_3_01tmpl_1_1list_3_01Tags_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDeferred.html">Deferred&lt; Rt, MakeConstReference &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides deferred or lazy evaluation of a function or function object, as well as efficient storage of an object that is mutable.  <a href="classDeferred.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1Subitems.html">db::Subitems&lt; Tag, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1SimpleTag.html">db::SimpleTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a struct as a simple tag by inheriting from this.  <a href="structdb_1_1SimpleTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1BaseTag.html">db::BaseTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a (usually) empty struct as a base tag by inheriting from this.  <a href="structdb_1_1BaseTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1PrefixTag.html">db::PrefixTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a struct as a prefix tag by inheriting from this.  <a href="structdb_1_1PrefixTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1ComputeTag.html">db::ComputeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark a struct as a compute tag by inheriting from this.  <a href="structdb_1_1ComputeTag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__compute__tag.html">db::is_compute_tag&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>Tag</code> derives off of <a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a>.  <a href="structdb_1_1is__compute__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__simple__tag.html">db::is_simple_tag&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>Tag</code> is a simple tag.  <a href="structdb_1_1is__simple__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__non__base__tag.html">db::is_non_base_tag&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>Tag</code> is not a base tag.  <a href="structdb_1_1is__non__base__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__tag.html">db::is_tag&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>Tag</code> is a DataBox tag, i.e. a <a class="el" href="structdb_1_1BaseTag.html" title="Mark a (usually) empty struct as a base tag by inheriting from this.">BaseTag</a>, <a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">SimpleTag</a>, or <a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">ComputeTag</a>.  <a href="structdb_1_1is__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdb_1_1is__base__tag.html">db::is_base_tag&lt; Tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>Tag</code> is a base DataBox tag.  <a href="structdb_1_1is__base__tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae49658baea2a211ae5959c7f555f3125"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename DataBoxType &gt; </td></tr>
<tr class="memitem:gae49658baea2a211ae5959c7f555f3125"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gae49658baea2a211ae5959c7f555f3125">db::tag_is_retrievable</a> = tmpl::any&lt; typename DataBoxType::tags_list, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt; tmpl::pin&lt; Tag &gt;, tmpl::_1 &gt; &gt;</td></tr>
<tr class="separator:gae49658baea2a211ae5959c7f555f3125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd63e443e3b9a35ef6307d0ded3890ca"><td class="memTemplParams" colspan="2"><a id="gabd63e443e3b9a35ef6307d0ded3890ca"></a>
template&lt;typename... Tags&gt; </td></tr>
<tr class="memitem:gabd63e443e3b9a35ef6307d0ded3890ca"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags</a> = tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt;</td></tr>
<tr class="memdesc:gabd63e443e3b9a35ef6307d0ded3890ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Tags to remove from the DataBox. <br /></td></tr>
<tr class="separator:gabd63e443e3b9a35ef6307d0ded3890ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dc674ba575ece4a8be1c23fa6c2cdcb"><td class="memTemplParams" colspan="2"><a id="ga3dc674ba575ece4a8be1c23fa6c2cdcb"></a>
template&lt;typename... Tags&gt; </td></tr>
<tr class="memitem:ga3dc674ba575ece4a8be1c23fa6c2cdcb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a> = tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt;</td></tr>
<tr class="memdesc:ga3dc674ba575ece4a8be1c23fa6c2cdcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Tags to add to the DataBox. <br /></td></tr>
<tr class="separator:ga3dc674ba575ece4a8be1c23fa6c2cdcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade77b58510b00c1d6d3efa10b3b4d460"><td class="memTemplParams" colspan="2"><a id="gade77b58510b00c1d6d3efa10b3b4d460"></a>
template&lt;typename... Tags&gt; </td></tr>
<tr class="memitem:gade77b58510b00c1d6d3efa10b3b4d460"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gade77b58510b00c1d6d3efa10b3b4d460">db::MutateTags</a> = tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt;</td></tr>
<tr class="memdesc:gade77b58510b00c1d6d3efa10b3b4d460"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Tags to mutate in the DataBox. <br /></td></tr>
<tr class="separator:gade77b58510b00c1d6d3efa10b3b4d460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9be9c6f7cd3f4ba85f3abfd28bf5d16"><td class="memTemplParams" colspan="2"><a id="gaa9be9c6f7cd3f4ba85f3abfd28bf5d16"></a>
template&lt;typename... Tags&gt; </td></tr>
<tr class="memitem:gaa9be9c6f7cd3f4ba85f3abfd28bf5d16"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gaa9be9c6f7cd3f4ba85f3abfd28bf5d16">db::ArgumentTags</a> = tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt;</td></tr>
<tr class="memdesc:gaa9be9c6f7cd3f4ba85f3abfd28bf5d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Tags to get from the DataBox to be used as arguments. <br /></td></tr>
<tr class="separator:gaa9be9c6f7cd3f4ba85f3abfd28bf5d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64597eb7f5df0dc4d99698289265b1a7"><td class="memTemplParams" colspan="2"><a id="ga64597eb7f5df0dc4d99698289265b1a7"></a>
template&lt;typename... Tags&gt; </td></tr>
<tr class="memitem:ga64597eb7f5df0dc4d99698289265b1a7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a> = tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt;</td></tr>
<tr class="memdesc:ga64597eb7f5df0dc4d99698289265b1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of Compute Item Tags to add to the DataBox. <br /></td></tr>
<tr class="separator:ga64597eb7f5df0dc4d99698289265b1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4b7a5c6b2c698b6f59ce687f310d893"><td class="memTemplParams" colspan="2"><a id="gaf4b7a5c6b2c698b6f59ce687f310d893"></a>
template&lt;class TagList &gt; </td></tr>
<tr class="memitem:gaf4b7a5c6b2c698b6f59ce687f310d893"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gaf4b7a5c6b2c698b6f59ce687f310d893">db::get_compute_items</a> = tmpl::filter&lt; TagList, <a class="el" href="structdb_1_1is__compute__tag.html">db::is_compute_tag</a>&lt; tmpl::_1 &gt; &gt;</td></tr>
<tr class="memdesc:gaf4b7a5c6b2c698b6f59ce687f310d893"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the Tags that are compute items from the <code>TagList</code> <br /></td></tr>
<tr class="separator:gaf4b7a5c6b2c698b6f59ce687f310d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga926bf301c2efbdf4f50cc7064163adee"><td class="memTemplParams" colspan="2"><a id="ga926bf301c2efbdf4f50cc7064163adee"></a>
template&lt;class TagList &gt; </td></tr>
<tr class="memitem:ga926bf301c2efbdf4f50cc7064163adee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga926bf301c2efbdf4f50cc7064163adee">db::get_items</a> = tmpl::filter&lt; TagList, tmpl::not_&lt; tmpl::bind&lt; <a class="el" href="structdb_1_1is__compute__tag.html">db::is_compute_tag</a>, tmpl::_1 &gt; &gt;&gt;</td></tr>
<tr class="memdesc:ga926bf301c2efbdf4f50cc7064163adee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the Tags that are items from the <code>TagList</code> <br /></td></tr>
<tr class="separator:ga926bf301c2efbdf4f50cc7064163adee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06bf4d7e004bfe4376cee28fe1710955"><td class="memTemplParams" colspan="2"><a id="ga06bf4d7e004bfe4376cee28fe1710955"></a>
template&lt;class TagList &gt; </td></tr>
<tr class="memitem:ga06bf4d7e004bfe4376cee28fe1710955"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga06bf4d7e004bfe4376cee28fe1710955">db::compute_databox_type</a> = typename detail::compute_dbox_type&lt; <a class="el" href="group__DataBoxGroup.html#ga926bf301c2efbdf4f50cc7064163adee">get_items</a>&lt; TagList &gt;, <a class="el" href="group__DataBoxGroup.html#gaf4b7a5c6b2c698b6f59ce687f310d893">get_compute_items</a>&lt; TagList &gt; &gt;::type</td></tr>
<tr class="memdesc:ga06bf4d7e004bfe4376cee28fe1710955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the DataBox that would be constructed from the <code>TagList</code> of tags. <br /></td></tr>
<tr class="separator:ga06bf4d7e004bfe4376cee28fe1710955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga258d81b1a545746fb8e039349da6baae"><td class="memTemplParams" colspan="2">template&lt;typename... MutateTags, typename TagList , typename Invokable , typename... Args&gt; </td></tr>
<tr class="memitem:ga258d81b1a545746fb8e039349da6baae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae">db::mutate</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBox&lt; TagList &gt; * &gt; box, Invokable &amp;&amp;invokable, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga258d81b1a545746fb8e039349da6baae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows changing the state of one or more non-computed elements in the DataBox.  <a href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae">More...</a><br /></td></tr>
<tr class="separator:ga258d81b1a545746fb8e039349da6baae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae08744824ea7df89224f128b2080c5b1"><td class="memTemplParams" colspan="2">template&lt;typename Tag , typename TagList &gt; </td></tr>
<tr class="memitem:gae08744824ea7df89224f128b2080c5b1"><td class="memTemplItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a> (const DataBox&lt; TagList &gt; &amp;box) noexcept</td></tr>
<tr class="memdesc:gae08744824ea7df89224f128b2080c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the item with tag <code>Tag</code> from the DataBox.  <a href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">More...</a><br /></td></tr>
<tr class="separator:gae08744824ea7df89224f128b2080c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190fd7a31cd2424701e03faea2d03247"><td class="memTemplParams" colspan="2">template&lt;typename AddSimpleTags , typename AddComputeTags  = tmpl::list&lt;&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:ga190fd7a31cd2424701e03faea2d03247"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga190fd7a31cd2424701e03faea2d03247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DataBox.  <a href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">More...</a><br /></td></tr>
<tr class="separator:ga190fd7a31cd2424701e03faea2d03247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa58e24d7ed3a46c5d6a1dadd96b939a2"><td class="memTemplParams" colspan="2">template&lt;typename RemoveTags , typename AddTags  = tmpl::list&lt;&gt;, typename AddComputeTags  = tmpl::list&lt;&gt;, typename TagsList , typename... Args&gt; </td></tr>
<tr class="memitem:gaa58e24d7ed3a46c5d6a1dadd96b939a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a> (db::DataBox&lt; TagsList &gt; &amp;&amp;box, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:gaa58e24d7ed3a46c5d6a1dadd96b939a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new DataBox from an existing one adding or removing items and compute items.  <a href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">More...</a><br /></td></tr>
<tr class="separator:gaa58e24d7ed3a46c5d6a1dadd96b939a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f0c81cb84017884c1099f2523f3d697"><td class="memTemplParams" colspan="2">template&lt;typename ArgumentTags , typename F , typename BoxTags , typename... Args&gt; </td></tr>
<tr class="memitem:ga1f0c81cb84017884c1099f2523f3d697"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">db::apply</a> (F &amp;&amp;f, const DataBox&lt; BoxTags &gt; &amp;box, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga1f0c81cb84017884c1099f2523f3d697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the invokable <code>f</code> with argument Tags <code>TagsList</code> from DataBox <code>box</code>  <a href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">More...</a><br /></td></tr>
<tr class="separator:ga1f0c81cb84017884c1099f2523f3d697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66830cd09b37b839d33569bb81738fb7"><td class="memTemplParams" colspan="2">template&lt;typename MutateTags , typename ArgumentTags , typename F , typename BoxTags , typename... Args&gt; </td></tr>
<tr class="memitem:ga66830cd09b37b839d33569bb81738fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7">db::mutate_apply</a> (F &amp;&amp;f, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBox&lt; BoxTags &gt; * &gt; box, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga66830cd09b37b839d33569bb81738fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the invokable <code>f</code> mutating items <code>MutateTags</code> and taking as additional arguments <code>ArgumentTags</code> and <code>args</code>.  <a href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7">More...</a><br /></td></tr>
<tr class="separator:ga66830cd09b37b839d33569bb81738fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a56543f1f309293c4c8cbe4749d252"><td class="memTemplParams" colspan="2">template&lt;size_t VolumeDim, typename TagsList , typename... TagsToSlice&gt; </td></tr>
<tr class="memitem:gab0a56543f1f309293c4c8cbe4749d252"><td class="memTemplItemLeft" align="right" valign="top">Variables&lt; tmpl::list&lt; TagsToSlice... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gab0a56543f1f309293c4c8cbe4749d252">db::data_on_slice</a> (const db::DataBox&lt; TagsList &gt; &amp;box, const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;element_extents, const size_t sliced_dim, const size_t fixed_index, tmpl::list&lt; TagsToSlice... &gt;) noexcept</td></tr>
<tr class="memdesc:gab0a56543f1f309293c4c8cbe4749d252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slices volume <code>Tensor</code>s from a <code>DataBox</code> into a <code>Variables</code>  <a href="group__DataBoxGroup.html#gab0a56543f1f309293c4c8cbe4749d252">More...</a><br /></td></tr>
<tr class="separator:gab0a56543f1f309293c4c8cbe4749d252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab16ffafee767da670cf8af4b26da919e"><td class="memTemplParams" colspan="2">template&lt;typename Rt , typename Fp , typename... Args&gt; </td></tr>
<tr class="memitem:gab16ffafee767da670cf8af4b26da919e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDeferred.html">Deferred</a>&lt; Rt &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gab16ffafee767da670cf8af4b26da919e">make_deferred</a> (Fp f, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:gab16ffafee767da670cf8af4b26da919e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a deferred function call object.  <a href="group__DataBoxGroup.html#gab16ffafee767da670cf8af4b26da919e">More...</a><br /></td></tr>
<tr class="separator:gab16ffafee767da670cf8af4b26da919e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f660914f4e986327a7ec1a61dddb2f4"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ga2f660914f4e986327a7ec1a61dddb2f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga2f660914f4e986327a7ec1a61dddb2f4">db::tag_name</a> () noexcept</td></tr>
<tr class="memdesc:ga2f660914f4e986327a7ec1a61dddb2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of a DataBox tag, including prefixes.  <a href="group__DataBoxGroup.html#ga2f660914f4e986327a7ec1a61dddb2f4">More...</a><br /></td></tr>
<tr class="separator:ga2f660914f4e986327a7ec1a61dddb2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e2e76fbb38d402dd8b995ec77fcf28b"><td class="memTemplParams" colspan="2"><a id="ga3e2e76fbb38d402dd8b995ec77fcf28b"></a>
template&lt;typename MutateTagList , typename BoxTags , typename... Args&gt; </td></tr>
<tr class="memitem:ga3e2e76fbb38d402dd8b995ec77fcf28b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga3e2e76fbb38d402dd8b995ec77fcf28b">Initialization::mutate_assign</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; db::DataBox&lt; BoxTags &gt; * &gt; box, Args &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:ga3e2e76fbb38d402dd8b995ec77fcf28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a mutation to the <a class="el" href="group__DataBoxGroup.html">DataBox</a> <code>box</code>, assigning the <code>args</code> to the tags in <code>MutateTagList</code> in order. <br /></td></tr>
<tr class="separator:ga3e2e76fbb38d402dd8b995ec77fcf28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaf08e8efa66093a627029fdaba7bb294a"><td class="memTemplParams" colspan="2"><a id="gaf08e8efa66093a627029fdaba7bb294a"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:gaf08e8efa66093a627029fdaba7bb294a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gaf08e8efa66093a627029fdaba7bb294a">db::is_compute_tag_v</a> = <a class="el" href="structdb_1_1is__compute__tag.html">is_compute_tag</a>&lt;Tag&gt;::value</td></tr>
<tr class="memdesc:gaf08e8efa66093a627029fdaba7bb294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>Tag</code> derives from <a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a>. <br /></td></tr>
<tr class="separator:gaf08e8efa66093a627029fdaba7bb294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62726b32bacb220f674e6670e6b18a55"><td class="memTemplParams" colspan="2"><a id="ga62726b32bacb220f674e6670e6b18a55"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ga62726b32bacb220f674e6670e6b18a55"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga62726b32bacb220f674e6670e6b18a55">db::is_simple_tag_v</a> = <a class="el" href="structdb_1_1is__simple__tag.html">is_simple_tag</a>&lt;Tag&gt;::value</td></tr>
<tr class="memdesc:ga62726b32bacb220f674e6670e6b18a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>Tag</code> is a simple tag. <br /></td></tr>
<tr class="separator:ga62726b32bacb220f674e6670e6b18a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a8de52ba18f30d29747e6090343e9d"><td class="memTemplParams" colspan="2"><a id="gae0a8de52ba18f30d29747e6090343e9d"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:gae0a8de52ba18f30d29747e6090343e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#gae0a8de52ba18f30d29747e6090343e9d">db::is_non_base_tag_v</a> = <a class="el" href="structdb_1_1is__non__base__tag.html">is_non_base_tag</a>&lt;Tag&gt;::value</td></tr>
<tr class="memdesc:gae0a8de52ba18f30d29747e6090343e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>Tag</code> is not a base tag. <br /></td></tr>
<tr class="separator:gae0a8de52ba18f30d29747e6090343e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bbbd9f851791413787e1725a2d4b4e"><td class="memTemplParams" colspan="2"><a id="ga50bbbd9f851791413787e1725a2d4b4e"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ga50bbbd9f851791413787e1725a2d4b4e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga50bbbd9f851791413787e1725a2d4b4e">db::is_tag_v</a> = <a class="el" href="structdb_1_1is__tag.html">is_tag</a>&lt;Tag&gt;::value</td></tr>
<tr class="memdesc:ga50bbbd9f851791413787e1725a2d4b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>Tag</code> is a DataBox tag. <br /></td></tr>
<tr class="separator:ga50bbbd9f851791413787e1725a2d4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7596f360400e87035ea297109f7ab645"><td class="memTemplParams" colspan="2"><a id="ga7596f360400e87035ea297109f7ab645"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ga7596f360400e87035ea297109f7ab645"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__DataBoxGroup.html#ga7596f360400e87035ea297109f7ab645">db::is_base_tag_v</a> = <a class="el" href="structdb_1_1is__base__tag.html">is_base_tag</a>&lt;Tag&gt;::value</td></tr>
<tr class="memdesc:ga7596f360400e87035ea297109f7ab645"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if <code>Tag</code> is a base tag. <br /></td></tr>
<tr class="separator:ga7596f360400e87035ea297109f7ab645"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Documentation, functions, metafunctions, and classes necessary for using DataBox. </p>
<p>DataBox is a heterogeneous compile-time associative container with lazy evaluation of functions. DataBox can not only store data, but can also store functions that depend on other data inside the DataBox. The functions will be evaluated when the data they return is requested. The result is cached, and if a dependency of the function is modified the cache is invalidated.</p>
<h4><a class="anchor" id="autotoc_md2"></a>
Simple and Compute Tags and Their Items</h4>
<p>The compile-time keys are <code>struct</code>s called tags, while the values are called items. Tags are quite minimal, containing only the information necessary to store the data and evaluate functions. There are two different types of tags that a DataBox can hold: simple tags and compute tags. Simple tags are for data that is inserted into the DataBox at the time of creation, while compute tags are for data that will be computed from a function when the compute item is retrieved. If a compute item is never retrieved from the DataBox then it is never evaluated.</p>
<p>Simple tags must have a member type alias <code>type</code> that is the type of the data to be stored and a <code>static <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name()</code> method that returns the name of the tag. Simple tags must inherit from <code><a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a></code>.</p>
<p>Compute tags must also have a <code>static <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name()</code> method that returns the name of the tag, but they cannot have a <code>type</code> type alias. Instead, compute tags must have a static member function or static member function pointer named <code>function</code>. <code>function</code> can be a function template if necessary. The <code>function</code> must take all its arguments by <code>const</code> reference. The arguments to the function are retrieved using tags from the DataBox that the compute tag is in. The tags for the arguments are set in the member type alias <code>argument_tags</code>, which must be a <code>tmpl::list</code> of the tags corresponding to each argument. Note that the order of the tags in the <code>argument_list</code> is the order that they will be passed to the function. Compute tags must inherit from <code><a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a></code>.</p>
<p>Here is an example of a simple tag:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Tag0 : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
</div><!-- fragment --><p> and an example of a compute tag with a function pointer:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MutateVariablesCompute : MutateVariables, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = MutateVariables;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> <span class="keyword">function</span> = mutate_variables;</div>
<div class="line">  <span class="keyword">using</span> return_type = Variables&lt;</div>
<div class="line">      tmpl::list&lt;test_databox_tags::ScalarTag, test_databox_tags::VectorTag&gt;&gt;;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Tag0&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the compute item's tag is inline then the compute item is of the form:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Lambda0 : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Lambda0Compute : Lambda0, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Lambda0;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) {</div>
<div class="line">    *result = 3.0 * a;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Tag0&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Compute tags can also have their functions be overloaded on the type of its arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag&gt;</div>
<div class="line"><span class="keyword">struct </span>OverloadTypeCompute : OverloadType&lt;ArgumentTag&gt;, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = OverloadType&lt;ArgumentTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; a) noexcept {</div>
<div class="line">    *result = 5 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) noexcept {</div>
<div class="line">    *result = 3.2 * a;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;ArgumentTag&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> or be overloaded on the number of arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag0, <span class="keyword">typename</span> ArgumentTag1 = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">struct </span>OverloadNumberOfArgsCompute</div>
<div class="line">    : OverloadNumberOfArgs&lt;ArgumentTag0, ArgumentTag1&gt;,</div>
<div class="line">      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = OverloadNumberOfArgs&lt;ArgumentTag0, ArgumentTag1&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) noexcept {</div>
<div class="line">    *result = 3.2 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a, <span class="keyword">const</span> <span class="keywordtype">double</span> b) noexcept {</div>
<div class="line">    *result = a * b;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags =</div>
<div class="line">      tmpl::conditional_t&lt;std::is_same_v&lt;void, ArgumentTag1&gt;,</div>
<div class="line">                          tmpl::list&lt;ArgumentTag0&gt;,</div>
<div class="line">                          tmpl::list&lt;ArgumentTag0, ArgumentTag1&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Compute tag function templates are implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag&gt;</div>
<div class="line"><span class="keyword">struct </span>TemplateCompute : Template&lt;ArgumentTag&gt;, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Template&lt;ArgumentTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> ArgumentTag::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;T*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> T&amp; a) noexcept {</div>
<div class="line">    *result = 5 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;ArgumentTag&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Finally, overloading, function templates, and variadic functions can be combined to produce extremely generic compute tags. The below compute tag takes as template parameters a parameter pack of integers, which is used to specify several of the arguments. The function is overloaded for the single argument case, and a variadic function template is provided for the multiple arguments case. Note that in practice few compute tags will be this complex.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> VectorBaseIndex = 0, <span class="keywordtype">int</span>... VectorBaseExtraIndices&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayCompute : Array&lt;I, sizeof...(VectorBaseExtraIndices) == 0</div>
<div class="line">                                   ? 3</div>
<div class="line">                                   : 2 + sizeof...(VectorBaseExtraIndices)&gt;,</div>
<div class="line">                      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Array&lt;I, <span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == 0</div>
<div class="line">                            ? 3</div>
<div class="line">                            : 2 + <span class="keyword">sizeof</span>...(VectorBaseExtraIndices)&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> base::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;std::array&lt;int, 3&gt;</a>*&gt; result,</div>
<div class="line">                       <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t) noexcept {</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]), -8}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;int, 2 + <span class="keyword">sizeof</span>...(Args)&gt;*&gt; result,</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t, <span class="keyword">const</span> Args&amp;... args) noexcept {</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == <span class="keyword">sizeof</span>...(Args));</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]),</div>
<div class="line">                <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(args[0])...}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;VectorBase&lt;VectorBaseIndex&gt;,</div>
<div class="line">                                   VectorBase&lt;VectorBaseExtraIndices&gt;...&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md3"></a>
Subitems and Prefix Tags</h4>
<p>A simple or compute tag might also hold a collection of data, such as a container of <code>Tensor</code>s. In many cases you will want to be able to retrieve individual elements of the collection from the DataBox without having to first retrieve the collection. The infrastructure that allows for this is called <em>Subitems</em>. The subitems of the parent tag must refer to a subset of the data inside the parent tag, e.g. one <code>Tensor</code> in the collection. If the parent tag is <code>Parent</code> and the subitems tags are <code>Sub&lt;0&gt;, Sub&lt;1&gt;</code>, then when <code>Parent</code> is added to the DataBox, so are <code>Sub&lt;0&gt;</code> and <code>Sub&lt;1&gt;</code>. This means the retrieval mechanisms described below will work on <code>Parent</code>, <code>Sub&lt;0&gt;</code>, and <code>Sub&lt;1&gt;</code>.</p>
<p>Subitems specify requirements on the tags they act on. For example, there could be a requirement that all tags with a certain type are to be treated as a Subitems. Let's say that the <code>Parent</code> tag holds a <code>Variables</code>, and <code>Variables</code> can be used with the Subitems infrastructure to add the nested <code>Tensor</code>s. Then all tags that hold a <code>Variables</code> will have their subitems added into the DataBox. To add a new type as a subitem the <code><a class="el" href="structdb_1_1Subitems.html">db::Subitems</a></code> struct must be specialized. See the documentation of <code><a class="el" href="structdb_1_1Subitems.html">db::Subitems</a></code> for more details.</p>
<p>The DataBox also supports <em>prefix tags</em>, which are commonly used for items that are related to a different item by some operation. Specifically, say you have a tag <code>MyTensor</code> and you want to also have the time derivative of <code>MyTensor</code>, then you can use the prefix tag <code>dt</code> to get <code>dt&lt;MyTensor&gt;</code>. The benefit of a prefix tag over, say, a separate tag <code>dtMyTensor</code> is that prefix tags can be added and removed by the compute tags acting on the original tag. Prefix tags can also be composed, so a second time derivative would be <code>dt&lt;dt&lt;MyTensor&gt;&gt;</code>. The net result of the prefix tags infrastructure is that the compute tag that returns <code>dt&lt;MyTensor&gt;</code> only needs to know its input tags, it knows how to name its output based off that. In addition to the normal things a simple or a compute tag must hold, prefix tags must have a nested type alias <code>tag</code>, which is the tag being prefixed. Prefix tags must also inherit from <code><a class="el" href="structdb_1_1PrefixTag.html" title="Mark a struct as a prefix tag by inheriting from this.">db::PrefixTag</a></code> in addition to inheriting from <code><a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a></code> or <code><a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a></code>.</p>
<h4><a class="anchor" id="autotoc_md4"></a>
Creating a DataBox</h4>
<p>You should never call the constructor of a DataBox directly. DataBox construction is quite complicated and the helper functions <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> and <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> should be used instead. <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> is used to construct a new DataBox. It takes two typelists as explicit template parameters, the first being a list of the simple tags to add and the second being a list of compute tags to add. If no compute tags are being added then only the simple tags list must be specified. The tags lists should be passed as <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a>&lt;<a class="el" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb" title="List of Tags to add to the DataBox.">db::AddSimpleTags</a>&lt;simple_tags...&gt;, <a class="el" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7" title="List of Compute Item Tags to add to the DataBox.">db::AddComputeTags</a>&lt;compute_tags...&gt;&gt;</code>. The arguments to <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> are the initial values of the simple tags and must be passed in the same order as the tags in the <code><a class="el" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb" title="List of Tags to add to the DataBox.">db::AddSimpleTags</a></code> list. If the type of an argument passed to <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> does not match the type of the corresponding simple tag a static assertion will trigger. Here is an example of how to use <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;,</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a>&lt;test_databox_tags::Tag4Compute,</div>
<div class="line">                           test_databox_tags::Tag5Compute,</div>
<div class="line">                           test_databox_tags::Lambda0Compute,</div>
<div class="line">                           test_databox_tags::Lambda1Compute&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
</div><!-- fragment --><p> To create a new DataBox from an existing one use the <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> function. The only time a new DataBox needs to be created is when tags need to be removed or added. Like <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code>, <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> also takes typelists as explicit template parameter. The first template parameter is the list of tags to be removed, which is passed using <code><a class="el" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca" title="List of Tags to remove from the DataBox.">db::RemoveTags</a></code>, second is the list of simple tags to add, and the third is the list of compute tags to add. If tags are only removed then only the first template parameter needs to be specified. If tags are being removed and only simple tags are being added then only the first two template parameters need to be specified. Here is an example of removing a tag or compute tag:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box = db::create_from&lt;db::RemoveTags&lt;test_databox_tags::Tag1&gt;&gt;(</div>
<div class="line">        std::move(original_box));</div>
</div><!-- fragment --><p> Adding a simple tag is done using:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;test_databox_tags::Tag3&gt;</a>&gt;(</div>
<div class="line">            std::move(original_box), <span class="stringliteral">&quot;Yet another test string&quot;</span>s);</div>
</div><!-- fragment --><p> Adding a compute tag is done using:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> simple_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;, <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;&gt;</a>,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;test_databox_tags::Tag4Compute&gt;</a>&gt;(</div>
<div class="line">            std::move(simple_box));</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md5"></a>
Accessing and Mutating Items</h4>
<p>To retrieve an item from a DataBox use the <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> function. <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> will always return a <code>const</code> reference to the object stored in the DataBox and will also have full type information available. This means you are able to use <code>const auto&amp;</code> when retrieving tags from the DataBox. For example, </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tag0 = db::get&lt;test_databox_tags::Tag0&gt;(original_box);</div>
</div><!-- fragment --><p> If you want to mutate the value of a simple item in the DataBox use <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>. Any compute item that depends on the mutated item will have its cached value invalidated and be recomputed the next time it is retrieved from the DataBox. <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> takes a parameter pack of tags to mutate as explicit template parameters, a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> of the DataBox whose items will be mutated, an invokable, and extra arguments to forward to the invokable. The invokable takes the arguments passed from the DataBox by <code>const <a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> while the extra arguments are forwarded to the invokable. The invokable is not allowed to retrieve anything from the DataBox, so any items must be passed as extra arguments using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> to retrieve them. For example,</p>
<div class="fragment"><div class="line">  db::mutate&lt;test_databox_tags::Tag0, test_databox_tags::Tag1&gt;(</div>
<div class="line">      <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;original_box),</div>
<div class="line">      [](<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> tag0,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; tag1,</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> compute_tag0) {</div>
<div class="line">        CHECK(6.28 == compute_tag0);</div>
<div class="line">        *tag0 = 10.32;</div>
<div class="line">        (*tag1)[0] = 837.2;</div>
<div class="line">      },</div>
<div class="line">      db::get&lt;test_databox_tags::Tag4&gt;(original_box));</div>
<div class="line">  CHECK(10.32 == db::get&lt;test_databox_tags::Tag0&gt;(original_box));</div>
<div class="line">  CHECK(837.2 == db::get&lt;test_databox_tags::Tag1&gt;(original_box)[0]);</div>
</div><!-- fragment --><p> In addition to retrieving items using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> and mutating them using <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>, there is a facility to invoke an invokable with tags from the DataBox. <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> takes a <code>tmpl::list</code> of tags as an explicit template parameter, will retrieve all the tags from the DataBox passed in and then invoke the invokable with the items in the tag list. Similarly, <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> invokes the invokable but allows for mutating some of the tags. See the documentation of <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> and <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> for examples of how to use them.</p>
<h4><a class="anchor" id="autotoc_md6"></a>
The Base Tags Mechanism</h4>
<p>Retrieving items by tags should not require knowing whether the item being retrieved was computed using a compute tag or simply added using a simple tag. The framework that handles this falls under the umbrella term <em>base tags</em>. The reason is that a compute tag can inherit from a simple tag with the same item type, and then calls to <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> with the simple tag can be used to retrieve the compute item as well. That is, say you have a compute tag <code>ArrayCompute</code> that derives off of the simple tag <code>Array</code>, then you can retrieve the compute tag <code>ArrayCompute</code> and <code>Array</code> by calling <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a>&lt;Array&gt;(box)</code>. The base tags mechanism requires that only one <code>Array</code> tag be present in the DataBox, otherwise a static assertion is triggered.</p>
<p>The inheritance idea can be generalized further with what are called base tags. A base tag is an empty <code>struct</code> that inherits from <code><a class="el" href="structdb_1_1BaseTag.html" title="Mark a (usually) empty struct as a base tag by inheriting from this.">db::BaseTag</a></code>. Any simple or compute item that derives off of the base tag can be retrieved using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>. Consider the following <code>VectorBase</code> and <code>Vector</code> tag:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>VectorBase : <a class="code" href="structdb_1_1BaseTag.html">db::BaseTag</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>Vector : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a>, VectorBase&lt;I&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> It is possible to retrieve <code>Vector&lt;1&gt;</code> from the DataBox using <code>VectorBase&lt;1&gt;</code>. Most importantly, base tags can also be used in compute tag arguments, as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> VectorBaseIndex = 0, <span class="keywordtype">int</span>... VectorBaseExtraIndices&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayCompute : Array&lt;I, sizeof...(VectorBaseExtraIndices) == 0</div>
<div class="line">                                   ? 3</div>
<div class="line">                                   : 2 + sizeof...(VectorBaseExtraIndices)&gt;,</div>
<div class="line">                      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Array&lt;I, <span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == 0</div>
<div class="line">                            ? 3</div>
<div class="line">                            : 2 + <span class="keyword">sizeof</span>...(VectorBaseExtraIndices)&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> base::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;std::array&lt;int, 3&gt;</a>*&gt; result,</div>
<div class="line">                       <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t) noexcept {</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]), -8}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;int, 2 + <span class="keyword">sizeof</span>...(Args)&gt;*&gt; result,</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t, <span class="keyword">const</span> Args&amp;... args) noexcept {</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == <span class="keyword">sizeof</span>...(Args));</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]),</div>
<div class="line">                <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(args[0])...}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;VectorBase&lt;VectorBaseIndex&gt;,</div>
<div class="line">                                   VectorBase&lt;VectorBaseExtraIndices&gt;...&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> As shown in the code example, the base tag mechanism works with function template compute tags, enabling generic programming to be combined with the lazy evaluation and automatic dependency analysis offered by the DataBox. To really demonstrate the power of base tags, let's also have <code>ArrayComputeBase</code> inherit from a simple tag <code>Array</code>, which inherits from a base tag <code>ArrayBase</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayBase : <a class="code" href="structdb_1_1BaseTag.html">db::BaseTag</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">size_t</span> Size = 3&gt;</div>
<div class="line"><span class="keyword">struct </span>Array : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a>, ArrayBase&lt;I&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, Size&gt;</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> To start, let's create a DataBox that holds a <code>Vector&lt;0&gt;</code> and an <code>ArrayComputeBase&lt;0&gt;</code> (the concrete tag must be used when creating the DataBox, not the base tags), retrieve the tags using the base tag mechanism, including mutating <code>Vector&lt;0&gt;</code>, and then verifying that the dependencies are handled correctly.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> box = db::create&lt;db::AddSimpleTags&lt;TestTags::Vector&lt;0&gt;&gt;,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;0&gt;</a>&gt;&gt;(</div>
<div class="line">      <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-10.0, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving simple tag Vector&lt;0&gt; using base tag VectorBase&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::VectorBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-10.0, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving compute tag ArrayCompute&lt;0&gt; using simple tag Array&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::Array&lt;0&gt;&gt;(box) == <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, -10, -8}});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check mutating Vector&lt;0&gt; using VectorBase&lt;0&gt;</span></div>
<div class="line">  db::mutate&lt;TestTags::VectorBase&lt;0&gt;&gt;(</div>
<div class="line">      <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;box), [](<span class="keyword">const</span> <span class="keyword">auto</span> vector) { (*vector)[0] = 101.8; });</div>
<div class="line"> </div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::VectorBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{101.8, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving ArrayCompute&lt;0&gt; using base tag ArrayBase&lt;0&gt;.</span></div>
<div class="line">  <span class="comment">// ArrayCompute was reset after mutating Vector&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::ArrayBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving ArrayCompute&lt;0&gt; using simple tag Array&lt;0&gt;.</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::Array&lt;0&gt;&gt;(box) == <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::ArrayCompute&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
</div><!-- fragment --><p> Notice that we are able to retrieve <code>ArrayComputeBase&lt;0&gt;</code> with <code>ArrayBase&lt;0&gt;</code> and <code>Array&lt;0&gt;</code>. We were also able to mutate <code>Vector&lt;0&gt;</code> using <code>VectorBase&lt;0&gt;</code>.</p>
<p>We can even remove tags using their base tags with <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box6 = <a class="code" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a>&lt;</div>
<div class="line">      <a class="code" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags&lt;TestTags::VectorBase&lt;1&gt;</a>, TestTags::VectorBase&lt;2&gt;,</div>
<div class="line">                     TestTags::ArrayBase&lt;1&gt;&gt;&gt;(</div>
<div class="line">      <a class="code" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a>&lt;</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags&lt;&gt;</a>,</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;TestTags::Vector&lt;1&gt;</a>, TestTags::Vector&lt;2&gt;&gt;,</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;1, 0, 1, 2&gt;</a>&gt;&gt;(</div>
<div class="line">          db::create&lt;db::AddSimpleTags&lt;TestTags::Vector&lt;0&gt;&gt;,</div>
<div class="line">                     <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;0&gt;</a>&gt;&gt;(</div>
<div class="line">              <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{101.8, 10.0}),</div>
<div class="line">          <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-7.1, 8.9}, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{408.8, -73.2}));</div>
</div><!-- fragment --><p> The base tags infrastructure even works with Subitems. Even if you mutate the subitem of a parent using a base tag, the appropriate compute item caches will be invalidated.</p>
<dl class="section note"><dt>Note</dt><dd>All of the base tags infrastructure works for <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>, <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>, <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> and <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>.</dd></dl>
<p>DataBox is a heterogeneous compile-time associative container with lazy evaluation of functions. DataBox can not only store data, but can also store functions that depend on other data inside the DataBox. The functions will be evaluated when the data they return is requested. The result is cached, and if a dependency of the function is modified the cache is invalidated.</p>
<h4><a class="anchor" id="autotoc_md150"></a>
Simple and Compute Tags and Their Items</h4>
<p>The compile-time keys are <code>struct</code>s called tags, while the values are called items. Tags are quite minimal, containing only the information necessary to store the data and evaluate functions. There are two different types of tags that a DataBox can hold: simple tags and compute tags. Simple tags are for data that is inserted into the DataBox at the time of creation, while compute tags are for data that will be computed from a function when the compute item is retrieved. If a compute item is never retrieved from the DataBox then it is never evaluated.</p>
<p>Simple tags must have a member type alias <code>type</code> that is the type of the data to be stored and a <code>static <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name()</code> method that returns the name of the tag. Simple tags must inherit from <code><a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a></code>.</p>
<p>Compute tags must also have a <code>static <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> name()</code> method that returns the name of the tag, but they cannot have a <code>type</code> type alias. Instead, compute tags must have a static member function or static member function pointer named <code>function</code>. <code>function</code> can be a function template if necessary. The <code>function</code> must take all its arguments by <code>const</code> reference. The arguments to the function are retrieved using tags from the DataBox that the compute tag is in. The tags for the arguments are set in the member type alias <code>argument_tags</code>, which must be a <code>tmpl::list</code> of the tags corresponding to each argument. Note that the order of the tags in the <code>argument_list</code> is the order that they will be passed to the function. Compute tags must inherit from <code><a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a></code>.</p>
<p>Here is an example of a simple tag:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Tag0 : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
</div><!-- fragment --><p> and an example of a compute tag with a function pointer:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MutateVariablesCompute : MutateVariables, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = MutateVariables;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> <span class="keyword">function</span> = mutate_variables;</div>
<div class="line">  <span class="keyword">using</span> return_type = Variables&lt;</div>
<div class="line">      tmpl::list&lt;test_databox_tags::ScalarTag, test_databox_tags::VectorTag&gt;&gt;;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Tag0&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> If the compute item's tag is inline then the compute item is of the form:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>Lambda0 : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a> {</div>
<div class="line">  <span class="keyword">using</span> type = double;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>Lambda0Compute : Lambda0, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Lambda0;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) {</div>
<div class="line">    *result = 3.0 * a;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;Tag0&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Compute tags can also have their functions be overloaded on the type of its arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag&gt;</div>
<div class="line"><span class="keyword">struct </span>OverloadTypeCompute : OverloadType&lt;ArgumentTag&gt;, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = OverloadType&lt;ArgumentTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">int</span>&amp; a) noexcept {</div>
<div class="line">    *result = 5 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) noexcept {</div>
<div class="line">    *result = 3.2 * a;</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;ArgumentTag&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> or be overloaded on the number of arguments:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag0, <span class="keyword">typename</span> ArgumentTag1 = <span class="keywordtype">void</span>&gt;</div>
<div class="line"><span class="keyword">struct </span>OverloadNumberOfArgsCompute</div>
<div class="line">    : OverloadNumberOfArgs&lt;ArgumentTag0, ArgumentTag1&gt;,</div>
<div class="line">      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = OverloadNumberOfArgs&lt;ArgumentTag0, ArgumentTag1&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = double;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a) noexcept {</div>
<div class="line">    *result = 3.2 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">double</span> a, <span class="keyword">const</span> <span class="keywordtype">double</span> b) noexcept {</div>
<div class="line">    *result = a * b;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags =</div>
<div class="line">      tmpl::conditional_t&lt;std::is_same_v&lt;void, ArgumentTag1&gt;,</div>
<div class="line">                          tmpl::list&lt;ArgumentTag0&gt;,</div>
<div class="line">                          tmpl::list&lt;ArgumentTag0, ArgumentTag1&gt;&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Compute tag function templates are implemented as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgumentTag&gt;</div>
<div class="line"><span class="keyword">struct </span>TemplateCompute : Template&lt;ArgumentTag&gt;, <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Template&lt;ArgumentTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> ArgumentTag::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;T*&gt;</a> result,</div>
<div class="line">                                 <span class="keyword">const</span> T&amp; a) noexcept {</div>
<div class="line">    *result = 5 * a;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;ArgumentTag&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Finally, overloading, function templates, and variadic functions can be combined to produce extremely generic compute tags. The below compute tag takes as template parameters a parameter pack of integers, which is used to specify several of the arguments. The function is overloaded for the single argument case, and a variadic function template is provided for the multiple arguments case. Note that in practice few compute tags will be this complex.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> VectorBaseIndex = 0, <span class="keywordtype">int</span>... VectorBaseExtraIndices&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayCompute : Array&lt;I, sizeof...(VectorBaseExtraIndices) == 0</div>
<div class="line">                                   ? 3</div>
<div class="line">                                   : 2 + sizeof...(VectorBaseExtraIndices)&gt;,</div>
<div class="line">                      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Array&lt;I, <span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == 0</div>
<div class="line">                            ? 3</div>
<div class="line">                            : 2 + <span class="keyword">sizeof</span>...(VectorBaseExtraIndices)&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> base::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;std::array&lt;int, 3&gt;</a>*&gt; result,</div>
<div class="line">                       <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t) noexcept {</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]), -8}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;int, 2 + <span class="keyword">sizeof</span>...(Args)&gt;*&gt; result,</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t, <span class="keyword">const</span> Args&amp;... args) noexcept {</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == <span class="keyword">sizeof</span>...(Args));</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]),</div>
<div class="line">                <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(args[0])...}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;VectorBase&lt;VectorBaseIndex&gt;,</div>
<div class="line">                                   VectorBase&lt;VectorBaseExtraIndices&gt;...&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md151"></a>
Subitems and Prefix Tags</h4>
<p>A simple or compute tag might also hold a collection of data, such as a container of <code>Tensor</code>s. In many cases you will want to be able to retrieve individual elements of the collection from the DataBox without having to first retrieve the collection. The infrastructure that allows for this is called <em>Subitems</em>. The subitems of the parent tag must refer to a subset of the data inside the parent tag, e.g. one <code>Tensor</code> in the collection. If the parent tag is <code>Parent</code> and the subitems tags are <code>Sub&lt;0&gt;, Sub&lt;1&gt;</code>, then when <code>Parent</code> is added to the DataBox, so are <code>Sub&lt;0&gt;</code> and <code>Sub&lt;1&gt;</code>. This means the retrieval mechanisms described below will work on <code>Parent</code>, <code>Sub&lt;0&gt;</code>, and <code>Sub&lt;1&gt;</code>.</p>
<p>Subitems specify requirements on the tags they act on. For example, there could be a requirement that all tags with a certain type are to be treated as a Subitems. Let's say that the <code>Parent</code> tag holds a <code>Variables</code>, and <code>Variables</code> can be used with the Subitems infrastructure to add the nested <code>Tensor</code>s. Then all tags that hold a <code>Variables</code> will have their subitems added into the DataBox. To add a new type as a subitem the <code><a class="el" href="structdb_1_1Subitems.html">db::Subitems</a></code> struct must be specialized. See the documentation of <code><a class="el" href="structdb_1_1Subitems.html">db::Subitems</a></code> for more details.</p>
<p>The DataBox also supports <em>prefix tags</em>, which are commonly used for items that are related to a different item by some operation. Specifically, say you have a tag <code>MyTensor</code> and you want to also have the time derivative of <code>MyTensor</code>, then you can use the prefix tag <code>dt</code> to get <code>dt&lt;MyTensor&gt;</code>. The benefit of a prefix tag over, say, a separate tag <code>dtMyTensor</code> is that prefix tags can be added and removed by the compute tags acting on the original tag. Prefix tags can also be composed, so a second time derivative would be <code>dt&lt;dt&lt;MyTensor&gt;&gt;</code>. The net result of the prefix tags infrastructure is that the compute tag that returns <code>dt&lt;MyTensor&gt;</code> only needs to know its input tags, it knows how to name its output based off that. In addition to the normal things a simple or a compute tag must hold, prefix tags must have a nested type alias <code>tag</code>, which is the tag being prefixed. Prefix tags must also inherit from <code><a class="el" href="structdb_1_1PrefixTag.html" title="Mark a struct as a prefix tag by inheriting from this.">db::PrefixTag</a></code> in addition to inheriting from <code><a class="el" href="structdb_1_1SimpleTag.html" title="Mark a struct as a simple tag by inheriting from this.">db::SimpleTag</a></code> or <code><a class="el" href="structdb_1_1ComputeTag.html" title="Mark a struct as a compute tag by inheriting from this.">db::ComputeTag</a></code>.</p>
<h4><a class="anchor" id="autotoc_md152"></a>
Creating a DataBox</h4>
<p>You should never call the constructor of a DataBox directly. DataBox construction is quite complicated and the helper functions <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> and <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> should be used instead. <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> is used to construct a new DataBox. It takes two typelists as explicit template parameters, the first being a list of the simple tags to add and the second being a list of compute tags to add. If no compute tags are being added then only the simple tags list must be specified. The tags lists should be passed as <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a>&lt;<a class="el" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb" title="List of Tags to add to the DataBox.">db::AddSimpleTags</a>&lt;simple_tags...&gt;, <a class="el" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7" title="List of Compute Item Tags to add to the DataBox.">db::AddComputeTags</a>&lt;compute_tags...&gt;&gt;</code>. The arguments to <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> are the initial values of the simple tags and must be passed in the same order as the tags in the <code><a class="el" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb" title="List of Tags to add to the DataBox.">db::AddSimpleTags</a></code> list. If the type of an argument passed to <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code> does not match the type of the corresponding simple tag a static assertion will trigger. Here is an example of how to use <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code>:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;,</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a>&lt;test_databox_tags::Tag4Compute,</div>
<div class="line">                           test_databox_tags::Tag5Compute,</div>
<div class="line">                           test_databox_tags::Lambda0Compute,</div>
<div class="line">                           test_databox_tags::Lambda1Compute&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
</div><!-- fragment --><p> To create a new DataBox from an existing one use the <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> function. The only time a new DataBox needs to be created is when tags need to be removed or added. Like <code><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">db::create</a></code>, <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code> also takes typelists as explicit template parameter. The first template parameter is the list of tags to be removed, which is passed using <code><a class="el" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca" title="List of Tags to remove from the DataBox.">db::RemoveTags</a></code>, second is the list of simple tags to add, and the third is the list of compute tags to add. If tags are only removed then only the first template parameter needs to be specified. If tags are being removed and only simple tags are being added then only the first two template parameters need to be specified. Here is an example of removing a tag or compute tag:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box = db::create_from&lt;db::RemoveTags&lt;test_databox_tags::Tag1&gt;&gt;(</div>
<div class="line">        std::move(original_box));</div>
</div><!-- fragment --><p> Adding a simple tag is done using:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;test_databox_tags::Tag3&gt;</a>&gt;(</div>
<div class="line">            std::move(original_box), <span class="stringliteral">&quot;Yet another test string&quot;</span>s);</div>
</div><!-- fragment --><p> Adding a compute tag is done using:</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> simple_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;, <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;&gt;</a>,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;test_databox_tags::Tag4Compute&gt;</a>&gt;(</div>
<div class="line">            std::move(simple_box));</div>
</div><!-- fragment --> <h4><a class="anchor" id="autotoc_md153"></a>
Accessing and Mutating Items</h4>
<p>To retrieve an item from a DataBox use the <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> function. <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> will always return a <code>const</code> reference to the object stored in the DataBox and will also have full type information available. This means you are able to use <code>const auto&amp;</code> when retrieving tags from the DataBox. For example, </p><div class="fragment"><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; tag0 = db::get&lt;test_databox_tags::Tag0&gt;(original_box);</div>
</div><!-- fragment --><p> If you want to mutate the value of a simple item in the DataBox use <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>. Any compute item that depends on the mutated item will have its cached value invalidated and be recomputed the next time it is retrieved from the DataBox. <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code> takes a parameter pack of tags to mutate as explicit template parameters, a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> of the DataBox whose items will be mutated, an invokable, and extra arguments to forward to the invokable. The invokable takes the arguments passed from the DataBox by <code>const <a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a></code> while the extra arguments are forwarded to the invokable. The invokable is not allowed to retrieve anything from the DataBox, so any items must be passed as extra arguments using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> to retrieve them. For example,</p>
<div class="fragment"><div class="line">  db::mutate&lt;test_databox_tags::Tag0, test_databox_tags::Tag1&gt;(</div>
<div class="line">      <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;original_box),</div>
<div class="line">      [](<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> tag0,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; tag1,</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> compute_tag0) {</div>
<div class="line">        CHECK(6.28 == compute_tag0);</div>
<div class="line">        *tag0 = 10.32;</div>
<div class="line">        (*tag1)[0] = 837.2;</div>
<div class="line">      },</div>
<div class="line">      db::get&lt;test_databox_tags::Tag4&gt;(original_box));</div>
<div class="line">  CHECK(10.32 == db::get&lt;test_databox_tags::Tag0&gt;(original_box));</div>
<div class="line">  CHECK(837.2 == db::get&lt;test_databox_tags::Tag1&gt;(original_box)[0]);</div>
</div><!-- fragment --><p> In addition to retrieving items using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> and mutating them using <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>, there is a facility to invoke an invokable with tags from the DataBox. <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> takes a <code>tmpl::list</code> of tags as an explicit template parameter, will retrieve all the tags from the DataBox passed in and then invoke the invokable with the items in the tag list. Similarly, <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> invokes the invokable but allows for mutating some of the tags. See the documentation of <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> and <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code> for examples of how to use them.</p>
<h4><a class="anchor" id="autotoc_md154"></a>
The Base Tags Mechanism</h4>
<p>Retrieving items by tags should not require knowing whether the item being retrieved was computed using a compute tag or simply added using a simple tag. The framework that handles this falls under the umbrella term <em>base tags</em>. The reason is that a compute tag can inherit from a simple tag with the same item type, and then calls to <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code> with the simple tag can be used to retrieve the compute item as well. That is, say you have a compute tag <code>ArrayCompute</code> that derives off of the simple tag <code>Array</code>, then you can retrieve the compute tag <code>ArrayCompute</code> and <code>Array</code> by calling <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a>&lt;Array&gt;(box)</code>. The base tags mechanism requires that only one <code>Array</code> tag be present in the DataBox, otherwise a static assertion is triggered.</p>
<p>The inheritance idea can be generalized further with what are called base tags. A base tag is an empty <code>struct</code> that inherits from <code><a class="el" href="structdb_1_1BaseTag.html" title="Mark a (usually) empty struct as a base tag by inheriting from this.">db::BaseTag</a></code>. Any simple or compute item that derives off of the base tag can be retrieved using <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>. Consider the following <code>VectorBase</code> and <code>Vector</code> tag:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>VectorBase : <a class="code" href="structdb_1_1BaseTag.html">db::BaseTag</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>Vector : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a>, VectorBase&lt;I&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> It is possible to retrieve <code>Vector&lt;1&gt;</code> from the DataBox using <code>VectorBase&lt;1&gt;</code>. Most importantly, base tags can also be used in compute tag arguments, as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">int</span> VectorBaseIndex = 0, <span class="keywordtype">int</span>... VectorBaseExtraIndices&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayCompute : Array&lt;I, sizeof...(VectorBaseExtraIndices) == 0</div>
<div class="line">                                   ? 3</div>
<div class="line">                                   : 2 + sizeof...(VectorBaseExtraIndices)&gt;,</div>
<div class="line">                      <a class="code" href="structdb_1_1ComputeTag.html">db::ComputeTag</a> {</div>
<div class="line">  <span class="keyword">using</span> base = Array&lt;I, <span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == 0</div>
<div class="line">                            ? 3</div>
<div class="line">                            : 2 + <span class="keyword">sizeof</span>...(VectorBaseExtraIndices)&gt;;</div>
<div class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> base::type;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;std::array&lt;int, 3&gt;</a>*&gt; result,</div>
<div class="line">                       <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t) noexcept {</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]), -8}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <span class="keyword">function</span>(</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a>&lt;int, 2 + <span class="keyword">sizeof</span>...(Args)&gt;*&gt; result,</div>
<div class="line">      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t, <span class="keyword">const</span> Args&amp;... args) noexcept {</div>
<div class="line">    static_assert(<span class="keyword">sizeof</span>...(VectorBaseExtraIndices) == <span class="keyword">sizeof</span>...(Args));</div>
<div class="line">    *result = {{<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t.size()), <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(t[0]),</div>
<div class="line">                <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(args[0])...}};</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;VectorBase&lt;VectorBaseIndex&gt;,</div>
<div class="line">                                   VectorBase&lt;VectorBaseExtraIndices&gt;...&gt;;</div>
<div class="line">};</div>
</div><!-- fragment --><p> As shown in the code example, the base tag mechanism works with function template compute tags, enabling generic programming to be combined with the lazy evaluation and automatic dependency analysis offered by the DataBox. To really demonstrate the power of base tags, let's also have <code>ArrayComputeBase</code> inherit from a simple tag <code>Array</code>, which inherits from a base tag <code>ArrayBase</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I&gt;</div>
<div class="line"><span class="keyword">struct </span>ArrayBase : <a class="code" href="structdb_1_1BaseTag.html">db::BaseTag</a> {};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> I, <span class="keywordtype">size_t</span> Size = 3&gt;</div>
<div class="line"><span class="keyword">struct </span>Array : <a class="code" href="structdb_1_1SimpleTag.html">db::SimpleTag</a>, ArrayBase&lt;I&gt; {</div>
<div class="line">  <span class="keyword">using</span> type = <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, Size&gt;</a>;</div>
<div class="line">};</div>
</div><!-- fragment --><p> To start, let's create a DataBox that holds a <code>Vector&lt;0&gt;</code> and an <code>ArrayComputeBase&lt;0&gt;</code> (the concrete tag must be used when creating the DataBox, not the base tags), retrieve the tags using the base tag mechanism, including mutating <code>Vector&lt;0&gt;</code>, and then verifying that the dependencies are handled correctly.</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> box = db::create&lt;db::AddSimpleTags&lt;TestTags::Vector&lt;0&gt;&gt;,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;0&gt;</a>&gt;&gt;(</div>
<div class="line">      <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-10.0, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving simple tag Vector&lt;0&gt; using base tag VectorBase&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::VectorBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-10.0, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving compute tag ArrayCompute&lt;0&gt; using simple tag Array&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::Array&lt;0&gt;&gt;(box) == <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, -10, -8}});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check mutating Vector&lt;0&gt; using VectorBase&lt;0&gt;</span></div>
<div class="line">  db::mutate&lt;TestTags::VectorBase&lt;0&gt;&gt;(</div>
<div class="line">      <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;box), [](<span class="keyword">const</span> <span class="keyword">auto</span> vector) { (*vector)[0] = 101.8; });</div>
<div class="line"> </div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::VectorBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{101.8, 10.0});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving ArrayCompute&lt;0&gt; using base tag ArrayBase&lt;0&gt;.</span></div>
<div class="line">  <span class="comment">// ArrayCompute was reset after mutating Vector&lt;0&gt;</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::ArrayBase&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check retrieving ArrayCompute&lt;0&gt; using simple tag Array&lt;0&gt;.</span></div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::Array&lt;0&gt;&gt;(box) == <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
<div class="line">  CHECK(<a class="code" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a>&lt;TestTags::ArrayCompute&lt;0&gt;&gt;(box) ==</div>
<div class="line">        <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/array.html">std::array&lt;int, 3&gt;</a>{{2, 101, -8}});</div>
</div><!-- fragment --><p> Notice that we are able to retrieve <code>ArrayComputeBase&lt;0&gt;</code> with <code>ArrayBase&lt;0&gt;</code> and <code>Array&lt;0&gt;</code>. We were also able to mutate <code>Vector&lt;0&gt;</code> using <code>VectorBase&lt;0&gt;</code>.</p>
<p>We can even remove tags using their base tags with <code><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">db::create_from</a></code>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box6 = <a class="code" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a>&lt;</div>
<div class="line">      <a class="code" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags&lt;TestTags::VectorBase&lt;1&gt;</a>, TestTags::VectorBase&lt;2&gt;,</div>
<div class="line">                     TestTags::ArrayBase&lt;1&gt;&gt;&gt;(</div>
<div class="line">      <a class="code" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a>&lt;</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags&lt;&gt;</a>,</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;TestTags::Vector&lt;1&gt;</a>, TestTags::Vector&lt;2&gt;&gt;,</div>
<div class="line">          <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;1, 0, 1, 2&gt;</a>&gt;&gt;(</div>
<div class="line">          db::create&lt;db::AddSimpleTags&lt;TestTags::Vector&lt;0&gt;&gt;,</div>
<div class="line">                     <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;TestTags::ArrayCompute&lt;0&gt;</a>&gt;&gt;(</div>
<div class="line">              <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{101.8, 10.0}),</div>
<div class="line">          <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{-7.1, 8.9}, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{408.8, -73.2}));</div>
</div><!-- fragment --><p> The base tags infrastructure even works with Subitems. Even if you mutate the subitem of a parent using a base tag, the appropriate compute item caches will be invalidated.</p>
<dl class="section note"><dt>Note</dt><dd>All of the base tags infrastructure works for <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a></code>, <code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">db::mutate</a></code>, <code><a class="el" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697" title="Apply the invokable f with argument Tags TagsList from DataBox box">db::apply</a></code> and <code><a class="el" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>. </dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae49658baea2a211ae5959c7f555f3125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49658baea2a211ae5959c7f555f3125">&#9670;&nbsp;</a></span>tag_is_retrievable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename DataBoxType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__DataBoxGroup.html#gae49658baea2a211ae5959c7f555f3125">db::tag_is_retrievable</a> = typedef tmpl::any&lt;typename DataBoxType::tags_list, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/is_base_of.html">std::is_base_of</a>&lt;tmpl::pin&lt;Tag&gt;, tmpl::_1&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equal to <code>true</code> if <code>Tag</code> can be retrieved from a <code>DataBox</code> of type <code>DataBoxType</code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1f0c81cb84017884c1099f2523f3d697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f0c81cb84017884c1099f2523f3d697">&#9670;&nbsp;</a></span>apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgumentTags , typename F , typename BoxTags , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto db::apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataBox&lt; BoxTags &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the invokable <code>f</code> with argument Tags <code>TagsList</code> from DataBox <code>box</code> </p>
<h3>Details</h3>
<p><code>f</code> must either be invokable with the arguments of type <code>db::const_item_type&lt;TagsList&gt;..., Args...</code> where the first pack expansion is over the elements in the type list <code>ArgumentTags</code>, or have a static <code>apply</code> function that is callable with the same types. If the class that implements the static <code>apply</code> functions also provides an <code>argument_tags</code> typelist, then it is used and no explicit <code>ArgumentTags</code> template parameter should be specified.</p>
<h3>Usage</h3>
<p>Given a function <code>func</code> that takes arguments of types <code>T1</code>, <code>T2</code>, <code>A1</code> and <code>A2</code>. Let the Tags for the quantities of types <code>T1</code> and <code>T2</code> in the DataBox <code>box</code> be <code>Tag1</code> and <code>Tag2</code>, and objects <code>a1</code> of type <code>A1</code> and <code>a2</code> of type <code>A2</code>, then </p><div class="fragment"><div class="line"><span class="keyword">auto</span> result = db::apply&lt;tmpl::list&lt;Tag1, Tag2&gt;&gt;(func, box, a1, a2);</div>
</div><!-- fragment --> <p><em>Returns:</em> <code>decltype(func(<a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a>&lt;Tag1&gt;(box), <a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a>&lt;Tag2&gt;(box), a1, a2))</code></p>
<p><em>Semantics:</em> For tags <code>Tags...</code> in a DataBox <code>box</code>, and a function <code>func</code> that takes <code>sizeof...(Tags)</code> arguments of types <code>db::const_item_type&lt;Tags&gt;...</code>, and <code>sizeof...(Args)</code> arguments of types <code>Args...</code>, </p><div class="fragment"><div class="line">result = func(box, db::get&lt;Tags&gt;(box)..., args...);</div>
</div><!-- fragment --><h3>Example</h3>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> check_result_args = [](<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; sample_string,</div>
<div class="line">                              <span class="keyword">const</span> <span class="keyword">auto</span>&amp; computed_string, <span class="keyword">const</span> <span class="keyword">auto</span>&amp; vector) {</div>
<div class="line">    CHECK(sample_string == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">    CHECK(computed_string == <span class="stringliteral">&quot;My Sample String6.28&quot;</span>s);</div>
<div class="line">    CHECK(vector == (<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}));</div>
<div class="line">  };</div>
<div class="line">  db::apply&lt;tmpl::list&lt;test_databox_tags::Tag2, test_databox_tags::Tag5&gt;&gt;(</div>
<div class="line">      check_result_args, original_box,</div>
<div class="line">      db::get&lt;test_databox_tags::Tag1&gt;(original_box));</div>
</div><!-- fragment --><p>Using a struct with an <code>apply</code> method: </p><div class="fragment"><div class="line">  <span class="keyword">struct </span>ApplyCallable {</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">apply</a>(<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; sample_string,</div>
<div class="line">                      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; computed_string,</div>
<div class="line">                      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; vector) noexcept {</div>
<div class="line">      CHECK(sample_string == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">      CHECK(computed_string == <span class="stringliteral">&quot;My Sample String6.28&quot;</span>s);</div>
<div class="line">      CHECK(vector == (<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  db::apply&lt;tmpl::list&lt;test_databox_tags::Tag2, test_databox_tags::Tag5&gt;&gt;(</div>
<div class="line">      ApplyCallable{}, original_box,</div>
<div class="line">      db::get&lt;test_databox_tags::Tag1&gt;(original_box));</div>
</div><!-- fragment --><p>If the class <code>F</code> has no state, you can also use the stateless overload of <code>apply</code>: </p><div class="fragment"><div class="line">  <span class="keyword">struct </span>StatelessApplyCallable {</div>
<div class="line">    <span class="keyword">using</span> argument_tags =</div>
<div class="line">        tmpl::list&lt;test_databox_tags::Tag2, test_databox_tags::Tag5&gt;;</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">apply</a>(<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; sample_string,</div>
<div class="line">                      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; computed_string,</div>
<div class="line">                      <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; vector) noexcept {</div>
<div class="line">      CHECK(sample_string == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">      CHECK(computed_string == <span class="stringliteral">&quot;My Sample String6.28&quot;</span>s);</div>
<div class="line">      CHECK(vector == (<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}));</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  db::apply&lt;StatelessApplyCallable&gt;(</div>
<div class="line">      original_box, db::get&lt;test_databox_tags::Tag1&gt;(original_box));</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>DataBox </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArgumentTags</td><td>typelist of Tags in the order that they are to be passed to <code>f</code> </td></tr>
    <tr><td class="paramname">F</td><td>The invokable to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga190fd7a31cd2424701e03faea2d03247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga190fd7a31cd2424701e03faea2d03247">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AddSimpleTags , typename AddComputeTags  = tmpl::list&lt;&gt;, typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto db::create </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new DataBox. </p>
<h3>Details</h3>
<p>Creates a new DataBox holding types Tags::type filled with the arguments passed to the function. Compute items must be added so that the dependencies of a compute item are added before the compute item. For example, say you have compute items <code>A</code> and <code>B</code> where <code>B</code> depends on <code>A</code>, then you must add them using <code><a class="el" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7" title="List of Compute Item Tags to add to the DataBox.">db::AddComputeTags</a>&lt;A, B&gt;</code>.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;,</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a>&lt;test_databox_tags::Tag4Compute,</div>
<div class="line">                           test_databox_tags::Tag5Compute,</div>
<div class="line">                           test_databox_tags::Lambda0Compute,</div>
<div class="line">                           test_databox_tags::Lambda1Compute&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2" title="Create a new DataBox from an existing one adding or removing items and compute items.">create_from</a></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">AddSimpleTags</td><td>the tags of the args being added </td></tr>
    <tr><td class="paramname">AddComputeTags</td><td>list of <a class="el" href="structdb_1_1ComputeTag.html">compute item tags</a> to add to the DataBox </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>the data to be added to the DataBox </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa58e24d7ed3a46c5d6a1dadd96b939a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa58e24d7ed3a46c5d6a1dadd96b939a2">&#9670;&nbsp;</a></span>create_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RemoveTags , typename AddTags  = tmpl::list&lt;&gt;, typename AddComputeTags  = tmpl::list&lt;&gt;, typename TagsList , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto db::create_from </td>
          <td>(</td>
          <td class="paramtype">db::DataBox&lt; TagsList &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new DataBox from an existing one adding or removing items and compute items. </p>
<h3>Example</h3>
<p>Removing an item or compute item is done using: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box = db::create_from&lt;db::RemoveTags&lt;test_databox_tags::Tag1&gt;&gt;(</div>
<div class="line">        std::move(original_box));</div>
</div><!-- fragment --><p>Adding an item is done using: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> original_box = create_original_box();</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;test_databox_tags::Tag3&gt;</a>&gt;(</div>
<div class="line">            std::move(original_box), <span class="stringliteral">&quot;Yet another test string&quot;</span>s);</div>
</div><!-- fragment --><p>Adding a compute item is done using: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> simple_box = <a class="code" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a>&lt;</div>
<div class="line">        <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a>&lt;test_databox_tags::Tag0, test_databox_tags::Tag1,</div>
<div class="line">                          test_databox_tags::Tag2&gt;&gt;(</div>
<div class="line">        3.14, <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>{8.7, 93.2, 84.7}, <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; box =</div>
<div class="line">        db::create_from&lt;db::RemoveTags&lt;&gt;, <a class="code" href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags&lt;&gt;</a>,</div>
<div class="line">                        <a class="code" href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags&lt;test_databox_tags::Tag4Compute&gt;</a>&gt;(</div>
<div class="line">            std::move(simple_box));</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247" title="Create a new DataBox.">create</a> DataBox</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RemoveTags</td><td>typelist of Tags to remove </td></tr>
    <tr><td class="paramname">AddTags</td><td>typelist of Tags corresponding to the arguments to be added </td></tr>
    <tr><td class="paramname">AddComputeTags</td><td>list of <a class="el" href="structdb_1_1ComputeTag.html">compute item tags</a> to add to the DataBox </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box</td><td>the DataBox the new box should be based off </td></tr>
    <tr><td class="paramname">args</td><td>the values for the items to add to the DataBox </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> DataBox like <code>box</code> but altered by RemoveTags and AddTags </p>

</div>
</div>
<a id="gab0a56543f1f309293c4c8cbe4749d252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0a56543f1f309293c4c8cbe4749d252">&#9670;&nbsp;</a></span>data_on_slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t VolumeDim, typename TagsList , typename... TagsToSlice&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Variables&lt;tmpl::list&lt;TagsToSlice...&gt; &gt; db::data_on_slice </td>
          <td>(</td>
          <td class="paramtype">const db::DataBox&lt; TagsList &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndex.html">Index</a>&lt; VolumeDim &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_extents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>sliced_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>fixed_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tmpl::list&lt; TagsToSlice... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Slices volume <code>Tensor</code>s from a <code>DataBox</code> into a <code>Variables</code> </p>
<p>The slice has a constant logical coordinate in direction <code>sliced_dim</code>, slicing the volume at <code>fixed_index</code> in that dimension. For example, to get the lower boundary of <code>sliced_dim</code>, pass <code>0</code> for <code>fixed_index</code>; to get the upper boundary, pass <code>extents[sliced_dim] - 1</code>. The last argument to the function is the typelist holding the tags to slice.</p>
<div class="fragment"><div class="line">      <a class="code" href="group__DataBoxGroup.html#gab0a56543f1f309293c4c8cbe4749d252">db::data_on_slice</a>(box, extents, 0, x_offset,</div>
<div class="line">                        tmpl::list&lt;DataBoxTest_detail::vector&gt;{})</div>
</div><!-- fragment -->
</div>
</div>
<a id="gae08744824ea7df89224f128b2080c5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae08744824ea7df89224f128b2080c5b1">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag , typename TagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto&amp; db::get </td>
          <td>(</td>
          <td class="paramtype">const DataBox&lt; TagList &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the item with tag <code>Tag</code> from the DataBox. </p>
<p><em>Requires:</em> Type <code>Tag</code> is one of the Tags corresponding to an object stored in the DataBox</p>
<p><em>Returns:</em> The object corresponding to the tag <code>Tag</code> </p>

</div>
</div>
<a id="gab16ffafee767da670cf8af4b26da919e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab16ffafee767da670cf8af4b26da919e">&#9670;&nbsp;</a></span>make_deferred()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rt , typename Fp , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDeferred.html">Deferred</a>&lt;Rt&gt; make_deferred </td>
          <td>(</td>
          <td class="paramtype">Fp&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a deferred function call object. </p>
<p>If creating a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> with a function object the call operator of the function object must be marked <code>const</code> currently. Since the function object will only be evaluated once there currently seems to be no reason to allow mutating call operators.</p>
<h3>Example</h3>
<p>The examples below use the following functions: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>func {</div>
<div class="line">  <span class="keywordtype">double</span> operator()()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 8.2; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> dummy() { <span class="keywordflow">return</span> 6.7; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>func2 {</div>
<div class="line">  <span class="keywordtype">double</span> operator()(<span class="keyword">const</span> <span class="keywordtype">double</span> t)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> t; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">double</span> lazy_function(<span class="keyword">const</span> <span class="keywordtype">double</span> t) { <span class="keywordflow">return</span> 10.0 * t; }</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> mutate_function(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> t, <span class="keyword">const</span> <span class="keywordtype">double</span> t0) {</div>
<div class="line">  *t = t0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> mutate_function_vector(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; t,</div>
<div class="line">                            <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>&amp; t0) {</div>
<div class="line">  <span class="keywordflow">if</span> (t-&gt;size() != t0.size()) {</div>
<div class="line">    t-&gt;resize(t0.size(), 0.0);</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Check the size again just to be sure the resize above happened.</span></div>
<div class="line">  CHECK(t-&gt;size() == t0.size());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; t-&gt;size(); ++i) {</div>
<div class="line">    t-&gt;operator[](i) = 10.0 * t0[i];</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>To create a <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> using a function object use: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def = make_deferred&lt;double&gt;(func{});</div>
<div class="line">  CHECK_FALSE(def.evaluated());</div>
<div class="line">  CHECK(8.2 == def.get());</div>
</div><!-- fragment --><p>or using a regular function: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = make_deferred&lt;double&gt;(dummy);</div>
<div class="line">  CHECK(6.7 == def2.get());</div>
</div><!-- fragment --><p> It is also possible to pass <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> objects to a deferred function call: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> def2 = make_deferred&lt;double&gt;(func2{}, 6.82);</div>
<div class="line">  <span class="keyword">auto</span> def3 = make_deferred&lt;double&gt;(lazy_function, def2);</div>
<div class="line">  CHECK(68.2 == def3.get());</div>
<div class="line">  CHECK(6.82 == def2.get());</div>
</div><!-- fragment --><p>in which case the first function will be evaluated just before the second function is evaluated.</p>
<p>In addition to functions that return by value, it is also possible to use functions that return by reference. The first argument of the function must then be a <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;Rt*&gt;</code>, and can be mutated inside the function. The mutating functions are primarily useful if <code>Rt</code> performs heap allocations and is frequently recomputed in a manner where the heap allocation could be avoided.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Rt</td><td>the type of the object returned by the function </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> <a class="el" href="classDeferred.html" title="Provides deferred or lazy evaluation of a function or function object, as well as efficient storage o...">Deferred</a> object that will lazily evaluate the function </p>

</div>
</div>
<a id="ga258d81b1a545746fb8e039349da6baae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258d81b1a545746fb8e039349da6baae">&#9670;&nbsp;</a></span>mutate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... MutateTags, typename TagList , typename Invokable , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void db::mutate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBox&lt; TagList &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Invokable &amp;&amp;&#160;</td>
          <td class="paramname"><em>invokable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows changing the state of one or more non-computed elements in the DataBox. </p>
<p><code><a class="el" href="group__DataBoxGroup.html#ga258d81b1a545746fb8e039349da6baae" title="Allows changing the state of one or more non-computed elements in the DataBox.">mutate()</a></code>'s first argument is the DataBox from which to retrieve the tags <code>MutateTags</code>. The objects corresponding to the <code>MutateTags</code> are then passed to <code>invokable</code>, which is a lambda or a function object taking as many arguments as there are <code>MutateTags</code> and with the arguments being of types <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;db::item_type&lt;MutateTags&gt;*&gt;...</code>. Inside the <code>invokable</code> no items can be retrieved from the DataBox <code>box</code>. This is to avoid confusing subtleties with order of evaluation of compute items, as well as dangling references. If an <code>invokable</code> needs read access to items in <code>box</code> they should be passed as additional arguments to <code>mutate</code>. Capturing them by reference in a lambda does not work because of a bug in GCC 6.3 and earlier. For a function object the read-only items can also be stored as const references inside the object by passing <code><a class="el" href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1" title="Retrieve the item with tag Tag from the DataBox.">db::get</a>&lt;TAG&gt;(t)</code> to the constructor.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">  db::mutate&lt;test_databox_tags::Tag0, test_databox_tags::Tag1&gt;(</div>
<div class="line">      <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;original_box),</div>
<div class="line">      [](<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;double*&gt;</a> tag0,</div>
<div class="line">         <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;double&gt;</a>*&gt; tag1,</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">double</span> compute_tag0) {</div>
<div class="line">        CHECK(6.28 == compute_tag0);</div>
<div class="line">        *tag0 = 10.32;</div>
<div class="line">        (*tag1)[0] = 837.2;</div>
<div class="line">      },</div>
<div class="line">      db::get&lt;test_databox_tags::Tag4&gt;(original_box));</div>
<div class="line">  CHECK(10.32 == db::get&lt;test_databox_tags::Tag0&gt;(original_box));</div>
<div class="line">  CHECK(837.2 == db::get&lt;test_databox_tags::Tag1&gt;(original_box)[0]);</div>
</div><!-- fragment -->
</div>
</div>
<a id="ga66830cd09b37b839d33569bb81738fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66830cd09b37b839d33569bb81738fb7">&#9670;&nbsp;</a></span>mutate_apply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MutateTags , typename ArgumentTags , typename F , typename BoxTags , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void db::mutate_apply </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBox&lt; BoxTags &gt; * &gt;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply the invokable <code>f</code> mutating items <code>MutateTags</code> and taking as additional arguments <code>ArgumentTags</code> and <code>args</code>. </p>
<h3>Details</h3>
<p><code>f</code> must either be invokable with the arguments of type <code><a class="el" href="classgsl_1_1not__null.html" title="Require a pointer to not be a nullptr">gsl::not_null</a>&lt;db::item_type&lt;MutateTags&gt;*&gt;..., db::const_item_type&lt;ArgumentTags&gt;..., Args...</code> where the first two pack expansions are over the elements in the typelists <code>MutateTags</code> and <code>ArgumentTags</code>, or have a static <code>apply</code> function that is callable with the same types. If the type of <code>f</code> specifies <code>return_tags</code> and <code>argument_tags</code> typelists, these are used for the <code>MutateTags</code> and <code>ArgumentTags</code>, respectively.</p>
<h3>Example</h3>
<p>An example of using <code>mutate_apply</code> with a lambda: </p><div class="fragment"><div class="line">    <a class="code" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7">db::mutate_apply</a>&lt;</div>
<div class="line">        tmpl::list&lt;test_databox_tags::ScalarTag, test_databox_tags::VectorTag&gt;,</div>
<div class="line">        tmpl::list&lt;test_databox_tags::Tag2&gt;&gt;(</div>
<div class="line">        [](<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;Scalar&lt;DataVector&gt;</a>*&gt; scalar,</div>
<div class="line">           <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null&lt;tnsr::I&lt;DataVector, 3&gt;</a>*&gt; vector,</div>
<div class="line">           <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; tag2) {</div>
<div class="line">          scalar-&gt;get() *= 2.0;</div>
<div class="line">          get&lt;0&gt;(*vector) *= 3.0;</div>
<div class="line">          get&lt;1&gt;(*vector) *= 4.0;</div>
<div class="line">          get&lt;2&gt;(*vector) *= 5.0;</div>
<div class="line">          CHECK(tag2 == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">        },</div>
<div class="line">        <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;box));</div>
</div><!-- fragment --><p> An example of a class with a static <code>apply</code> function </p><div class="fragment"><div class="line"><span class="keyword">struct </span>TestDataboxMutateApply {</div>
<div class="line">  <span class="comment">// delete copy semantics just to make sure it works. Not necessary in general.</span></div>
<div class="line">  TestDataboxMutateApply() = <span class="keywordflow">default</span>;</div>
<div class="line">  TestDataboxMutateApply(<span class="keyword">const</span> TestDataboxMutateApply&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  TestDataboxMutateApply&amp; operator=(<span class="keyword">const</span> TestDataboxMutateApply&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  TestDataboxMutateApply(TestDataboxMutateApply&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  TestDataboxMutateApply&amp; operator=(TestDataboxMutateApply&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  ~TestDataboxMutateApply() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// These typelists are used by the `db::mutate_apply` overload that does not</span></div>
<div class="line">  <span class="comment">// require these lists as template arguments</span></div>
<div class="line">  <span class="keyword">using</span> return_tags =</div>
<div class="line">      tmpl::list&lt;test_databox_tags::ScalarTag, test_databox_tags::VectorTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;test_databox_tags::Tag2&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">apply</a>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="code" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar&lt;DataVector&gt;</a>*&gt; scalar,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;tnsr::I&lt;DataVector, 3&gt;*&gt; vector,</div>
<div class="line">                    <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; tag2) noexcept {</div>
<div class="line">    scalar-&gt;get() *= 2.0;</div>
<div class="line">    get&lt;0&gt;(*vector) *= 3.0;</div>
<div class="line">    get&lt;1&gt;(*vector) *= 4.0;</div>
<div class="line">    get&lt;2&gt;(*vector) *= 5.0;</div>
<div class="line">    CHECK(tag2 == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>and how to use <code>mutate_apply</code> with the above class </p><div class="fragment"><div class="line">    <a class="code" href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7">db::mutate_apply</a>(TestDataboxMutateApply{}, <a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;box));</div>
</div><!-- fragment --><p>Note that the class exposes <code>return_tags</code> and <code>argument_tags</code> typelists, so we don't specify the template parameters explicitly. If the class <code>F</code> has no state, like in this example, </p><div class="fragment"><div class="line"><span class="keyword">struct </span>TestDataboxMutateApply {</div>
<div class="line">  <span class="comment">// delete copy semantics just to make sure it works. Not necessary in general.</span></div>
<div class="line">  TestDataboxMutateApply() = <span class="keywordflow">default</span>;</div>
<div class="line">  TestDataboxMutateApply(<span class="keyword">const</span> TestDataboxMutateApply&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  TestDataboxMutateApply&amp; operator=(<span class="keyword">const</span> TestDataboxMutateApply&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  TestDataboxMutateApply(TestDataboxMutateApply&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  TestDataboxMutateApply&amp; operator=(TestDataboxMutateApply&amp;&amp;) = <span class="keywordflow">default</span>;</div>
<div class="line">  ~TestDataboxMutateApply() = <span class="keywordflow">default</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// These typelists are used by the `db::mutate_apply` overload that does not</span></div>
<div class="line">  <span class="comment">// require these lists as template arguments</span></div>
<div class="line">  <span class="keyword">using</span> return_tags =</div>
<div class="line">      tmpl::list&lt;test_databox_tags::ScalarTag, test_databox_tags::VectorTag&gt;;</div>
<div class="line">  <span class="keyword">using</span> argument_tags = tmpl::list&lt;test_databox_tags::Tag2&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">apply</a>(<span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;<a class="code" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar&lt;DataVector&gt;</a>*&gt; scalar,</div>
<div class="line">                    <span class="keyword">const</span> <a class="code" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt;tnsr::I&lt;DataVector, 3&gt;*&gt; vector,</div>
<div class="line">                    <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>&amp; tag2) noexcept {</div>
<div class="line">    scalar-&gt;get() *= 2.0;</div>
<div class="line">    get&lt;0&gt;(*vector) *= 3.0;</div>
<div class="line">    get&lt;1&gt;(*vector) *= 4.0;</div>
<div class="line">    get&lt;2&gt;(*vector) *= 5.0;</div>
<div class="line">    CHECK(tag2 == <span class="stringliteral">&quot;My Sample String&quot;</span>s);</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p>you can also use the stateless overload of <code>mutate_apply</code>: </p><div class="fragment"><div class="line">    db::mutate_apply&lt;TestDataboxMutateApply&gt;(<a class="code" href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a>(&amp;box));</div>
</div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MutateTags</td><td>typelist of Tags to mutate </td></tr>
    <tr><td class="paramname">ArgumentTags</td><td>typelist of additional items to retrieve from the DataBox </td></tr>
    <tr><td class="paramname">F</td><td>The invokable to apply </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f660914f4e986327a7ec1a61dddb2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f660914f4e986327a7ec1a61dddb2f4">&#9670;&nbsp;</a></span>tag_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> db::tag_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of a DataBox tag, including prefixes. </p>
<h3>Details</h3>
<p>Given a DataBox tag returns the name of the DataBox tag as a <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a>. If the DataBox tag is also a <a class="el" href="structdb_1_1PrefixTag.html" title="Mark a struct as a prefix tag by inheriting from this.">PrefixTag</a> then the prefix is added.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tag</td><td>the DataBox tag whose name to get </td></tr>
  </table>
  </dd>
</dl>
<p><em>Returns:</em> string holding the DataBox tag's name </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__DataBoxGroup_html_ga1f0c81cb84017884c1099f2523f3d697"><div class="ttname"><a href="group__DataBoxGroup.html#ga1f0c81cb84017884c1099f2523f3d697">db::apply</a></div><div class="ttdeci">constexpr auto apply(F &amp;&amp;f, const DataBox&lt; BoxTags &gt; &amp;box, Args &amp;&amp;... args) noexcept</div><div class="ttdoc">Apply the invokable f with argument Tags TagsList from DataBox box</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1272</div></div>
<div class="ttc" id="astructdb_1_1ComputeTag_html"><div class="ttname"><a href="structdb_1_1ComputeTag.html">db::ComputeTag</a></div><div class="ttdoc">Mark a struct as a compute tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:157</div></div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga66830cd09b37b839d33569bb81738fb7"><div class="ttname"><a href="group__DataBoxGroup.html#ga66830cd09b37b839d33569bb81738fb7">db::mutate_apply</a></div><div class="ttdeci">constexpr void mutate_apply(F &amp;&amp;f, const gsl::not_null&lt; DataBox&lt; BoxTags &gt; * &gt; box, Args &amp;&amp;... args) noexcept</div><div class="ttdoc">Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1379</div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; double &gt;</a></div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga64597eb7f5df0dc4d99698289265b1a7"><div class="ttname"><a href="group__DataBoxGroup.html#ga64597eb7f5df0dc4d99698289265b1a7">db::AddComputeTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; AddComputeTags</div><div class="ttdoc">List of Compute Item Tags to add to the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1006</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_gae08744824ea7df89224f128b2080c5b1"><div class="ttname"><a href="group__DataBoxGroup.html#gae08744824ea7df89224f128b2080c5b1">db::get</a></div><div class="ttdeci">const auto &amp; get(const DataBox&lt; TagList &gt; &amp;box) noexcept</div><div class="ttdoc">Retrieve the item with tag Tag from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:969</div></div>
<div class="ttc" id="astructdb_1_1SimpleTag_html"><div class="ttname"><a href="structdb_1_1SimpleTag.html">db::SimpleTag</a></div><div class="ttdoc">Mark a struct as a simple tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:36</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga190fd7a31cd2424701e03faea2d03247"><div class="ttname"><a href="group__DataBoxGroup.html#ga190fd7a31cd2424701e03faea2d03247">db::create</a></div><div class="ttdeci">constexpr auto create(Args &amp;&amp;... args)</div><div class="ttdoc">Create a new DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1031</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_gab0a56543f1f309293c4c8cbe4749d252"><div class="ttname"><a href="group__DataBoxGroup.html#gab0a56543f1f309293c4c8cbe4749d252">db::data_on_slice</a></div><div class="ttdeci">Variables&lt; tmpl::list&lt; TagsToSlice... &gt; &gt; data_on_slice(const db::DataBox&lt; TagsList &gt; &amp;box, const Index&lt; VolumeDim &gt; &amp;element_extents, const size_t sliced_dim, const size_t fixed_index, tmpl::list&lt; TagsToSlice... &gt;) noexcept</div><div class="ttdoc">Slices volume Tensors from a DataBox into a Variables</div><div class="ttdef"><b>Definition:</b> DataOnSlice.hpp:33</div></div>
<div class="ttc" id="aarray_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/array.html">std::array</a></div></div>
<div class="ttc" id="astructdb_1_1BaseTag_html"><div class="ttname"><a href="structdb_1_1BaseTag.html">db::BaseTag</a></div><div class="ttdoc">Mark a (usually) empty struct as a base tag by inheriting from this.</div><div class="ttdef"><b>Definition:</b> Tag.hpp:69</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_ga3dc674ba575ece4a8be1c23fa6c2cdcb"><div class="ttname"><a href="group__DataBoxGroup.html#ga3dc674ba575ece4a8be1c23fa6c2cdcb">db::AddSimpleTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; AddSimpleTags</div><div class="ttdoc">List of Tags to add to the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:985</div></div>
<div class="ttc" id="agroup__TensorGroup_html_ga06ebcb38a1f13c246e53378b9e8959ce"><div class="ttname"><a href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a></div><div class="ttdeci">Tensor&lt; T, Symmetry&lt;&gt;, index_list&lt;&gt; &gt; Scalar</div><div class="ttdef"><b>Definition:</b> TypeAliases.hpp:21</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_gaa58e24d7ed3a46c5d6a1dadd96b939a2"><div class="ttname"><a href="group__DataBoxGroup.html#gaa58e24d7ed3a46c5d6a1dadd96b939a2">db::create_from</a></div><div class="ttdeci">constexpr auto create_from(db::DataBox&lt; TagsList &gt; &amp;&amp;box, Args &amp;&amp;... args) noexcept</div><div class="ttdoc">Create a new DataBox from an existing one adding or removing items and compute items.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:1165</div></div>
<div class="ttc" id="aGsl_8hpp_html_a649c6961f9146205c203e45d58fd0c4c"><div class="ttname"><a href="Gsl_8hpp.html#a649c6961f9146205c203e45d58fd0c4c">make_not_null</a></div><div class="ttdeci">gsl::not_null&lt; T * &gt; make_not_null(T *ptr) noexcept</div><div class="ttdoc">Construct a not_null from a pointer. Often this will be done as an implicit conversion,...</div><div class="ttdef"><b>Definition:</b> Gsl.hpp:880</div></div>
<div class="ttc" id="agroup__DataBoxGroup_html_gabd63e443e3b9a35ef6307d0ded3890ca"><div class="ttname"><a href="group__DataBoxGroup.html#gabd63e443e3b9a35ef6307d0ded3890ca">db::RemoveTags</a></div><div class="ttdeci">tmpl::flatten&lt; tmpl::list&lt; Tags... &gt; &gt; RemoveTags</div><div class="ttdoc">List of Tags to remove from the DataBox.</div><div class="ttdef"><b>Definition:</b> DataBox.hpp:978</div></div>
<div class="ttc" id="aclassgsl_1_1not__null_html"><div class="ttname"><a href="classgsl_1_1not__null.html">gsl::not_null</a></div><div class="ttdoc">Require a pointer to not be a nullptr</div><div class="ttdef"><b>Definition:</b> ReadSpecThirdOrderPiecewisePolynomial.hpp:13</div></div>
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2020
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
